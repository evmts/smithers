**SCOPE:** easy

# Code Review for Commit 80e34d7

**Date:** 2026-01-18 13:23:00
**Commit Message:** feat(issue): add broken build orchestration pattern

Design for multi-agent coordination when build breaks:
- Only 1 agent fixes, others wait 5min
- SQLite-based distributed lock pattern
- Demonstrates Smithers orchestration capabilities

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>

---

**STATUS:** Not implemented - still in design phase (`issues/broken-build-orchestration.md`)

This is a great design document that clearly outlines a common problem in multi-agent systems and proposes a solid, practical solution. The use of a SQLite database for a distributed lock is a good choice for this architecture.

However, I have a few suggestions to refine the design and ensure its robustness before implementation.

### Summary

The commit adds a well-written design document (`issues/broken-build-orchestration.md`) that specifies a pattern for coordinating multiple agents when a build is broken. The core idea is to use a database-backed lock to ensure only one agent attempts a fix at a time, preventing redundant work and conflicts. The design is clear, and the implementation tasks are well-defined.

### Suggestions for Improvement

The design is strong, but could be made more robust by explicitly addressing potential race conditions and deadlocks.

1.  **Race Condition in Lock Acquisition**
    - **File:** `issues/broken-build-orchestration.md`
    - **Concern:** The agent behavior described in `on_precommit_failure` has a potential race condition. Two agents could simultaneously read `state.status == 'passing'` and both attempt to become the fixer.
    - **Suggestion:** The design should specify that claiming the fixer role must be an **atomic operation**. When an agent tries to claim the lock, it should execute a conditional `UPDATE` statement, such as `UPDATE build_state SET status = 'fixing', fixer_agent_id = :my_id WHERE status = 'passing'`. The agent would only become the fixer if this database command successfully updates one row. If it fails, the agent knows it lost the race and should re-read the state to act accordingly (i.e., wait).

2.  **Stale Lock Handling and Deadlocks**
    - **File:** `issues/broken-build-orchestration.md`
    - **Concern:** The document mentions a `cleanup()` task for stale locks (e.g., after 15 minutes) but doesn't detail how this is integrated into the agent's primary workflow. If the "fixer" agent crashes, the system could deadlock indefinitely in the `fixing` state.
    - **Suggestion:** The agent logic should explicitly handle stale locks. For example, when an agent encounters a `fixing` status, it should check the `broken_since` timestamp. If `now() - broken_since > 15 minutes`, it should be allowed to forcibly claim the fixer role, assuming the previous agent has failed. This prevents the system from getting stuck.

3.  **State Transition on Fix Failure**
    - **File:** `issues/broken-build-orchestration.md`
    - **Concern:** The state machine is slightly ambiguous about what happens if the designated agent attempts a fix and fails.
    - **Suggestion:** It would be helpful to define the state transition for a failed fix attempt. Does the `status` revert to `broken` so another agent can try? Or does the original agent retain the lock and retry? Clarifying this would make the agent's responsibilities clearer.

---

## Implementation Guidance

**Database Schema:**
Add to `/Users/williamcory/smithers/src/db/schema.sql`:
```sql
CREATE TABLE IF NOT EXISTS build_state (
  id INTEGER PRIMARY KEY CHECK (id = 1),  -- Singleton
  status TEXT NOT NULL DEFAULT 'passing',  -- 'passing' | 'broken' | 'fixing'
  fixer_agent_id TEXT,
  broken_since TEXT,
  last_check TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

INSERT OR IGNORE INTO build_state (id, status) VALUES (1, 'passing');
```

**Database Module:**
Create `/Users/williamcory/smithers/src/db/build-state.ts` following patterns in:
- `/Users/williamcory/smithers/src/db/state.ts` - for singleton state management
- `/Users/williamcory/smithers/src/db/agents.ts` - for query patterns

**Critical Implementation Details:**

1. **Atomic Lock Acquisition** - Use SQLite's conditional UPDATE:
```typescript
const result = await db.run(`
  UPDATE build_state
  SET status = 'fixing',
      fixer_agent_id = ?,
      broken_since = datetime('now')
  WHERE id = 1 AND status = 'passing'
`, [myAgentId]);

const claimed = result.changes > 0; // Only true if we won the race
```

2. **Stale Lock Detection** - Check timestamp before waiting:
```typescript
const state = await db.get('SELECT * FROM build_state WHERE id = 1');
const staleThresholdMs = 15 * 60 * 1000; // 15 minutes
const isStaleLock = state.status === 'fixing' &&
  (Date.now() - new Date(state.broken_since).getTime() > staleThresholdMs);
```

3. **Hook Integration** - Pattern already exists in CLAUDE.md precommit protocol:
- Detect precommit failure
- Query build_state
- If can claim lock: spawn fix agent
- If locked by another: wait 5min and retry

**No existing implementation found in codebase** - this is purely a design document requiring full implementation of schema, module, and hook integration.
