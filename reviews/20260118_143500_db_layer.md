# DB Layer Architecture Review

**Date:** 2026-01-18
**Subject:** Smithers Database Schema & Module Correctness Review

---

## Executive Assessment

### Strengths

* **Clear modularization**: Separate modules per table family (`execution`, `phases`, `agents`, `tools`, `state`, `memories`, `vcs`) with single `createSmithersDB()` façade is solid maintenance shape.
* **Good observability backbone**: `executions`, `phases`, `steps`, `agents`, `tool_calls`, `reports`, `reviews`, `commits`, `snapshots`, `render_frames` cover the right surface area for a workflow engine.
* **Pragmatic JSON-in-TEXT approach**: Structured fields as JSON strings reasonable for SQLite.
* **Metrics rollups present** (tokens/tool calls/agents) essential for stop conditions.

### Most Urgent Issues

1. **Context handling not safe for parallelism** (global `current*Id` variables in DB instance will race/collide).
2. **State/iteration key mismatch**: Schema seeds `iteration`, tasks read `ralphCount`.
3. **State table is global** (not per execution), undermines resumability and auditability.
4. **Type correctness**: Time fields declared as `Date` but stored/returned as `TEXT`.
5. **Tool output strategy half-implemented**: Schema supports `output_path`/`git_hash` but only stores inline for small outputs; large outputs unrecoverable.

---

## 1) Context Model: Correctness vs. Parallelism

### Current Design

`createSmithersDB()` maintains global variables:
* `currentExecutionId`
* `currentPhaseId`
* `currentAgentId`
* `currentStepId`

Module methods depend on these (especially `start()` methods).

### Problems

#### A. Not Safe for Parallel Subagents

If two subagents run concurrently sharing one `SmithersDB` instance:
* `phases.start()` overwrites `currentPhaseId`
* `agents.start()` overwrites `currentAgentId`
* `steps.start()` overwrites `currentStepId`

Parallel execution will misattribute rows (wrong phase_id, step_id linkage in downstream logging, etc.).

**This is the biggest architectural risk given Smithers' parallel subagent direction.**

#### B. Resuming an Execution is Awkward

DB does not expose supported way to set `currentExecutionId` to arbitrary existing execution. You can `execution.get(id)` but that does not set current; only `execution.start()` sets current. Resume either operates with `currentExecutionId = null` or requires reaching into internals.

### Recommended Fixes (in robustness order)

**Option 1 (Best): Move "current context" out of DB into orchestrator/provider**

Make DB APIs explicit:
```typescript
agents.start({ executionId, phaseId, ... })
tools.start({ executionId, agentId, ... })
steps.start({ executionId, phaseId, ... })
```

Noisier but makes correctness compositional; eliminates shared mutable global context.

**Option 2: AsyncLocalStorage Context**

Use `AsyncLocalStorage` (`node:async_hooks`) to store `{ executionId, phaseId, agentId, stepId }` per async call chain. Supports concurrency without collisions while maintaining ergonomic implicit context.

**Option 3: Explicit Context Setter + Stack (Minimum Change)**

Expose:
```typescript
db.setExecutionContext(executionId)
db.withPhase(phaseId, () => { ... })  // push/pop
```

Still breaks in parallel unless `with*` uses async context, but at least fixes resumability.

---

## 2) Iteration/State Key Mismatch (Likely Real Bug)

### Current State

* `schema.sql` seeds: `phase`, `iteration`, `data`
* `TasksModule.getCurrentIteration()` reads: `SELECT value FROM state WHERE key = 'ralphCount'`
* `RenderFramesModule` stores: `ralph_count`

### Why It Matters

**Tasks will default to iteration 0 forever** unless something elsewhere writes `state.key='ralphCount'`. Seeded "iteration" key unused by `TasksModule`.

### Recommendations

Choose canonical key: either `iteration` or `ralphCount`. Update:
* schema seed (`INSERT OR IGNORE`) for canonical key
* `state.reset()` to insert canonical key
* `TasksModule.getCurrentIteration()` to read canonical key
* orchestrator logic that increments it

Also: state values are JSON strings. Use `JSON.parse(value)` rather than `parseInt(value, 10)` to avoid weirdness if stored as `"0"` vs `0`.

---

## 3) State Table Not Scoped by Execution (Design-Level Concern)

### Current Schema

```sql
CREATE TABLE state (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TEXT ...
);
```

No `execution_id`. But `transitions` has `execution_id` and inserts when `currentExecutionId` exists.

### Consequences

* Running multiple executions in single DB file: `state` table becomes **global singleton**.
* Resuming previous execution sees *current* state (from most recent run), not state at that execution.
* Transition history shows state changes per execution, but "current" state not reconstructible without replay.

### Strongly Recommended Direction

Make `state` scoped per execution:

```sql
CREATE TABLE state (
  execution_id TEXT NOT NULL REFERENCES executions(id) ON DELETE CASCADE,
  key TEXT NOT NULL,
  value TEXT NOT NULL,
  updated_at TEXT ...,
  PRIMARY KEY (execution_id, key)
);
```

Then:
* `StateModule` must require execution context (or accept executionId explicitly)
* `state.reset()` resets for active execution only
* Aligns with rest of per-execution tables
* Makes resume semantics correct by construction

If you intentionally want *global* state across runs:
* Remove `execution_id` from transitions (or treat transitions as "global" too)
* Accept that "resume" requires replay from transitions to reconstruct run-specific state

Current hybrid will surprise you later.

---

## 4) Type Correctness: Date Fields and Boolean Casts

### Date Fields

Many tables in `types.ts` define `created_at`, `started_at` as `Date`, but DB stores `TEXT` and modules generally return row as-is without conversion.

Example: `MemoriesModule.get()` returns `Memory | null` but does not parse `created_at`/`updated_at` into `Date`. Will cause runtime errors when consumers do `memory.created_at.getTime()`.

**Recommendation**: Pick consistent representation:
* Change all time fields in types to `string` (ISO), OR
* Map them to `Date` everywhere in mappers

Given you use `now(): string` and store TEXT, adjust TS types to `string` for timestamps. Simpler and consistent.

### Boolean Casts (Important Subtlety)

In `vcs.ts`:
```typescript
approved: Boolean(row.approved)
```

If SQLite driver returns `"0"` (string), `Boolean("0") === true`. Same for `"1"`.

If using `better-sqlite3`, typically get numbers and OK. But brittle assumption.

**Recommendation**: Use `row.approved === 1` or `Boolean(Number(row.approved))` for all boolean fields (`blocking`, `posted_to_*`, `has_conflicts`).

---

## 5) Tool Output Persistence is Incomplete

### Schema Supports

* `output_path`
* `output_git_hash`
* `output_inline`
* `output_summary`

### Code Behavior

* For `<1KB`, stores `output_inline`
* For large outputs, stores only summary (drops payload)

**Large tool outputs are not recoverable** and `tool_calls.output_path`/`output_git_hash` never set.

### Recommended Fix Pattern

When output is large:

1. Write output to file (e.g., `.smithers/outputs/<tool_call_id>.txt`)
2. Store `output_path` and `output_size_bytes`
3. Optionally:
   * Add `artifact` row referencing file
   * Store `output_git_hash` if you snapshot/commit outputs

Update `ToolsModule.getOutput(id)` to:
* Return `output_inline` if present
* Else read from `output_path` if present
* Else return null

Current behavior silently returns null for large outputs—feels like data loss.

---

## 6) Metric Rollups are Partially Maintained (Invariants Drift Risk)

You update:
* `executions.total_agents += 1` when agent starts
* `executions.total_tool_calls += 1` when tool starts
* `agents.tool_calls_count += 1` when tool starts
* `executions.total_tokens_used += (input+output)` when agent completes (if tokens passed)

You do **not** update:
* `phases.agents_count` (schema includes it)
* `executions.total_iterations` (schema includes it)

### Recommendation

Decide whether rollups are:
* Maintained by code (ensure all updated everywhere, including fail/cancel paths), OR
* Derived by queries (remove columns or treat as caches with reconciliation)

Robust compromise for SQLite: **Triggers**
* `AFTER INSERT ON agents` → increment `executions.total_agents`, `phases.agents_count`
* `AFTER INSERT ON tool_calls` → increment `executions.total_tool_calls`, `agents.tool_calls_count`
* `AFTER iteration increment event` → `executions.total_iterations`

Triggers reduce "forgot to increment" bugs.

---

## 7) Failure Paths Don't Compute Duration Consistently

Examples:
* `AgentsModule.fail()` sets status/error/completed_at but **not** duration_ms
* `PhasesModule.fail()` sets status/completed_at but **not** duration_ms
* `StepsModule.fail()` sets status/completed_at but **not** duration_ms
* `TasksModule.fail()` *does* compute duration_ms (good pattern)

### Recommendation

Mirror duration_ms computation for fail paths too. Consider adding `error` columns to `phases`, `steps`, `tasks` (tasks currently has no error field). Failed tasks without reason hard to debug.

---

## 8) Memories: Scope Lookup Semantics are Nondeterministic

`MemoriesModule.get(category, key, scope?)` uses:
```sql
WHERE category = ? AND key = ? AND (scope = ? OR ? IS NULL)
```

If `scope` is `null`, this means "any scope", but:
* Can have multiple rows with same (category, key) across scopes
* `queryOne` returns arbitrary one without ordering

### Recommendation Options

**Option A**: Require `scope` in `get()` (strict API).

**Option B**: Define precedence when scope omitted (`session > project > global`):
```sql
ORDER BY CASE scope WHEN 'session' THEN 3 WHEN 'project' THEN 2 ELSE 1 END DESC
LIMIT 1
```

Also: `search` uses `LIKE '%query%'` which won't scale. If many memories expected, add FTS5 virtual table for `memories.content`.

---

## 9) Indexing: Add Composites for Real Query Patterns

Currently single-column indexes, but code often filters by multiple columns then orders.

Examples to improve:

* `tasks.getRunningCount()` filters `(execution_id, iteration, status)`
  * Add: `CREATE INDEX ON tasks(execution_id, iteration, status)`

* `human.listPending()` filters `(execution_id, status)`
  * Add: `(execution_id, status)`

* Common list patterns:
  * `agents` by `(execution_id, created_at)`
  * `phases` by `(execution_id, created_at)`
  * `steps` by `(phase_id, created_at)` and/or `(execution_id, created_at)`
  * `tool_calls` by `(agent_id, created_at)`
  * `artifacts` by `(execution_id, created_at)`

Matters once runs get large and you build UIs against this DB.

---

## 10) Migration Strategy is Too Ad Hoc

Single migration adding `agents.log_path`. As you add more columns/tables, need:
* `schema_version` table
* Ordered migrations

### Minimal Approach

```sql
CREATE TABLE IF NOT EXISTS schema_migrations (
  id TEXT PRIMARY KEY,
  applied_at TEXT NOT NULL
)
```

Each migration checks/records its id. Avoids "migrations must be PRAGMA checks" forever.

---

## 11) SQLite Foreign Keys Enforcement

You declare foreign keys with `REFERENCES ... ON DELETE ...` throughout schema, but SQLite does not enforce FKs unless:

```sql
PRAGMA foreign_keys = ON;
```

**Recommendation**: Ensure `ReactiveDatabase` enables this, or do it explicitly in `createSmithersDB()` immediately after opening connection. Without it, cascading deletes and referential constraints won't actually work.

---

## 12) Smaller API/Ergonomics Observations

* `ExecutionModule.start()` doesn't reset state/tasks/frames. If "one DB = many executions", orchestrator-level "new run" initializer should:
  * Set current execution id
  * Reset per-execution state
  * Seed run-level metadata

* `state.history()` returns transitions but doesn't parse `old_value`/`new_value`; consumers parse repeatedly. Consider mapper helpers for transitions.

* `VcsModule.logCommit()` uses `INSERT OR REPLACE` with new UUID each time. Can destroy audit trails. Prefer:
  * `INSERT ... ON CONFLICT(vcs_type, commit_hash) DO UPDATE SET ...`
  * Keep stable `id`

---

## Recommended Implementation Priority

1. Fix iteration key (`iteration` vs `ralphCount`) and parse values as JSON
2. Decide and implement execution-scoped state (essential for reliable resume)
3. Replace global `current*Id` variables with explicit params or AsyncLocalStorage
4. Make timestamps typed as `string` (or map to Date everywhere)
5. Implement large tool output persistence via `output_path` and update `getOutput()`
6. Add missing composite indexes for frequent list/count queries
7. Add real migration table

---

**Note**: Can propose revised DB API surface preserving ergonomics while becoming parallel-safe, typically via `db.withContext({executionId, phaseId, ...}, fn)` wrapper backed by AsyncLocalStorage. Gives correctness under concurrency without rewriting every module signature.

---

## Code References

### Primary Files (src/db/)

* `src/db/index.ts` - `createSmithersDB()` entry point with context variables
* `src/db/types.ts` - Type definitions for all tables and modules
* `src/db/schema.sql` - Database schema and seeding logic
* `src/db/execution.ts` - Execution module with `start()` method
* `src/db/phases.ts` - Phases module
* `src/db/agents.ts` - Agents module
* `src/db/steps.ts` - Steps module
* `src/db/tools.ts` - Tools module with output handling
* `src/db/state.ts` - State module (global, non-scoped)
* `src/db/memories.ts` - Memories module with scope lookup
* `src/db/vcs.ts` - VCS module with boolean casting
* `src/db/tasks.ts` - Tasks module with `getCurrentIteration()` (reads `ralphCount` key)
* `src/db/render-frames.ts` - Renders with `ralph_count` field

### ReactiveDatabase Integration

* `src/reactive-sqlite/database.ts` - Core `ReactiveDatabase` wrapper
* `src/reactive-sqlite/parser.ts` - SQL table extraction logic
* `src/reactive-sqlite/hooks/useQuery.ts` - Primary cache + invalidation bug location
* `src/reactive-sqlite/hooks/useQueryOne.ts` - Context db signature missing
* `src/reactive-sqlite/hooks/useQueryValue.ts` - Context db signature missing
* `src/reactive-sqlite/hooks/useMutation.ts` - Reference for overload pattern

### Related Documentation

* `docs/tui-architecture.md` - System architecture overview
* `docs/refactor-state.md` - State management refactoring notes
