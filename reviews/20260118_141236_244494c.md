# Code Review for Commit 244494c

**Date:** 2026-01-18 14:12:36
**Commit Message:** docs(State): update for useState elimination refactor

Major architectural changes documented:
- ZERO useState in orchestration (eliminated commit 5e3536e)
- All state now: SQLite + useQuery, useRef + forceUpdate, or derived
- Exception: TUI components (src/tui/) CAN use useState
- Updated all component examples (Claude, Smithers, JJ/*, Git/*, etc)
- Added migration patterns (old useState → new patterns)
- Documented forceUpdate pattern for ref-based state

Pattern summary:
1. Durable agent state → db.agents + useQuery
2. Durable component state → db.state key-value
3. Non-durable with updates → useRef + forceUpdate
4. Pure ephemeral → useRef only

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>

---

This is a well-structured and comprehensive update to the state management documentation, reflecting a significant and disciplined architectural refactor. The move to eliminate `useState` in orchestration components is a strong choice for ensuring durability and predictability, and the documentation does a great job of explaining the "why."

However, there is a critical flaw in the primary documented pattern for durable, database-backed state that will prevent it from working as described.

### Critical Issue: `useQuery` with `useRef` dependency is a broken pattern

The recommended pattern for components like `Claude.tsx` and `Smithers.tsx`, and documented in the migration guide, will not work correctly due to how React hooks and refs function.

- **File:** `State.md`
- **Location:**
  - `#### State (NO useState - all DB + refs)` section for `Claude.tsx` (approx. line 215)
  - `✅ NEW (Option 1: DB for durable state)` migration pattern (approx. line 570)

**The Problem:**

The pattern is as follows:
1.  An `agentIdRef` is initialized to `null`.
2.  `useQuery` is called with `agentIdRef.current` in its dependency array. On the first render, this value is `null` (or `''` after the nullish coalescing operator).
3.  In `useMount`, a new agent ID is created and assigned to `agentIdRef.current`.

The critical flaw is that **mutating a `ref` does not trigger a component re-render.** The `useQuery` hook executes on the initial render with a `null` agent ID and will **never be re-executed** with the correct ID once it's assigned in `useMount`. The component will remain stuck showing the initial (likely empty) state, as the query is never re-run with the valid agent ID.

**Incorrect Code Snippet (from `State.md`):**
```typescript
// ✅ NEW (Option 1: DB for durable state)
const agentIdRef = useRef<string | null>(null)

// This query runs once with agentIdRef.current being null.
const { data: agentRows } = useQuery<AgentRow>(
  reactiveDb,
  "SELECT status, result FROM agents WHERE id = ?",
  [agentIdRef.current ?? '']
)
// ...
useMount(async () => {
  const id = db.agents.create({ status: 'running', ... })
  // This mutation is "invisible" to React's rendering lifecycle.
  // It does NOT trigger a re-render, so the useQuery above never runs again.
  agentIdRef.current = id 
  const output = await execute()
  db.agents.complete(id, output)
})
```

### Suggested Improvement

To fix this pattern, a re-render must be forced after the `agentId` is created and assigned to the ref. The document already shows the correct way to do this in "Option 2" for ephemeral state. The same `useReducer`-based `forceUpdate` should be applied to the durable state pattern.

**Corrected Code Snippet:**
```typescript
// ✅ NEW (Option 1: DB for durable state) - CORRECTED
const agentIdRef = useRef<string | null>(null)
// forceUpdate is needed to make useQuery re-evaluate
const [, forceUpdate] = useReducer((x: number) => x + 1, 0)

const { data: agentRows } = useQuery<AgentRow>(
  reactiveDb,
  "SELECT status, result FROM agents WHERE id = ?",
  [agentIdRef.current ?? '']
)
const agentRow = agentRows[0] ?? null
// ...
useMount(async () => {
  const id = db.agents.create({ status: 'running', ... })
  agentIdRef.current = id
  forceUpdate() // <-- CRITICAL: Trigger re-render to re-run useQuery with the new ID

  const output = await execute()
  // The useQuery is reactive, so this DB update will trigger a re-render automatically
  db.agents.complete(id, output)
})
```
This correction should be applied to the `Claude.tsx`, `Smithers.tsx` examples and, most importantly, the "Pattern Migration" section to ensure developers adopt a working pattern.
