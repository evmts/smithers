# Code Review for Commit 0023433

**Date:** 2026-01-18 02:28:56
**Commit Message:** feat(Step): add step registry for sequential execution within phases

---

In `src/components/Step.tsx`:

### Major Issues

1.  **Race Condition in Step Registration (Bug)**:
    The `registerStep` function relies on the `steps` state variable (`steps.length`) to assign indices. When multiple `Step` components are children of a `Phase`, they will mount and render effectively simultaneously.
    -   Inside `Step`, `useStepIndex` calls `registerStep` via the `useState` initializer.
    -   Since state updates (`setSteps`) are not applied immediately during the render pass, `steps` will remain empty (or stale) for all sibling components during their initial render.
    -   **Result**: All sibling steps will likely receive `index: 0`.

2.  **React State Update Warning**:
    Calling `registerStep` (which calls `setSteps` on the parent `StepRegistryProvider`) inside the `useState` initializer of a child component (`Step`) triggers the React warning: *"Cannot update a component (`StepRegistryProvider`) while rendering a different component (`Step`)."*
    -   Side effects (like state updates) should usually be performed in `useEffect` or event handlers, not during render.

### Suggested Improvements

Refactor `StepRegistryProvider` to use a `useRef` for the step registry. This allows for synchronous, mutable updates during the render pass (which is safe for initialization logic like this if handled carefully) and avoids the state update warning.

**Suggested `StepRegistryProvider` fix:**

```typescript
// Inside StepRegistryProvider
const stepsRef = useRef<string[]>([])

const registerStep = useCallback((name: string): number => {
  const existingIndex = stepsRef.current.indexOf(name)
  if (existingIndex >= 0) {
    return existingIndex
  }
  const index = stepsRef.current.length
  stepsRef.current.push(name)
  return index
}, []) // No dependencies needed
```

**Note**: If you need the `steps` list to trigger re-renders elsewhere (e.g., for a UI list), you can sync the ref to state inside a `useEffect`, but for the logic of `Step` execution indices, the Ref is sufficient and stable.

### Minor Issues

*   **`useStepIndex` Dependency**:
    ```typescript
    const [index] = useState(() => {
       // ...
       return registry.registerStep(name ?? 'unnamed')
    })
    ```
    Since `useState` initializers only run once, if `name` changes dynamically (unlikely for a Step, but possible), the index won't update. This is likely acceptable for this use case but worth noting.

*   **Cleanup**:
    There is no unregistration logic. If a `Step` unmounts conditionally within a Phase, it remains in the registry. This might be intended for "completed" steps, but could cause issues if steps are toggled.
