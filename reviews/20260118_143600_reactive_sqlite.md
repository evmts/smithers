# Reactive SQLite Module Review

**Date:** 2026-01-18
**Subject:** `reactive-sqlite` (12 files) Correctness & API Review

---

## Executive Summary

Modular design with `ReactiveDatabase` wrapper is clean, and using `useSyncExternalStore` is correct for React 18 concurrency. Row-filter invalidation support is thoughtful. However, **critical P0 correctness issue**: `useQuery` cache prevents React from observing DB invalidations, so components don't rerender on DB writes. Also transaction semantics and parser limitations need attention.

---

## 1) What This Module Does Well

### ReactiveDatabase Wrapper (`src/reactive-sqlite/database.ts`)

* Clean minimal wrapper around `bun:sqlite` with:
  * `exec`, `run`, query helpers (`query`, `queryOne`, `queryValue`)
  * In-memory subscription registry (`Map<string, QuerySubscription>`)
  * Basic dependency tracking via "table extraction" from SQL
* WAL mode enabled by default—good for read-heavy/observer-heavy workflows

### Row-Filter Invalidation Support

* `extractRowFilter()` + `invalidateWithRowFilter()` + `subscribeWithRowFilter()` provide path to predicate-level invalidation
* Design intentionally conservative (bails out on OR/IN/EXISTS/LIKE/subqueries)—appropriate for lightweight parser

### React Hook Architecture

* `useSyncExternalStore` is right primitive for React 18 concurrency correctness
* `DatabaseProvider` + `useDatabaseOptional()` supports both explicit-db and context-based usage

---

## 2) P0 Correctness Issue: `useQuery` Does Not Actually Refresh on Invalidations

### Where It Breaks

In `src/reactive-sqlite/hooks/useQuery.ts`, cache logic prevents `useSyncExternalStore` from observing changes:

* `subscribe()` registers `db.subscribe(tables, () => { incrementVersion(); onStoreChange(); })`
* However, `getSnapshot()` only re-runs SQL if `cacheRef.current.key !== queryKey`
* On invalidation, `queryKey` typically does **not** change (SQL/params unchanged), and you never clear/alter cache key
* `incrementVersion()` increments ref, but that ref not used to affect snapshot's identity

### Result

When DB invalidates:
* React calls `onStoreChange` handler
* React then calls `getSnapshot` to compare new snapshot vs old
* `getSnapshot` returns same cached object reference with same key
* `Object.is(prevSnapshot, nextSnapshot)` is true, so React treats as unchanged

**Components won't rerender and query won't rerun on invalidation** (except when params/sql change, or you call `refetch`, or your `deps` effect fires).

### Minimal Fix (Recommended)

Invalidate the cache inside subscription callback so next `getSnapshot()` recomputes query and returns new snapshot object.

```typescript
const subscribe = useCallback((onStoreChange: () => void) => {
  if (skip) return () => {}

  const tables = extractReadTables(sql)
  return db.subscribe(tables, () => {
    invalidateCache()        // <-- critical
    onStoreChange()
  })
}, [db, sql, skip, invalidateCache])
```

Then remove `useVersionTracking()` entirely (or repurpose it properly).

### Alternative Fix

In db subscription callback, directly compute and write new cache snapshot object (ensure referentially different), but "clear cache then let getSnapshot recompute" is simpler and matches current structure.

---

## 3) P0/P1 Semantics Issue: Invalidations Inside Transactions Can Be Wrong

### Current Behavior

`ReactiveDatabase.transaction(fn)` delegates to `this.db.transaction(fn)()`.

But invalidation happens inside `run()` immediately after `stmt.run(...)`, **before transaction commit guaranteed** and potentially before rollback occurs.

### Implications

* If transaction throws and rolls back, subscribers notified about changes that never committed
* Even for successful transactions, multiple `run()` calls cause multiple invalidations and redundant rerenders

### Recommended Approach

Introduce transaction-aware invalidation queue:

* Track `inTransaction` depth and accumulate:
  * Union of tables written
  * Optional row filters (possibly multiple)
* On successful transaction completion, flush consolidated invalidation
* On rollback/throw, drop queue

Important if Smithers uses transactions for multi-step state updates (common in orchestration/persistence code).

---

## 4) P1 Correctness Issue: `REPLACE INTO` Won't Invalidate

* `isWriteOperation()` returns true for `replace...`
* `extractWriteTables()` does **not** include `REPLACE INTO` regex
* Therefore `exec()` or `run()` with `REPLACE` statement will **not** invalidate (tables.length === 0)

### Fix

Add support in `extractWriteTables()`:
* `REPLACE INTO table_name ...`
* Potentially `INSERT OR REPLACE INTO ...` already handled by `insertRegex`, but direct `REPLACE` not

---

## 5) Parser Limitations Causing Missed Invalidations (P1 Depending on Usage)

Acceptable if you strictly constrain SQL style, otherwise reliability problems.

### Table Extraction Gaps

Both `extractReadTables` and `extractWriteTables` only match unquoted identifiers `[a-z_][a-z0-9_]*` and don't handle:

* Quoted identifiers: `"users"`, `` `users` ``, `[users]`
* Schema-qualified: `main.users`, `temp.users`
* Comma joins: `FROM users, posts` (only captures `users`)
* Some CTE reference cases where "real" table only in subqueries

If Smithers uses consistent unquoted snake_case tables and avoids comma joins, probably fine. Otherwise, subscriptions silently subscribe to empty table set, and reactivity fails.

### Row Filter Extraction Limitations

`extractRowFilter()`:
* Picks only first `AND` condition
* Rejects OR / IN / EXISTS / LIKE
* Doesn't parse qualified columns `users.id`
* May misbehave with complex parameter placements

OK as opportunistic optimization with safe fallback (you do by falling back to table-level invalidation when rowFilter is null).

---

## 6) React Hook Ergonomics and Consistency Issues

### `useQuery` Overload Footgun

`useQuery(sql, paramsArray, db)` natural call shape people will try.

Right now, third argument interpreted as `options` (no "is this a db?" discriminator like `useMutation` has), and you'll end up with:
* options being db object (nonsense)
* explicitDb undefined
* falling back to contextDb (or throwing)

### Recommendation

Mirror `useMutation` heuristic (`'query' in obj`) or use `instanceof ReactiveDatabase` with single instance semantics, or prefer object-parameter signature to eliminate ambiguity.

### `useQueryOne` / `useQueryValue` Lack Context DB Signature

Currently require `db: ReactiveDatabase` explicitly, unlike `useQuery`/`useMutation` which support `DatabaseProvider`.

**Recommendation**: Implement same overload behavior for `useQueryOne`/`useQueryValue`:
```typescript
useQueryOne(sql, params?, options?, explicitDb?)
useQueryValue(sql, params?, options?, explicitDb?)
```

Or add thin wrappers.

### `useMutation` Loading State Effectively Unobservable

Because `db.run` is synchronous and React batches state updates:
* `setIsLoading(true)` and `setIsLoading(false)` happen in same tick
* UI rarely/never sees loading state

**Options**:
* Drop `isLoading` (or document it's useful if calling `mutateAsync` from async boundary that actually yields)
* Return `run()` result and treat as synchronous

---

## 7) Reentrancy and Robustness in Invalidation Dispatch (P2)

### Callbacks Can Mutate Subscriptions During Iteration

`invalidate()` and `invalidateWithRowFilter()` iterate `this.subscriptions.values()` directly and invoke callbacks inline.

If callbacks add/remove subscriptions, Map iteration semantics can surprise. Safer pattern:
* Gather callbacks into array/set first
* Invoke after iteration
* Wrap each callback in try/catch so one subscriber can't break others

### Cross-Connection / Cross-Process Changes Not Observable

In-memory subscriptions inherent limitation:
* If anything writes to DB via `db.raw`, separately opened `Database`, or another process, reactivity won't fire
* Fine if Smithers constrains all writes through `ReactiveDatabase`, but should be documented contract

---

## 8) Performance Considerations (P2, Could Matter in Smithers)

### Prepared Statements Not Cached

`run()` and `query()` call `this.db.prepare(sql)` every time.

For hot paths, caching by SQL string can reduce overhead. If adding caching, must decide statement lifecycle/finalization and handle `close()`.

### Subscription Invalidation is O(N)

Invalidate scans every subscription and checks table intersection. If many subscriptions expected (e.g., live UI panels over Smithers DB):
* Consider indexing subscriptions by table (`Map<table, Set<subscriptionId>>`)

---

## 9) Suggested Priority Changes

### P0 (Must Fix)

1. **Fix `useQuery` invalidation** so DB writes cause snapshot changes and rerenders
2. **Consider transaction-aware invalidation batching**, or at least document semantics clearly (invalidations may fire mid-transaction)

### P1 (High-Value)

3. Add `REPLACE INTO` support in `extractWriteTables`
4. Make `useQuery(sql, params, db)` unambiguous and safe
5. Add context-based overload support for `useQueryOne` and `useQueryValue`

### P2 (Quality)

6. Harden invalidation dispatch against callback reentrancy and exceptions
7. Decide on parser contract (tight SQL style vs broader parsing)
8. Optional: statement caching and table-indexed subscriptions

---

## 10) Correctness Test Cases to Add

### Hook Correctness

```typescript
// Render component using useQuery inside DatabaseProvider
// Insert into table via db.run()
// Assert component rerenders and shows new row
```

This will catch current P0 bug immediately.

### Parser Tests

**extractReadTables**:
* `SELECT * FROM users`
* `SELECT * FROM users u JOIN posts p ON ...`
* `SELECT * FROM users, posts` (should include both; currently won't)
* Quoted identifiers if you decide to support

**extractWriteTables**:
* `REPLACE INTO users (...) VALUES (...)` (currently fails)
* `INSERT OR REPLACE INTO users ...` (should pass)

**extractRowFilter**:
* `UPDATE users SET name=? WHERE id=?`
* `DELETE FROM users WHERE id=123`
* `SELECT * FROM users WHERE id=?`

### Transaction Semantics

Run transaction that writes then throws; ensure no invalidation emitted if you adopt queueing approach.

---

## Architecture Notes

### Strengths to Preserve

* Separation of concerns (database operations, reactivity, React hooks)
* Conservative approach to optimizations (row filtering is optional fallback)
* Use of `useSyncExternalStore` for correctness

### Dependencies to Consider

* Currently uses `bun:sqlite` (good—built-in)
* No external state management dependencies needed

---

## Recommended Implementation Sequence

1. Fix P0 `useQuery` invalidation bug (high impact, straightforward)
2. Decide transaction invalidation strategy (important for correctness)
3. Add `REPLACE INTO` support (quick win)
4. Improve hook ergonomics (API consistency)
5. Add parser tests (prevent regressions)
6. Optional optimizations (caching, indexing)

---

**Note**: Can provide concrete patch layout (exact code changes per file) for P0 `useQuery` fix and transaction invalidation queue design that stays lightweight without requiring real SQL parser.

---

## Code References

### Core Module Files

* `src/reactive-sqlite/database.ts` - `ReactiveDatabase` wrapper class with subscription registry and invalidation logic
* `src/reactive-sqlite/parser.ts` - SQL parsing: `extractReadTables()`, `extractWriteTables()`, `extractRowFilter()`
* `src/reactive-sqlite/types.ts` - Type definitions for subscriptions and query options

### Hook Implementations

* `src/reactive-sqlite/hooks/useQuery.ts` - Main hook with cache bug (P0 issue location)
* `src/reactive-sqlite/hooks/useQueryOne.ts` - Single row hook (missing context db overload)
* `src/reactive-sqlite/hooks/useQueryValue.ts` - Single value hook (missing context db overload)
* `src/reactive-sqlite/hooks/useMutation.ts` - Mutation hook (reference for ergonomic overloads)
* `src/reactive-sqlite/hooks/shared.ts` - Shared utilities and `DatabaseProvider`

### Test Files

* `src/reactive-sqlite/database.test.ts` - Database tests (should add hook reactivity test)
* `src/reactive-sqlite/parser.test.ts` - Parser tests (needs expansion for edge cases)
* `src/reactive-sqlite/row-tracking.test.ts` - Row-filter tests

### Integration Points

* `src/db/index.ts` - Uses `ReactiveDatabase` for Smithers DB
* `src/db/query.ts` - Query helpers that depend on ReactiveDatabase

---

## Critical Files to Review

### Priority 1: Fix the P0 Bug

**File**: `src/reactive-sqlite/hooks/useQuery.ts`

Look for:
* `cacheRef.current` - Cache state management
* `getSnapshot()` - Must invalidate cache on subscription callback
* `useVersionTracking()` - Either remove or repurpose
* `subscribe()` callback - Add `invalidateCache()` call

### Priority 2: Transaction Safety

**Files**:
* `src/reactive-sqlite/database.ts` - `run()`, `transaction()` methods
* Need to track `inTransaction` state and queue invalidations

### Priority 3: Parser Coverage

**File**: `src/reactive-sqlite/parser.ts`

Current regexes to enhance:
* `insertRegex`, `updateRegex`, `deleteRegex` - Add `REPLACE INTO` support
* `extractReadTables()` - Handle comma joins, qualified identifiers
* `extractWriteTables()` - Add `REPLACE INTO` pattern

### Priority 4: Hook Ergonomics

**Files**:
* `src/reactive-sqlite/hooks/useQuery.ts` - Fix overload to disambiguate 3rd param
* `src/reactive-sqlite/hooks/useQueryOne.ts` - Add context db support
* `src/reactive-sqlite/hooks/useQueryValue.ts` - Add context db support
* Reference `src/reactive-sqlite/hooks/useMutation.ts` for pattern

---

## Related Context

* Smithers orchestrator uses `ReactiveDatabase` for all persistence
* Performance-sensitive: runs can accumulate thousands of rows
* UI layer depends on subscription reactivity for live updates
* Parallel subagents share same `ReactiveDatabase` instance (concurrency concern)
