# Code Review for Commit 2f627c6

**Date:** 2026-01-18 02:28:39
**Commit Message:** refactor(Phase): use PhaseRegistry for automatic state management

Replace manual phase status tracking with PhaseRegistry hooks for
centralized phase coordination. Phases now:
- Always render in output (visible structure)
- Only render children when active (executes work)
- Automatically advance to next phase on completion

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>

---

Review of `src/components/Phase.tsx` and `EXAMPLES.md`.

### Summary
The refactor introduces a significant logical conflict between the stated goal ("Phases always render in output") and the implementation (relying on `useMount`/`useUnmount` for state transitions).

If phases are rendered declaratively as a list (as shown in the updated JSDoc), they will all mount simultaneously. This breaks the logic because:
1.  **Activation Failure:** `useMount` will not run when a pre-mounted pending phase becomes `active`.
2.  **Completion Failure:** `useUnmount` will not run if the phase remains in the DOM to show its status.

### Issues

#### 1. Lifecycle Logic Breaks Sequential Execution
**File:** `src/components/Phase.tsx` (lines 80-97)

The logic to start a phase is inside `useMount`:
```typescript
useMount(() => {
  // ...
  if (isActive && !hasStartedRef.current) {
    // Start phase
  }
})
```
If the user renders multiple phases upfront (e.g., `<Phase A/><Phase B/>`):
1.  Both `A` and `B` mount immediately.
2.  `A` is active -> `useMount` starts it.
3.  `B` is pending -> `useMount` does nothing.
4.  When `A` completes and `B` becomes `active`, **`useMount` for `B` has already run**. It will never trigger the start logic (DB logging, `onStart`).

**Suggestion:**
Replace `useMount` with `useEffect` dependent on `isActive`.

```typescript
useEffect(() => {
  if (isActive && !hasStartedRef.current) {
    hasStartedRef.current = true;
    // ... start logic
  }
}, [isActive]);
```

#### 2. Completion Logic Incompatible with "Always Render"
**File:** `src/components/Phase.tsx` (lines 100-111)

The logic to complete a phase and advance is inside `useUnmount`:
```typescript
useUnmount(() => {
  // ...
  db.phases.complete(id)
  registry.advancePhase()
})
```
If "Phases always render in output", the `Phase` component never unmounts. Therefore:
1.  `db.phases.complete` is never called.
2.  `registry.advancePhase()` is never called.
3.  The workflow stalls indefinitely at the first phase.

**Suggestion:**
There is a missing mechanism for detecting *when* the work is done if the `Phase` container itself doesn't unmount.
- If the intention is that `children` unmount when finished, `Phase` needs a way to know this.
- If the intention is to keep the *Old Pattern* (conditional rendering), the commit message "Always render in output" is misleading.

If the goal is truly automatic, `Phase` might need a callback context that children call, or it needs to listen to `registry` state changes if the `registry` is what drives completion.

#### 3. Outdated Documentation
**File:** `@plugins/smithers/skills/smithers/EXAMPLES.md`

The JSDoc in `Phase.tsx` points to `EXAMPLES.md`, but the content of that file still demonstrates the **old manual state management pattern** (using `useState` and conditional rendering like `{phase === 'research' && ...}`).

**Suggestion:**
Update `EXAMPLES.md` to use the new `PhaseRegistry` pattern (declarative list of phases) to avoid confusing users.

### Refactored Code Example
Here is a potential fix for the lifecycle issues, assuming there is an external trigger or the children's unmounting (when `isActive` flips) isn't the *driver* of completion but rather the *result*.

*Note: Since the mechanism for "work is done" is ambiguous in this diff (usually `Claude` calls `onFinished`), you might need to expose a `complete()` function to children or wrap the children to intercept their completion.*

```typescript
// Fix for Activation
useEffect(() => {
  if (isSkipped) return; // Handled in mount or separate effect

  if (isActive && !hasStartedRef.current) {
    hasStartedRef.current = true;
    const id = db.phases.start(props.name, ralphCount);
    setPhaseId(id);
    phaseIdRef.current = id;
    props.onStart?.();
  }
}, [isActive, isSkipped, props.name, ralphCount, db]);
```
