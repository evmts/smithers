---
title: Multi-Agent Team
description: Architect and developer agents working together on feature implementation
---

# Multi-Agent Team

This example demonstrates a team of specialized agents working together: an architect designs the plan, then multiple developers implement in parallel.

## Complete Example

```tsx
import { create } from 'zustand'
import {
  Claude,
  Subagent,
  Phase,
  Step,
  Persona,
  Constraints,
  OutputFormat,
} from 'smithers'

// Type definitions
interface Subtask {
  id: string
  description: string
  dependencies: string[]
  estimatedComplexity: 'low' | 'medium' | 'high'
}

interface ImplementationPlan {
  overview: string
  subtasks: Subtask[]
  integrationNotes: string
}

interface Implementation {
  taskId: string
  files: Array<{ path: string; content: string }>
  tests: Array<{ path: string; content: string }>
  notes: string
}

// State management
const useTeamStore = create<{
  phase: 'planning' | 'implementing' | 'integrating' | 'complete'
  plan: ImplementationPlan | null
  implementations: Record<string, Implementation>
  integrationResult: any

  setPlan: (plan: ImplementationPlan) => void
  addImplementation: (taskId: string, impl: Implementation) => void
  setIntegrationResult: (result: any) => void
}>((set, get) => ({
  phase: 'planning',
  plan: null,
  implementations: {},
  integrationResult: null,

  setPlan: (plan) => set({ plan, phase: 'implementing' }),

  addImplementation: (taskId, impl) => {
    const implementations = { ...get().implementations, [taskId]: impl }
    const plan = get().plan!
    const allDone = Object.keys(implementations).length === plan.subtasks.length
    set({
      implementations,
      phase: allDone ? 'integrating' : 'implementing',
    })
  },

  setIntegrationResult: (result) =>
    set({ integrationResult: result, phase: 'complete' }),
}))

// Specialized personas
function Architect() {
  return (
    <Persona role="Software Architect">
      You are a senior software architect with 15+ years of experience.
      You excel at breaking down complex features into well-defined,
      independent tasks that can be worked on in parallel.
      You consider dependencies, interfaces, and integration points.
    </Persona>
  )
}

function Developer({ specialty }: { specialty?: string }) {
  return (
    <Persona role="Senior Developer">
      You are an experienced developer who writes clean, tested code.
      {specialty && ` You specialize in ${specialty}.`}
      You follow project conventions and best practices.
      You write comprehensive tests for your implementations.
    </Persona>
  )
}

function TechLead() {
  return (
    <Persona role="Tech Lead">
      You are a tech lead responsible for code quality and integration.
      You ensure implementations work together seamlessly.
      You catch integration issues and inconsistencies.
      You maintain high standards for the codebase.
    </Persona>
  )
}

// Main team agent
export function FeatureTeam({
  feature,
  codebaseContext,
}: {
  feature: string
  codebaseContext?: string
}) {
  const {
    phase,
    plan,
    implementations,
    setPlan,
    addImplementation,
    setIntegrationResult,
  } = useTeamStore()

  // Phase 1: Architect creates the plan
  if (phase === 'planning') {
    return (
      <Claude tools={[filesystem, grep]} onFinished={setPlan}>
        <Architect />

        <Constraints>
          - Create tasks that can be worked on independently
          - Minimize dependencies between tasks
          - Each task should be completable by one developer
          - Consider the existing codebase structure
        </Constraints>

        <Phase name="analysis">
          <Step>Understand the feature requirements: {feature}</Step>
          {codebaseContext && (
            <Step>Review existing codebase context: {codebaseContext}</Step>
          )}
          <Step>Identify affected areas and integration points</Step>
        </Phase>

        <Phase name="planning">
          <Step>Break down into independent subtasks</Step>
          <Step>Define clear interfaces between components</Step>
          <Step>Identify dependencies and ordering</Step>
          <Step>Estimate complexity for each task</Step>
        </Phase>

        <OutputFormat
          schema={{
            overview: 'string - high-level description of the approach',
            subtasks: [
              {
                id: 'string - unique identifier',
                description: 'string - detailed task description',
                dependencies: 'string[] - IDs of tasks this depends on',
                estimatedComplexity: 'low | medium | high',
              },
            ],
            integrationNotes: 'string - how pieces fit together',
          }}
        >
          Return valid JSON with the implementation plan.
        </OutputFormat>
      </Claude>
    )
  }

  // Phase 2: Developers implement in parallel
  if (phase === 'implementing') {
    // Only implement tasks whose dependencies are met
    const completedIds = new Set(Object.keys(implementations))
    const readyTasks = plan!.subtasks.filter(
      (task) =>
        !completedIds.has(task.id) &&
        task.dependencies.every((dep) => completedIds.has(dep))
    )

    if (readyTasks.length === 0 && completedIds.size < plan!.subtasks.length) {
      // Waiting for dependencies - this shouldn't happen with good planning
      return (
        <Claude onFinished={() => {}}>
          Waiting for dependencies to complete...
        </Claude>
      )
    }

    return (
      <>
        {readyTasks.map((task) => (
          <Subagent key={task.id} name={`dev-${task.id}`}>
            <Claude
              tools={[filesystem, terminal]}
              onFinished={(impl: Implementation) =>
                addImplementation(task.id, impl)
              }
            >
              <Developer />

              <Constraints>
                - Follow existing project patterns and conventions
                - Write comprehensive unit tests
                - Keep code modular and maintainable
                - Document public interfaces
              </Constraints>

              <Phase name="context">
                Overall feature: {feature}
                Your task: {task.description}
                Complexity: {task.estimatedComplexity}

                {task.dependencies.length > 0 && (
                  <>
                    Dependencies completed:
                    {task.dependencies.map((dep) => (
                      <Step key={dep}>
                        {dep}: {implementations[dep]?.notes}
                      </Step>
                    ))}
                  </>
                )}
              </Phase>

              <Phase name="implement">
                <Step>Implement the feature according to the task</Step>
                <Step>Write unit tests with good coverage</Step>
                <Step>Document any public APIs</Step>
              </Phase>

              <OutputFormat
                schema={{
                  taskId: 'string',
                  files: [{ path: 'string', content: 'string' }],
                  tests: [{ path: 'string', content: 'string' }],
                  notes: 'string - summary for other developers',
                }}
              >
                Return JSON with implementation details.
              </OutputFormat>
            </Claude>
          </Subagent>
        ))}
      </>
    )
  }

  // Phase 3: Tech lead integrates and reviews
  if (phase === 'integrating') {
    return (
      <Claude tools={[filesystem, terminal]} onFinished={setIntegrationResult}>
        <TechLead />

        <Constraints>
          - Ensure all implementations work together
          - Run all tests and fix any failures
          - Check for inconsistencies in interfaces
          - Verify the feature works end-to-end
        </Constraints>

        <Phase name="review">
          <Step>Review all implementations for consistency</Step>
          <Step>Check interfaces match between components</Step>
          <Step>Identify any integration issues</Step>
        </Phase>

        <Phase name="integrate">
          <Step>Run all tests</Step>
          <Step>Fix any integration issues</Step>
          <Step>Verify end-to-end functionality</Step>
        </Phase>

        <Phase name="finalize">
          <Step>Create integration test if needed</Step>
          <Step>Update documentation</Step>
          <Step>Prepare summary of changes</Step>
        </Phase>

        Implementation plan:
        {JSON.stringify(plan, null, 2)}

        Individual implementations:
        {JSON.stringify(implementations, null, 2)}

        <OutputFormat
          schema={{
            success: 'boolean',
            testsPass: 'boolean',
            integrationIssues: 'string[]',
            summary: 'string',
            filesModified: 'string[]',
          }}
        >
          Return JSON with integration results.
        </OutputFormat>
      </Claude>
    )
  }

  return null
}
```

## Running the Team

```bash
# Preview the planning phase
smithers plan feature-team.tsx \
  --props '{"feature": "Add user authentication with OAuth"}'

# Execute the full workflow
smithers run feature-team.tsx \
  --props '{"feature": "Add user authentication with OAuth"}' \
  --verbose
```

## Execution Flow

```
Frame 1: Architect plans
  └─ Creates subtasks and dependencies

Frame 2: Developers implement (parallel)
  ├─ dev-auth-provider
  ├─ dev-login-ui
  └─ dev-session-manager

Frame 3: More developers (if dependencies allow)
  └─ dev-protected-routes (depends on session-manager)

Frame 4: Tech lead integrates
  └─ Reviews, tests, finalizes
```

## Key Patterns

<CardGroup cols={2}>
  <Card title="Specialized Roles" icon="users">
    Different personas for architect, developers, and tech lead
  </Card>
  <Card title="Dependency Management" icon="diagram-project">
    Tasks only start when dependencies are complete
  </Card>
  <Card title="Parallel Development" icon="layer-group">
    Independent tasks run concurrently via Subagent
  </Card>
  <Card title="Integration Phase" icon="puzzle-piece">
    Final review ensures everything works together
  </Card>
</CardGroup>

## Handling Complex Dependencies

For features with complex dependency graphs:

```tsx
function getReadyTasks(subtasks: Subtask[], completed: Set<string>) {
  return subtasks.filter(
    (task) =>
      !completed.has(task.id) &&
      task.dependencies.every((dep) => completed.has(dep))
  )
}

// In the implementing phase
const readyTasks = getReadyTasks(plan.subtasks, new Set(Object.keys(implementations)))

if (readyTasks.length === 0) {
  // All remaining tasks have unmet dependencies
  // This could indicate a circular dependency or planning issue
  return (
    <Claude>
      <Phase name="dependency-resolution">
        These tasks have unmet dependencies:
        {JSON.stringify(
          plan.subtasks.filter((t) => !implementations[t.id]),
          null,
          2
        )}

        Resolve the dependency issue or re-plan.
      </Phase>
    </Claude>
  )
}
```

## Related Examples

<CardGroup cols={2}>
  <Card title="Code Review" icon="magnifying-glass" href="/examples/code-review">
    Parallel file analysis pattern
  </Card>
  <Card title="Data Pipeline" icon="database" href="/examples/data-pipeline">
    Sequential processing with error handling
  </Card>
</CardGroup>
