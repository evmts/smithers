---
title: Coverage Loop
description: Automated test coverage improvement loop
---

# Coverage Loop

```tsx
#!/usr/bin/env smithers

import {
  createSmithersRoot,
  createSmithersDB,
  SmithersProvider,
  While,
  useWhileIteration,
  Claude,
  useSmithers,
  useQueryValue,
} from "smithers-orchestrator";

interface CoverageResult {
  functionCoverage: number;
  lineCoverage: number;
  passed: number;
  failed: number;
}

function parseCoverage(output: string): CoverageResult {
  const allFilesMatch = output.match(/All files\s*\|\s*([\d.]+)\s*\|\s*([\d.]+)/);
  const passMatch = output.match(/(\d+)\s+pass/);
  const failMatch = output.match(/(\d+)\s+fail/);
  return {
    functionCoverage: allFilesMatch ? parseFloat(allFilesMatch[1]) : 0,
    lineCoverage: allFilesMatch ? parseFloat(allFilesMatch[2]) : 0,
    passed: passMatch ? parseInt(passMatch[1], 10) : 0,
    failed: failMatch ? parseInt(failMatch[1], 10) : 0,
  };
}

const COVERAGE_PROMPT = `Improve test coverage:
1. Run \`bun test --coverage\`
2. Find lowest coverage files
3. Add tests (happy path, edge cases, errors)
4. Atomic commits, 2-3 tests per iteration max`;

function CoverageLoop({ targetCoverage = 98, maxIterations = 20 }) {
  const { db, reactiveDb } = useSmithers();
  const { data: checkCountVal } = useQueryValue<number>(
    reactiveDb, "SELECT json_extract(value, '$') as v FROM state WHERE key = 'coverage.checkCount'"
  );
  const checkCount = checkCountVal ?? 0;

  const checkCoverage = async (): Promise<boolean> => {
    const proc = Bun.spawn(["bun", "test", "--coverage"], { stdout: "pipe", stderr: "pipe" });
    const output = await new Response(proc.stdout).text();
    await proc.exited;

    const result = parseCoverage(output);
    const minCoverage = Math.min(result.functionCoverage, result.lineCoverage);

    db.state.set("coverage.current", minCoverage, "coverage_check");
    db.state.set("coverage.checkCount", checkCount + 1, "coverage_check");
    console.log(`[Check #${checkCount + 1}] ${minCoverage.toFixed(2)}%`);

    return minCoverage < targetCoverage;
  };

  return (
    <While
      id="coverage-improvement"
      condition={checkCoverage}
      maxIterations={maxIterations}
      onComplete={(iterations, reason) => console.log(`Done: ${iterations} iterations (${reason})`)}
    >
      <CoverageIteration />
    </While>
  );
}

function CoverageIteration() {
  const ctx = useWhileIteration();
  const { db } = useSmithers();

  return (
    <Claude
      model="sonnet"
      permissionMode="acceptEdits"
      maxTurns={50}
      onFinished={() => {
        db.state.set(`iteration.${ctx?.iteration}.completed`, true, "done");
        ctx?.signalComplete();
      }}
    >
      {COVERAGE_PROMPT}
    </Claude>
  );
}

async function main() {
  const db = createSmithersDB({ path: ".smithers/coverage-loop" });
  const executionId = db.execution.start("Coverage Loop", "coverage-loop.tsx");
  const root = createSmithersRoot();

  await root.mount(() => (
    <SmithersProvider db={db} executionId={executionId}>
      <CoverageLoop targetCoverage={98} maxIterations={20} />
    </SmithersProvider>
  ));

  db.execution.complete(executionId);
  db.close();
}

main();
```

## Run It

```bash
bun examples/coverage-loop/index.tsx
```

## What's Happening

- **While**: Loops until condition returns false or max iterations
- **condition**: Runs `bun test --coverage`, checks against target
- **useWhileIteration**: Provides iteration context, signalComplete()
- **SQLite state**: Coverage metrics persist, survive restarts

## Inspect Progress

```bash
smithers db state | grep coverage
smithers db transitions
```

## Customization

```tsx
// Different test runner
Bun.spawn(["bun", "test", "--coverage"]);

// Target specific files
const COVERAGE_PROMPT = `Focus on src/auth/*.ts, src/api/*.ts`;

// Stricter threshold
<CoverageLoop targetCoverage={100} maxIterations={50} />
```
