---
title: Feature Workflow
description: The complete development workflow - from research to implementation with human approval gates
---

# Feature Workflow

The flagship example demonstrating Smithers' full capabilities for production-grade feature development. This workflow mirrors how senior engineers build features:

1. **Research first** - understand the codebase before coding
2. **Human checkpoints** - catch issues early with approval gates
3. **POC validation** - discover unknowns before committing to a plan
4. **TDD flow** - types → tests (fail) → implementation (pass)
5. **Extended thinking** - deep analysis for complex decisions

## Workflow Phases

```
prompt-input → research → planning → plan-review (Human)
     ↓
    poc → poc-analysis (Deep Thinking) → refined-review (Human)
     ↓
 api-impl → test-impl → test-verify → implementation → done
```

| Phase | Description |
|-------|-------------|
| `prompt-input` | Human confirms the feature request |
| `research` | Agent searches files, docs, and codebase for context |
| `planning` | Agent creates implementation plan with test cases |
| `plan-review` | Human reviews and approves/rejects the plan |
| `poc` | Agent builds a quick proof of concept |
| `poc-analysis` | Deep analysis (extended thinking) of POC learnings |
| `refined-review` | Human reviews the improved, detailed plan |
| `api-impl` | Implement types, interfaces, JSDoc (throw not implemented) |
| `test-impl` | Write comprehensive tests |
| `test-verify` | Verify tests fail (TDD red phase) |
| `implementation` | Implement actual code to make tests pass |
| `done` | Complete |

## Full Implementation

```tsx
import { create } from 'zustand'
import {
  executePlan,
  Claude,
  Phase,
  Step,
  Persona,
  Constraints,
  OutputFormat,
  Human,
  Stop,
} from 'smithers'

// =============================================================================
// Types
// =============================================================================

type WorkflowPhase =
  | 'prompt-input'
  | 'research'
  | 'planning'
  | 'plan-review'
  | 'poc'
  | 'poc-analysis'
  | 'refined-review'
  | 'api-impl'
  | 'test-impl'
  | 'test-verify'
  | 'implementation'
  | 'done'
  | 'cancelled'

interface Plan {
  summary: string
  steps: Array<{ step: number; description: string; files: string[] }>
  testCases: Array<{ name: string; description: string; edgeCase: boolean }>
  apis: Array<{ name: string; signature: string; description: string }>
  risks: string[]
}

interface POCResult {
  working: boolean
  implementation: string
  discoveries: string[]
  suggestions: string[]
}

// =============================================================================
// State Management
// =============================================================================

const phaseOrder: WorkflowPhase[] = [
  'prompt-input', 'research', 'planning', 'plan-review',
  'poc', 'poc-analysis', 'refined-review',
  'api-impl', 'test-impl', 'test-verify', 'implementation', 'done',
]

interface WorkflowState {
  phase: WorkflowPhase
  prompt: string
  fileResearch: Array<{ path: string; relevance: string; summary: string }>
  initialPlan: Plan | null
  refinedPlan: Plan | null
  pocResult: POCResult | null
  pocAnalysis: string | null

  setPhase: (phase: WorkflowPhase) => void
  setPrompt: (prompt: string) => void
  setFileResearch: (research: WorkflowState['fileResearch']) => void
  setInitialPlan: (plan: Plan) => void
  setRefinedPlan: (plan: Plan) => void
  setPOCResult: (result: POCResult) => void
  setPOCAnalysis: (analysis: string) => void
  nextPhase: () => void
}

const useWorkflowStore = create<WorkflowState>((set, get) => ({
  phase: 'prompt-input',
  prompt: '',
  fileResearch: [],
  initialPlan: null,
  refinedPlan: null,
  pocResult: null,
  pocAnalysis: null,

  setPhase: (phase) => set({ phase }),
  setPrompt: (prompt) => set({ prompt }),
  setFileResearch: (fileResearch) => set({ fileResearch }),
  setInitialPlan: (initialPlan) => set({ initialPlan }),
  setRefinedPlan: (refinedPlan) => set({ refinedPlan }),
  setPOCResult: (pocResult) => set({ pocResult }),
  setPOCAnalysis: (pocAnalysis) => set({ pocAnalysis }),
  nextPhase: () => {
    const { phase } = get()
    const idx = phaseOrder.indexOf(phase)
    if (idx < phaseOrder.length - 1) set({ phase: phaseOrder[idx + 1] })
  },
}))

// =============================================================================
// Phase Components
// =============================================================================

function PromptInputPhase({ initialPrompt }: { initialPrompt: string }) {
  const { setPrompt, nextPhase, setPhase } = useWorkflowStore()

  return (
    <Human
      message="Review the feature request before proceeding"
      onApprove={() => { setPrompt(initialPrompt); nextPhase() }}
      onReject={() => setPhase('cancelled')}
    >
      Feature Request: {initialPrompt}
    </Human>
  )
}

function ResearchPhase() {
  const { prompt, setFileResearch, nextPhase } = useWorkflowStore()

  return (
    <Claude
      allowedTools={['Read', 'Glob', 'Grep', 'WebFetch']}
      onFinished={(result) => {
        setFileResearch(result.files || [])
        nextPhase()
      }}
    >
      <Persona role="senior software architect">
        You explore codebases thoroughly before acting.
      </Persona>
      <Phase name="research">
        <Step>Search for relevant file paths</Step>
        <Step>Find existing patterns and conventions</Step>
        <Step>Identify integration points</Step>
      </Phase>
      <Constraints>
        - Focus on understanding, not implementing
        - Be thorough - gather context before acting
      </Constraints>
      Feature to implement: {prompt}
    </Claude>
  )
}

function PlanningPhase() {
  const { prompt, fileResearch, setInitialPlan, nextPhase } = useWorkflowStore()

  return (
    <Claude onFinished={(plan) => { setInitialPlan(plan); nextPhase() }}>
      <Persona role="software architect">
        Create detailed, actionable implementation plans.
      </Persona>
      <Phase name="planning">
        <Step>Analyze research findings</Step>
        <Step>Break down into concrete steps</Step>
        <Step>Identify test cases including edge cases</Step>
        <Step>Define public API surface</Step>
      </Phase>
      Feature: {prompt}
      Research: {JSON.stringify(fileResearch, null, 2)}
      <OutputFormat schema={{
        summary: { type: 'string' },
        steps: { type: 'array' },
        testCases: { type: 'array' },
        apis: { type: 'array' },
        risks: { type: 'array' },
      }}>
        Return a JSON implementation plan.
      </OutputFormat>
    </Claude>
  )
}

function PlanReviewPhase() {
  const { initialPlan, nextPhase, setPhase } = useWorkflowStore()

  return (
    <Human
      message="Review the implementation plan"
      onApprove={() => nextPhase()}
      onReject={() => setPhase('cancelled')}
    >
      Summary: {initialPlan?.summary}
      Steps: {initialPlan?.steps.map((s, i) => `${i + 1}. ${s.description}`).join('\n')}
      Test Cases: {initialPlan?.testCases.length}
      APIs: {initialPlan?.apis.map(a => a.name).join(', ')}
    </Human>
  )
}

function POCPhase() {
  const { prompt, initialPlan, setPOCResult, nextPhase } = useWorkflowStore()

  return (
    <Claude
      allowedTools={['Read', 'Write', 'Edit', 'Bash']}
      onFinished={(result) => { setPOCResult(result); nextPhase() }}
    >
      <Persona role="rapid prototyping engineer">
        Build quick, working prototypes to validate approaches.
      </Persona>
      <Phase name="poc">
        <Step>Implement minimum viable version</Step>
        <Step>Focus on core functionality</Step>
        <Step>Document discoveries</Step>
      </Phase>
      <Constraints>
        - Build a WORKING proof of concept
        - This is throwaway code to inform the plan
        - Document discoveries and suggestions
      </Constraints>
      Feature: {prompt}
      Plan: {JSON.stringify(initialPlan, null, 2)}
    </Claude>
  )
}

function POCAnalysisPhase() {
  const { initialPlan, pocResult, setPOCAnalysis, setRefinedPlan, nextPhase } = useWorkflowStore()

  return (
    <Claude
      maxThinkingTokens={16000}
      onFinished={(result) => {
        setPOCAnalysis(result.analysis)
        setRefinedPlan(result.refinedPlan)
        nextPhase()
      }}
    >
      <Persona role="senior architect">
        Deep, thorough analysis with extended thinking.
      </Persona>
      <Phase name="poc-analysis">
        <Step>Analyze POC discoveries</Step>
        <Step>Identify gaps in original plan</Step>
        <Step>Add additional test cases</Step>
        <Step>Refine API designs</Step>
      </Phase>
      Original plan: {JSON.stringify(initialPlan, null, 2)}
      POC results: {JSON.stringify(pocResult, null, 2)}
    </Claude>
  )
}

function RefinedReviewPhase() {
  const { refinedPlan, pocAnalysis, nextPhase, setPhase } = useWorkflowStore()

  return (
    <Human
      message="Review the refined plan"
      onApprove={() => nextPhase()}
      onReject={() => setPhase('cancelled')}
    >
      Analysis: {pocAnalysis}
      Refined Plan: {JSON.stringify(refinedPlan, null, 2)}
    </Human>
  )
}

function APIImplementationPhase() {
  const { refinedPlan, nextPhase } = useWorkflowStore()

  return (
    <Claude
      allowedTools={['Read', 'Write', 'Edit']}
      onFinished={() => nextPhase()}
    >
      <Phase name="api-impl">
        <Step>Create TypeScript interfaces</Step>
        <Step>Write JSDoc documentation</Step>
        <Step>All functions throw new Error('Not implemented')</Step>
      </Phase>
      <Constraints>
        - ONLY types and signatures
        - ALL bodies throw 'Not implemented'
      </Constraints>
      APIs: {JSON.stringify(refinedPlan?.apis, null, 2)}
    </Claude>
  )
}

function TestImplementationPhase() {
  const { refinedPlan, nextPhase } = useWorkflowStore()

  return (
    <Claude
      allowedTools={['Read', 'Write', 'Edit']}
      onFinished={() => nextPhase()}
    >
      <Phase name="test-impl">
        <Step>Write tests for all test cases</Step>
        <Step>Tests should FAIL at this point</Step>
      </Phase>
      Test cases: {JSON.stringify(refinedPlan?.testCases, null, 2)}
    </Claude>
  )
}

function TestVerificationPhase() {
  const { nextPhase } = useWorkflowStore()

  return (
    <Claude
      allowedTools={['Bash']}
      onFinished={() => nextPhase()}
    >
      <Phase name="test-verify">
        <Step>Run test suite</Step>
        <Step>Verify tests fail with "Not implemented"</Step>
      </Phase>
    </Claude>
  )
}

function ImplementationPhase() {
  const { refinedPlan, nextPhase } = useWorkflowStore()

  return (
    <Claude
      allowedTools={['Read', 'Write', 'Edit', 'Bash']}
      onFinished={() => nextPhase()}
    >
      <Phase name="implementation">
        <Step>Replace stubs with real implementation</Step>
        <Step>Run tests after each change</Step>
        <Step>Continue until all tests pass</Step>
      </Phase>
      Plan: {JSON.stringify(refinedPlan, null, 2)}
    </Claude>
  )
}

// =============================================================================
// Main Orchestrator
// =============================================================================

export function FeatureWorkflow({ prompt: initialPrompt }: { prompt: string }) {
  const { phase } = useWorkflowStore()

  switch (phase) {
    case 'prompt-input': return <PromptInputPhase initialPrompt={initialPrompt} />
    case 'research': return <ResearchPhase />
    case 'planning': return <PlanningPhase />
    case 'plan-review': return <PlanReviewPhase />
    case 'poc': return <POCPhase />
    case 'poc-analysis': return <POCAnalysisPhase />
    case 'refined-review': return <RefinedReviewPhase />
    case 'api-impl': return <APIImplementationPhase />
    case 'test-impl': return <TestImplementationPhase />
    case 'test-verify': return <TestVerificationPhase />
    case 'implementation': return <ImplementationPhase />
    case 'done': return null
    case 'cancelled': return <Stop reason="Cancelled by user" />
    default: return null
  }
}

// =============================================================================
// Execution
// =============================================================================

await executePlan(
  <FeatureWorkflow prompt="Add user authentication" />,
  {
    onHumanPrompt: async (message, content) => {
      console.log('HUMAN REVIEW:', message)
      console.log(content)
      return true // or show UI for approval
    },
  }
)
```

## Key Concepts Demonstrated

### Human-in-the-Loop Approval

Multiple checkpoints where humans can approve or reject:

```tsx
<Human
  message="Review the implementation plan"
  onApprove={() => nextPhase()}
  onReject={() => setPhase('cancelled')}
>
  {planDetails}
</Human>
```

### Extended Thinking for Deep Analysis

The POC analysis phase uses extended thinking tokens for complex reasoning:

```tsx
<Claude maxThinkingTokens={16000}>
  <Phase name="poc-analysis">
    <Step>Analyze POC discoveries deeply</Step>
  </Phase>
</Claude>
```

### Test-Driven Development Flow

The workflow enforces TDD:

1. **api-impl**: Types and JSDoc only, functions throw "Not implemented"
2. **test-impl**: Write tests that call the not-yet-implemented code
3. **test-verify**: Verify tests fail with "Not implemented" errors
4. **implementation**: Replace stubs with real code until tests pass

### POC-Driven Refinement

Build something quick to learn, then refine:

```
Initial Plan → POC → Discoveries → Refined Plan (better APIs, more tests)
```

## Running the Example

```bash
# From the examples directory
bun run examples/00-feature-workflow/agent.tsx "Add user authentication"
```

## Customization

### Skip POC Phase

For simpler features, modify the phase order:

```tsx
const phaseOrder = [
  'prompt-input', 'research', 'planning', 'plan-review',
  'api-impl', 'test-impl', 'test-verify', 'implementation', 'done',
]
```

### Add Custom Phases

Add domain-specific phases like security review:

```tsx
case 'security-review':
  return (
    <Claude>
      <Persona role="security engineer">
        Review for security vulnerabilities.
      </Persona>
    </Claude>
  )
```
