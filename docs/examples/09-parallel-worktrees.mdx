---
title: "Parallel Worktrees"
description: "Parallel feature development with git worktree isolation"
---

# Parallel Worktrees

Parallel feature development using git worktrees for complete filesystem isolation.

## What This Example Shows

- Using the `<Worktree>` component for parallel agent isolation
- Git worktree lifecycle management (create, execute, cleanup)
- Parallel execution with `<Subagent parallel={true}>`
- Coordinated multi-feature development
- Automatic cwd injection for child agents

## The Code

```tsx
import { executePlan, Worktree, Subagent, Claude } from '@evmts/smithers'

function ParallelFeatureDevelopment({
  features
}: {
  features: Array<{ name: string; task: string }>
}) {
  return (
    <Subagent name="coordinator" parallel={true}>
      {features.map(feature => (
        <Worktree
          key={feature.name}
          path={`./worktrees/${feature.name}`}
          branch={`feature/${feature.name}`}
          cleanup={true}
          onCreated={() => console.log(`âœ“ Worktree created: ${feature.name}`)}
          onCleanup={() => console.log(`âœ“ Worktree cleaned: ${feature.name}`)}
        >
          <Claude
            allowedTools={['Read', 'Edit', 'Write', 'Bash']}
            onFinished={() => {
              console.log(`âœ“ Feature complete: ${feature.name}`)
            }}
          >
            Implement feature: {feature.name}

            Task: {feature.task}

            Steps:
            1. Create necessary files
            2. Implement the feature
            3. Write tests
            4. Commit your changes

            You are working in an isolated git worktree.
            All file operations happen in this worktree only.
          </Claude>
        </Worktree>
      ))}
    </Subagent>
  )
}

// CLI execution
const features = [
  {
    name: 'auth',
    task: 'Add user authentication with JWT tokens'
  },
  {
    name: 'api',
    task: 'Create REST API endpoints for user data'
  },
  {
    name: 'ui',
    task: 'Build login/signup forms in React'
  }
]

console.log('ðŸš€ Parallel Feature Development Starting')
console.log(`  Features: ${features.map(f => f.name).join(', ')}`)

const result = await executePlan(
  () => <ParallelFeatureDevelopment features={features} />
)

console.log('âœ… All Features Complete')
console.log(`  Total time: ${result.totalDuration}ms`)
console.log(`  Frames: ${result.frames}`)
```

## Running

```bash
# Run with 3 parallel features (default)
bun run examples/09-parallel-worktrees/agent.tsx

# Run with custom features
bun run examples/09-parallel-worktrees/agent.tsx \
  auth "Add JWT authentication" \
  api "Create REST API" \
  ui "Build React components"
```

## Example Output

```
ðŸš€ Parallel Feature Development Starting
  Features: auth, api, ui

âœ“ Worktree created: auth
âœ“ Worktree created: api
âœ“ Worktree created: ui

âœ“ Feature complete: auth
âœ“ Feature complete: api
âœ“ Feature complete: ui

âœ“ Worktree cleaned: auth
âœ“ Worktree cleaned: api
âœ“ Worktree cleaned: ui

âœ… All Features Complete
  Total time: 45230ms
  Frames: 4
```

## Key Concepts

### Worktree Component

The `<Worktree>` component creates an isolated git worktree:

```tsx
<Worktree
  path="./worktrees/feature-a"
  branch="feature/feature-a"
  cleanup={true}
>
  {/* Child agents work in this worktree */}
</Worktree>
```

Features:
- **Isolated filesystem** - Each worktree has its own working directory
- **Separate branch** - Each worktree checks out a different branch
- **Automatic cleanup** - Worktrees are removed after execution (optional)
- **cwd injection** - Child Claude components automatically run in the worktree directory

### Parallel Execution

Combine `<Subagent parallel={true}>` with multiple worktrees:

```tsx
<Subagent parallel={true}>
  <Worktree path="./wt/feature-a" branch="feature-a">
    <Claude>Implement feature A</Claude>
  </Worktree>
  <Worktree path="./wt/feature-b" branch="feature-b">
    <Claude>Implement feature B</Claude>
  </Worktree>
</Subagent>
```

All worktrees execute simultaneously without conflicts.

### Worktree Lifecycle

1. **Creation**: `git worktree add <path> -b <branch>`
2. **Execution**: Child agents run in the worktree directory
3. **Cleanup**: `git worktree remove <path>` (if `cleanup={true}`)

Callbacks available:
- `onCreated()` - Called after worktree is created
- `onCleanup()` - Called after worktree is removed

## Use Cases

### 1. Parallel Feature Development

Work on multiple features simultaneously without conflicts:

```tsx
features.map(feature => (
  <Worktree path={`./wt/${feature}`} branch={`feature/${feature}`}>
    <Claude>Implement {feature}</Claude>
  </Worktree>
))
```

### 2. Experimental Refactoring

Try different refactoring approaches in parallel:

```tsx
approaches.map(approach => (
  <Worktree path={`./wt/refactor-${approach}`}>
    <Claude>Refactor using {approach} pattern</Claude>
  </Worktree>
))
```

### 3. Multi-Version Testing

Test changes against multiple versions:

```tsx
versions.map(version => (
  <Worktree path={`./wt/test-${version}`} branch={`release/${version}`}>
    <Claude>Run tests for version {version}</Claude>
  </Worktree>
))
```

### 4. Code Review Assistance

Review multiple PRs simultaneously:

```tsx
prs.map(pr => (
  <Worktree path={`./wt/pr-${pr.number}`} branch={`pr/${pr.number}`}>
    <Claude>Review PR #{pr.number}: {pr.title}</Claude>
  </Worktree>
))
```

## Extending This Example

### Add PR Creation

After feature completion, automatically create PRs:

```tsx
<Claude
  allowedTools={['Bash']}
  onFinished={() => {
    console.log(`âœ“ Feature complete: ${feature.name}`)
    console.log(`  Creating PR...`)
  }}
>
  1. Implement feature
  2. Commit changes
  3. Push branch to remote
  4. Create PR using: gh pr create --title "{feature.name}" --body "{feature.task}"
</Claude>
```

### Add Merge Coordination

Coordinate merging multiple features:

```tsx
<Subagent name="merger">
  Wait for all feature branches to complete.
  Then merge them into main in dependency order:
  1. auth (no dependencies)
  2. api (depends on auth)
  3. ui (depends on api)
</Subagent>
```

### Add Conflict Detection

Check for merge conflicts before cleanup:

```tsx
<Claude allowedTools={['Bash']}>
  Before cleaning up worktree:
  1. Fetch latest main
  2. Try merge: git merge main
  3. If conflicts, report them
  4. Don't cleanup if conflicts exist
</Claude>
```

## Safety Considerations

### Branch Name Validation

Branch names are validated to prevent command injection:

- Allowed: `feature-123`, `bug/fix-auth`, `release-v1.0`
- Blocked: `--help`, `../../../etc/passwd`, `; rm -rf`

### Cleanup Behavior

- `cleanup={true}` (default): Worktree is removed after execution
- `cleanup={false}`: Worktree persists for manual inspection

### Error Handling

If a worktree fails to create:
- Child agents are blocked with clear error message
- Other worktrees continue executing
- Failed worktrees can be retried

## Related Examples

- [07-git-helper](/examples/07-git-helper) - AI-powered git operations
- [02-code-review](/examples/02-code-review) - Automated code review
- [00-feature-workflow](/examples/feature-workflow) - Complete development workflow
