---
title: "Test Generator"
description: "Automated test generation from source code with multiple frameworks"
---

# Test Generator

Automated test generation from source code files using AI analysis and structured output.

## What This Example Shows

- Code analysis with the `Read` tool
- Structured output with `<OutputFormat>` component
- Multi-phase workflow (analyze â†’ generate â†’ write)
- Support for multiple test frameworks (Bun, Jest, Vitest)
- Writing test files with `<File>` component

## The Code

```tsx
import { Claude, executePlan, File, OutputFormat } from 'smithers'
import { create } from 'zustand'

interface TestGeneratorState {
  phase: 'analyze' | 'generate' | 'write' | 'done'
  exports: string[]
  testContent: string
  setPhase: (phase: TestGeneratorState['phase']) => void
  setExports: (exports: string[]) => void
  setTestContent: (content: string) => void
}

const useStore = create<TestGeneratorState>((set) => ({
  phase: 'analyze',
  exports: [],
  testContent: '',
  setPhase: (phase) => set({ phase }),
  setExports: (exports) => set({ exports }),
  setTestContent: (content) => set({ testContent: content }),
}))

function TestGenerator({
  sourceFile,
  framework = 'bun'
}: {
  sourceFile: string
  framework?: 'bun' | 'jest' | 'vitest'
}) {
  const { phase, exports, testContent, setPhase, setExports, setTestContent } =
    useStore()

  // Phase 1: Analyze source file
  if (phase === 'analyze') {
    return (
      <Claude allowedTools={['Read']} onFinished={(result) => {
        // Extract exports from structured output
        try {
          const json = JSON.parse(result.text)
          setExports(json.exports || [])
          setPhase('generate')
        } catch {
          setExports([])
          setPhase('generate')
        }
      }}>
        Analyze the source file: {sourceFile}

        <OutputFormat schema={{
          exports: ['function names exported from this file']
        }} />

        Read the file and extract all exported functions, classes, and types.
      </Claude>
    )
  }

  // Phase 2: Generate tests
  if (phase === 'generate') {
    return (
      <Claude onFinished={(result) => {
        setTestContent(result.text)
        setPhase('write')
      }}>
        Generate comprehensive tests for: {sourceFile}

        The file exports: {exports.join(', ')}

        Create tests using {framework} test framework that cover:
        1. Happy path cases
        2. Edge cases
        3. Error handling
        4. Type checking (if TypeScript)

        Use {framework} syntax:
        {framework === 'bun' && 'import { test, expect } from "bun:test"'}
        {framework === 'jest' && 'import { test, expect } from "@jest/globals"'}
        {framework === 'vitest' && 'import { test, expect } from "vitest"'}

        Return ONLY the test code, no markdown formatting.
      </Claude>
    )
  }

  // Phase 3: Write test file
  if (phase === 'write') {
    const testFilePath = sourceFile.replace(
      /\.(ts|tsx|js|jsx)$/,
      '.test.$1'
    )

    return (
      <File
        path={testFilePath}
        onWritten={() => {
          console.log(`âœ“ Test file written: ${testFilePath}`)
          setPhase('done')
        }}
      >
        {testContent}
      </File>
    )
  }

  return null // Done
}

// CLI execution
const sourceFile = process.argv[2]
const framework = (process.argv[3] || 'bun') as 'bun' | 'jest' | 'vitest'

if (!sourceFile) {
  console.error('Usage: bun run agent.tsx <source-file> [framework]')
  console.error('Frameworks: bun (default), jest, vitest')
  process.exit(1)
}

console.log('ðŸ§ª Test Generator Starting')
console.log(`  Source: ${sourceFile}`)
console.log(`  Framework: ${framework}`)

await executePlan(<TestGenerator sourceFile={sourceFile} framework={framework} />)

const state = useStore.getState()
console.log('âœ… Test Generation Complete')
console.log(`  Generated tests for ${state.exports.length} exports`)
```

## Running

### Generate tests with Bun (default)

```bash
bun run examples/08-test-generator/agent.tsx src/utils.ts
```

### Generate tests with Jest

```bash
bun run examples/08-test-generator/agent.tsx src/utils.ts jest
```

### Generate tests with Vitest

```bash
bun run examples/08-test-generator/agent.tsx src/utils.ts vitest
```

## Example Output

```
ðŸ§ª Test Generator Starting
  Source: src/utils.ts
  Framework: bun

âœ“ Test file written: src/utils.test.ts
âœ… Test Generation Complete
  Generated tests for 5 exports
```

The generated test file (`src/utils.test.ts`) will contain:

```typescript
import { test, expect } from "bun:test"
import { add, subtract, multiply, divide, isEven } from "./utils"

test("add should sum two numbers", () => {
  expect(add(2, 3)).toBe(5)
  expect(add(-1, 1)).toBe(0)
  expect(add(0, 0)).toBe(0)
})

test("divide should throw on division by zero", () => {
  expect(() => divide(10, 0)).toThrow()
})

// ... more tests
```

## Key Concepts

### Code Analysis with OutputFormat

The `<OutputFormat>` component guides Claude to return structured data:

```tsx
<OutputFormat schema={{
  exports: ['function names exported from this file']
}} />
```

This ensures the output is parseable JSON rather than free-form text.

### Multi-Phase Workflow

The example uses three phases:

1. **Analyze**: Read source file and extract exports
2. **Generate**: Create test code for each export
3. **Write**: Save test file to disk

Each phase transitions to the next via `setPhase()` callbacks.

### Framework-Specific Syntax

The generator adapts to different test frameworks:

```tsx
{framework === 'bun' && 'import { test, expect } from "bun:test"'}
{framework === 'jest' && 'import { test, expect } from "@jest/globals"'}
{framework === 'vitest' && 'import { test, expect } from "vitest"'}
```

Claude generates tests using the correct import statements and syntax.

## Extending This Example

### Add Test Coverage Analysis

```tsx
<Claude allowedTools={['Bash']}>
  1. Run tests with coverage: bun test --coverage
  2. Parse coverage report
  3. Identify uncovered lines
  4. Generate additional tests for uncovered code
</Claude>
```

### Add Test Execution

```tsx
<Claude allowedTools={['Bash']}>
  After generating tests:
  1. Run the test file: bun test {testFilePath}
  2. Parse test results
  3. If tests fail, analyze failures and regenerate
</Claude>
```

### Add Property-Based Testing

```tsx
<Claude>
  Generate property-based tests using fast-check:

  import { fc, test } from '@fast-check/vitest'

  test.prop([fc.integer(), fc.integer()])('add is commutative', (a, b) => {
    expect(add(a, b)).toBe(add(b, a))
  })
</Claude>
```

## Safety Considerations

- **Review generated tests** - AI-generated tests may not cover all edge cases
- **Verify test assertions** - Ensure expectations match actual behavior
- **Run tests before committing** - Validate generated tests pass

## Related Examples

- [06-file-processor](/examples/06-file-processor) - Multi-phase file transformation
- [02-code-review](/examples/02-code-review) - Code analysis with structured output
- [11-rate-limited-batch](/examples/11-rate-limited-batch) - Process many files
