---
title: Conditional Phases
description: Shows conditional phase execution based on runtime state
---

# Conditional Phases

This example demonstrates how to conditionally execute phases based on runtime state, user input, or the results of previous phases.

## Complete Example

```tsx
import { create } from 'zustand'
import {
  Claude,
  Phase,
  Step,
  Subagent,
  Persona,
  Constraints,
  OutputFormat,
} from '@evmts/smithers'

// Type definitions
interface AnalysisResult {
  complexity: 'simple' | 'moderate' | 'complex'
  hasSecurityConcerns: boolean
  requiresReview: boolean
  estimatedEffort: number // hours
  riskLevel: 'low' | 'medium' | 'high'
}

interface TaskState {
  phase: 'analyze' | 'plan' | 'execute' | 'review' | 'complete'
  analysis: AnalysisResult | null
  plan: string | null
  result: unknown | null
  reviewResult: unknown | null
}

// State management with conditional transitions
const useTaskStore = create<
  TaskState & {
    setAnalysis: (analysis: AnalysisResult) => void
    setPlan: (plan: string) => void
    setResult: (result: unknown) => void
    setReviewResult: (result: unknown) => void
    skipToComplete: () => void
  }
>((set, get) => ({
  phase: 'analyze',
  analysis: null,
  plan: null,
  result: null,
  reviewResult: null,

  setAnalysis: (analysis) => {
    // Conditional phase transition based on complexity
    const nextPhase = analysis.complexity === 'simple'
      ? 'execute'  // Skip planning for simple tasks
      : 'plan'     // Complex tasks need planning

    set({ analysis, phase: nextPhase })
  },

  setPlan: (plan) => set({ plan, phase: 'execute' }),

  setResult: (result) => {
    const { analysis } = get()
    // Conditional review phase based on risk
    const nextPhase = analysis?.requiresReview || analysis?.riskLevel === 'high'
      ? 'review'
      : 'complete'

    set({ result, phase: nextPhase })
  },

  setReviewResult: (reviewResult) =>
    set({ reviewResult, phase: 'complete' }),

  skipToComplete: () => set({ phase: 'complete' }),
}))

// Analyst persona for initial assessment
function Analyst() {
  return (
    <Persona role="Task Analyst">
      You are an expert at analyzing tasks and determining the best approach.
      You accurately assess complexity, identify risks, and estimate effort.
    </Persona>
  )
}

// Reviewer persona for quality checks
function Reviewer() {
  return (
    <Persona role="Quality Reviewer">
      You are a meticulous reviewer who catches issues and ensures quality.
      You focus on correctness, security, and best practices.
    </Persona>
  )
}

// Main conditional agent
export function ConditionalTaskAgent({
  task,
  forceReview = false,
  skipAnalysis = false,
}: {
  task: string
  forceReview?: boolean
  skipAnalysis?: boolean
}) {
  const {
    phase,
    analysis,
    plan,
    result,
    setAnalysis,
    setPlan,
    setResult,
    setReviewResult,
    skipToComplete,
  } = useTaskStore()

  // Skip analysis if requested (for known simple tasks)
  if (skipAnalysis && phase === 'analyze') {
    setAnalysis({
      complexity: 'simple',
      hasSecurityConcerns: false,
      requiresReview: forceReview,
      estimatedEffort: 1,
      riskLevel: 'low',
    })
    return null // Re-render with new state
  }

  // Phase 1: Analyze the task
  if (phase === 'analyze') {
    return (
      <Claude onFinished={setAnalysis}>
        <Analyst />

        <Constraints>
          - Assess task complexity honestly
          - Identify any security implications
          - Estimate effort in hours
          - Flag tasks that need review
        </Constraints>

        <Phase name="analyze">
          Analyze this task and determine the best approach:

          Task: {task}

          <Step>Assess complexity (simple, moderate, complex)</Step>
          <Step>Check for security concerns</Step>
          <Step>Estimate effort required</Step>
          <Step>Determine if review is needed</Step>
        </Phase>

        <OutputFormat
          schema={{
            complexity: 'simple | moderate | complex',
            hasSecurityConcerns: 'boolean',
            requiresReview: 'boolean',
            estimatedEffort: 'number (hours)',
            riskLevel: 'low | medium | high',
            reasoning: 'string',
          }}
        >
          Return JSON with your analysis.
        </OutputFormat>
      </Claude>
    )
  }

  // Phase 2: Plan (only for moderate/complex tasks)
  if (phase === 'plan') {
    return (
      <Claude onFinished={setPlan}>
        <Analyst />

        <Constraints>
          - Create a detailed plan for a {analysis!.complexity} task
          - Address security concerns if any: {analysis!.hasSecurityConcerns}
          - Estimated effort: {analysis!.estimatedEffort} hours
        </Constraints>

        <Phase name="plan">
          Create an execution plan for:

          Task: {task}

          <Step>Break down into subtasks</Step>
          <Step>Identify dependencies</Step>
          <Step>Plan for risk mitigation</Step>
          <Step>Define success criteria</Step>
        </Phase>

        <OutputFormat
          schema={{
            steps: [
              {
                order: 'number',
                description: 'string',
                dependencies: ['number'],
                riskMitigation: 'string (optional)',
              },
            ],
            successCriteria: ['string'],
            rollbackPlan: 'string',
          }}
        >
          Return JSON with the execution plan.
        </OutputFormat>
      </Claude>
    )
  }

  // Phase 3: Execute
  if (phase === 'execute') {
    // Different execution strategies based on complexity
    const ExecutionComponent = () => {
      if (analysis?.complexity === 'simple') {
        return (
          <Claude onFinished={setResult}>
            <Phase name="quick-execute">
              <Step>Execute this simple task directly: {task}</Step>
            </Phase>
          </Claude>
        )
      }

      if (analysis?.complexity === 'complex') {
        // Complex tasks might use parallel subagents
        return (
          <Claude onFinished={setResult}>
            <Phase name="complex-execute">
              Following the plan:
              {plan}

              <Step>Execute each step in order</Step>
              <Step>Handle dependencies correctly</Step>
              <Step>Apply risk mitigations as needed</Step>
            </Phase>
          </Claude>
        )
      }

      // Moderate complexity
      return (
        <Claude onFinished={setResult}>
          <Phase name="execute">
            Task: {task}
            {plan && (
              <>
                Plan: {plan}
              </>
            )}

            <Step>Execute the task</Step>
            <Step>Verify completion</Step>
          </Phase>
        </Claude>
      )
    }

    return <ExecutionComponent />
  }

  // Phase 4: Review (conditional)
  if (phase === 'review') {
    return (
      <Claude onFinished={setReviewResult}>
        <Reviewer />

        <Constraints>
          - Review the result thoroughly
          - Check for correctness and completeness
          {analysis?.hasSecurityConcerns && (
            '- Pay special attention to security aspects'
          )}
          - Suggest improvements if needed
        </Constraints>

        <Phase name="review">
          Review this task result:

          Original task: {task}
          Complexity: {analysis?.complexity}
          Risk level: {analysis?.riskLevel}

          Result:
          {JSON.stringify(result, null, 2)}

          <Step>Verify correctness</Step>
          <Step>Check for issues</Step>
          <Step>Provide feedback</Step>
        </Phase>

        <OutputFormat
          schema={{
            approved: 'boolean',
            issues: ['string'],
            suggestions: ['string'],
            overallQuality: 'poor | acceptable | good | excellent',
          }}
        >
          Return JSON with review results.
        </OutputFormat>
      </Claude>
    )
  }

  return null
}

// Example: Multi-path conditional workflow
import { createSignal } from 'solid-js'

export function MultipathAgent({
  input,
  mode,
}: {
  input: string
  mode: 'fast' | 'thorough' | 'balanced'
}) {
  const [result, setResult] = createSignal(null)

  // Different paths based on mode
  if (mode === 'fast') {
    return (
      <Claude onFinished={setResult}>
        <Constraints>
          - Speed is priority
          - Skip detailed analysis
          - Provide quick, actionable response
        </Constraints>

        <Phase name="quick-response">
          Respond quickly to: {input}
        </Phase>
      </Claude>
    )
  }

  if (mode === 'thorough') {
    return (
      <Claude onFinished={setResult}>
        <Constraints>
          - Be comprehensive and detailed
          - Consider all edge cases
          - Provide extensive documentation
        </Constraints>

        <Phase name="research">
          <Step>Deeply analyze: {input}</Step>
          <Step>Research related topics</Step>
          <Step>Consider alternatives</Step>
        </Phase>

        <Phase name="synthesize">
          <Step>Combine findings</Step>
          <Step>Provide detailed response</Step>
          <Step>Include citations and references</Step>
        </Phase>
      </Claude>
    )
  }

  // Balanced mode
  return (
    <Claude onFinished={setResult}>
      <Constraints>
        - Balance speed and thoroughness
        - Focus on key points
        - Be concise but complete
      </Constraints>

      <Phase name="balanced-response">
        <Step>Analyze key aspects of: {input}</Step>
        <Step>Provide balanced response</Step>
      </Phase>
    </Claude>
  )
}

// Example: Feature flag driven phases
export function FeatureFlagAgent({
  task,
  features,
}: {
  task: string
  features: {
    useNewAlgorithm: boolean
    enableCaching: boolean
    parallelExecution: boolean
  }
}) {
  return (
    <Claude>
      <Constraints>
        {features.useNewAlgorithm && (
          '- Use the new v2 algorithm for processing'
        )}
        {features.enableCaching && (
          '- Cache intermediate results for efficiency'
        )}
        {!features.parallelExecution && (
          '- Execute steps sequentially (parallel disabled)'
        )}
      </Constraints>

      {features.enableCaching && (
        <Phase name="cache-check">
          <Step>Check if result is cached</Step>
          <Step>Return cached result if available</Step>
        </Phase>
      )}

      <Phase name="execute">
        {features.useNewAlgorithm ? (
          <Step>Execute using v2 algorithm</Step>
        ) : (
          <Step>Execute using standard algorithm</Step>
        )}
      </Phase>

      {features.enableCaching && (
        <Phase name="cache-store">
          <Step>Store result in cache</Step>
        </Phase>
      )}

      Task: {task}
    </Claude>
  )
}
```

## Running Conditional Agents

```bash
# Normal run - all phases as needed
smithers run conditional-task.tsx \
  --props '{"task": "Implement user authentication"}'

# Skip analysis for known simple tasks
smithers run conditional-task.tsx \
  --props '{"task": "Fix typo in README", "skipAnalysis": true}'

# Force review regardless of complexity
smithers run conditional-task.tsx \
  --props '{"task": "Update API endpoints", "forceReview": true}'

# Different modes
smithers run conditional-task.tsx \
  --entry MultipathAgent \
  --props '{"input": "Explain quantum computing", "mode": "thorough"}'
```

## Execution Flow Examples

```
Example 1: Simple Task (skipAnalysis=true)
  Phase: analyze -> (skipped)
  Phase: plan -> (skipped - simple)
  Phase: execute -> complete

Example 2: Complex Task with Security Concerns
  Phase: analyze -> {complexity: "complex", hasSecurityConcerns: true}
  Phase: plan -> (creates detailed plan)
  Phase: execute -> (follows plan)
  Phase: review -> (triggered by security concerns)
  Phase: complete

Example 3: Moderate Task, Low Risk
  Phase: analyze -> {complexity: "moderate", riskLevel: "low"}
  Phase: plan -> (creates plan)
  Phase: execute -> (executes)
  Phase: review -> (skipped - low risk)
  Phase: complete
```

## Key Patterns Demonstrated

<CardGroup cols={2}>
  <Card title="State-Driven Flow" icon="diagram-project">
    Phase transitions based on analysis results
  </Card>
  <Card title="Skip Conditions" icon="forward">
    Skip phases when not needed (simple tasks)
  </Card>
  <Card title="Feature Flags" icon="toggle-on">
    Enable/disable phases via configuration
  </Card>
  <Card title="Mode Selection" icon="sliders">
    Different execution paths based on mode
  </Card>
</CardGroup>

## Advanced: Dynamic Phase Generation

```tsx
function DynamicPhasesAgent({ requirements }: { requirements: string[] }) {
  return (
    <Claude>
      {requirements.map((req, i) => (
        <Phase key={i} name={`requirement-${i + 1}`}>
          <Step>Implement: {req}</Step>
          <Step>Verify implementation</Step>
          <Step>Document changes</Step>
        </Phase>
      ))}

      <Phase name="integration">
        <Step>Integrate all requirements</Step>
        <Step>Run integration tests</Step>
      </Phase>
    </Claude>
  )
}

// Usage
<DynamicPhasesAgent
  requirements={[
    'Add user registration',
    'Implement login flow',
    'Add password reset',
    'Enable 2FA',
  ]}
/>
```

## Related Examples

<CardGroup cols={2}>
  <Card title="Multi-Agent Team" icon="users" href="/examples/multi-agent">
    Complex phase coordination
  </Card>
  <Card title="Data Pipeline" icon="database" href="/examples/data-pipeline">
    Sequential phase execution
  </Card>
</CardGroup>
