---
title: Streaming Progress
description: Shows streaming responses with real-time progress updates
---

# Streaming Progress

This example demonstrates how to use streaming mode to provide real-time progress updates during long-running agent operations.

## Complete Example

```tsx
import { create } from 'zustand'
import { Claude, Phase, Step, Persona, Constraints, OutputFormat } from 'smithers'

// Type definitions for streaming state
interface ProgressState {
  stage: 'idle' | 'analyzing' | 'processing' | 'complete'
  currentChunk: string
  fullResponse: string
  tokensGenerated: number
  startTime: number | null
  endTime: number | null
}

interface StreamChunk {
  type: 'text' | 'tool_use' | 'message_delta' | 'content_block_delta'
  text?: string
  delta?: { text?: string; stop_reason?: string }
}

// State management for streaming progress
const useProgressStore = create<
  ProgressState & {
    startStreaming: () => void
    appendChunk: (chunk: StreamChunk) => void
    complete: () => void
    reset: () => void
  }
>((set, get) => ({
  stage: 'idle',
  currentChunk: '',
  fullResponse: '',
  tokensGenerated: 0,
  startTime: null,
  endTime: null,

  startStreaming: () =>
    set({
      stage: 'analyzing',
      currentChunk: '',
      fullResponse: '',
      tokensGenerated: 0,
      startTime: Date.now(),
      endTime: null,
    }),

  appendChunk: (chunk) => {
    const text = chunk.text || chunk.delta?.text || ''
    if (text) {
      set((state) => ({
        currentChunk: text,
        fullResponse: state.fullResponse + text,
        tokensGenerated: state.tokensGenerated + 1,
        stage: 'processing',
      }))
    }
  },

  complete: () =>
    set({
      stage: 'complete',
      endTime: Date.now(),
    }),

  reset: () =>
    set({
      stage: 'idle',
      currentChunk: '',
      fullResponse: '',
      tokensGenerated: 0,
      startTime: null,
      endTime: null,
    }),
}))

// Progress display component (for UI integration)
function ProgressIndicator() {
  const { stage, tokensGenerated, startTime, fullResponse } = useProgressStore()

  const elapsed = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0
  const tokensPerSecond = elapsed > 0 ? Math.round(tokensGenerated / elapsed) : 0

  return (
    <div className="progress-indicator">
      <span>Stage: {stage}</span>
      <span>Tokens: {tokensGenerated}</span>
      <span>Speed: {tokensPerSecond} tokens/sec</span>
      <span>Elapsed: {elapsed}s</span>
      {fullResponse && (
        <div className="preview">
          {fullResponse.slice(-200)}...
        </div>
      )}
    </div>
  )
}

// Analyst persona for document analysis
function Analyst() {
  return (
    <Persona role="Document Analyst">
      You are a meticulous document analyst who provides detailed,
      structured analysis. You think through problems step-by-step
      and explain your reasoning as you work.
    </Persona>
  )
}

// Main streaming agent component
export function StreamingAnalyzer({
  document,
  analysisType = 'comprehensive',
}: {
  document: string
  analysisType?: 'quick' | 'comprehensive' | 'deep'
}) {
  const { stage, startStreaming, appendChunk, complete, fullResponse } =
    useProgressStore()

  // Handle streaming start
  const handleStreamStart = () => {
    startStreaming()
  }

  // Handle each streaming chunk
  const handleStream = (chunk: StreamChunk) => {
    appendChunk(chunk)

    // You can also log progress in real-time
    if (chunk.text) {
      console.log(`[STREAM] ${chunk.text}`)
    }
  }

  // Handle completion
  const handleFinished = (result: unknown) => {
    complete()
    console.log('Analysis complete:', result)
  }

  if (stage === 'idle' || stage === 'analyzing' || stage === 'processing') {
    return (
      <Claude
        stream={true}
        onStream={handleStream}
        onFinished={handleFinished}
      >
        <Analyst />

        <Constraints>
          - Provide detailed explanations as you analyze
          - Break down complex sections step-by-step
          - Think out loud to show your reasoning process
          - Identify key themes and patterns
          {analysisType === 'deep' && (
            '- Provide extensive cross-references and citations'
          )}
        </Constraints>

        <Phase name="analysis">
          <Step>Read and understand the document structure</Step>
          <Step>Identify key themes and arguments</Step>
          <Step>Analyze supporting evidence</Step>
          <Step>Evaluate logical consistency</Step>
          {analysisType !== 'quick' && (
            <>
              <Step>Identify potential weaknesses or gaps</Step>
              <Step>Consider alternative interpretations</Step>
            </>
          )}
        </Phase>

        <Phase name="document">
          Analyze the following document ({analysisType} analysis):

          {document}
        </Phase>

        <OutputFormat
          schema={{
            summary: 'string - Brief overview',
            themes: ['string - Key themes identified'],
            arguments: [
              {
                claim: 'string',
                evidence: 'string',
                strength: 'weak | moderate | strong',
              },
            ],
            gaps: ['string - Identified gaps or weaknesses'],
            overallAssessment: 'string - Final assessment',
          }}
        >
          Return valid JSON with your complete analysis.
        </OutputFormat>
      </Claude>
    )
  }

  // Complete - return the result
  return null
}

// Example with custom progress callback
export function StreamingWithCallback({
  task,
  onProgress,
}: {
  task: string
  onProgress?: (progress: { text: string; percent: number }) => void
}) {
  let totalExpectedSteps = 5
  let currentStep = 0

  const handleStream = (chunk: StreamChunk) => {
    const text = chunk.text || chunk.delta?.text || ''

    // Detect step markers in the response
    if (text.includes('Step')) {
      currentStep++
    }

    onProgress?.({
      text,
      percent: Math.min((currentStep / totalExpectedSteps) * 100, 100),
    })
  }

  return (
    <Claude stream={true} onStream={handleStream}>
      <Phase name="task">
        Complete this task step by step. Mark each step with "Step N:".

        Task: {task}

        <Step>Analyze the requirements</Step>
        <Step>Plan the approach</Step>
        <Step>Execute the solution</Step>
        <Step>Verify the results</Step>
        <Step>Summarize findings</Step>
      </Phase>
    </Claude>
  )
}
```

## Running with Streaming

```bash
# Run with streaming output visible in terminal
smithers run streaming-analyzer.tsx \
  --props '{"document": "Long document text...", "analysisType": "comprehensive"}' \
  --stream

# With verbose logging to see all chunks
smithers run streaming-analyzer.tsx \
  --props '{"document": "..."}' \
  --stream \
  --verbose
```

## UI Integration Example

```tsx
import { StreamingAnalyzer } from './streaming-analyzer'
import { useProgressStore } from './streaming-analyzer'

function AnalyzerUI({ document }) {
  const { stage, tokensGenerated, fullResponse } = useProgressStore()

  return (
    <div>
      <header>
        <h1>Document Analyzer</h1>
        <StatusBadge status={stage} />
        <TokenCounter count={tokensGenerated} />
      </header>

      <main>
        {stage === 'processing' && (
          <StreamingOutput content={fullResponse} />
        )}

        {stage === 'complete' && (
          <AnalysisResults content={fullResponse} />
        )}
      </main>

      {/* The agent runs in the background */}
      <StreamingAnalyzer document={document} analysisType="comprehensive" />
    </div>
  )
}
```

## Key Patterns Demonstrated

<CardGroup cols={2}>
  <Card title="Real-time Streaming" icon="signal-stream">
    Use `stream={true}` and `onStream` callback for live updates
  </Card>
  <Card title="Progress Tracking" icon="chart-line">
    Track tokens, elapsed time, and completion status
  </Card>
  <Card title="UI Integration" icon="display">
    Connect streaming state to React UI components
  </Card>
  <Card title="Chunked Processing" icon="layer-group">
    Process and display response as it arrives
  </Card>
</CardGroup>

## Advanced: Streaming with Tool Calls

```tsx
function StreamingWithTools({ query }: { query: string }) {
  const [toolCalls, setToolCalls] = useState<any[]>([])

  const handleStream = (chunk: StreamChunk) => {
    // Handle tool use chunks
    if (chunk.type === 'tool_use' && chunk.tool_use) {
      setToolCalls((prev) => [...prev, chunk.tool_use])
      console.log(`Tool called: ${chunk.tool_use.name}`)
    }

    // Handle text chunks
    if (chunk.text) {
      console.log(`Text: ${chunk.text}`)
    }
  }

  return (
    <Claude
      stream={true}
      onStream={handleStream}
      tools={[searchTool, calculatorTool]}
    >
      <Phase name="research">
        Answer this query, using tools as needed: {query}
      </Phase>
    </Claude>
  )
}
```

## Related Examples

<CardGroup cols={2}>
  <Card title="Error Handling" icon="triangle-exclamation" href="/examples/07-error-handling">
    Handling errors during streaming
  </Card>
  <Card title="Data Pipeline" icon="database" href="/examples/data-pipeline">
    Progress tracking in ETL pipelines
  </Card>
</CardGroup>
