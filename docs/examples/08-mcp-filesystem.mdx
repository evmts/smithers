---
title: MCP Filesystem Operations
description: Using MCP filesystem server for file operations
---

# MCP Filesystem Operations

This example demonstrates how to use the MCP (Model Context Protocol) filesystem server to perform file operations like reading, writing, searching, and managing files.

## Complete Example

```tsx
import { create } from 'zustand'
import {
  Claude,
  Phase,
  Step,
  Persona,
  Constraints,
  OutputFormat,
  Subagent,
} from '@evmts/smithers'
import { MCPPresets } from 'smithers/mcp'

// Type definitions
interface FileInfo {
  path: string
  size: number
  modified: string
  type: 'file' | 'directory'
}

interface FileOperation {
  operation: 'read' | 'write' | 'delete' | 'move' | 'search'
  path: string
  status: 'pending' | 'complete' | 'error'
  result?: unknown
  error?: string
}

interface FileManagerState {
  phase: 'scanning' | 'analyzing' | 'operating' | 'complete'
  files: FileInfo[]
  operations: FileOperation[]
  summary: string | null
}

// State management
const useFileStore = create<
  FileManagerState & {
    setFiles: (files: FileInfo[]) => void
    addOperation: (op: FileOperation) => void
    updateOperation: (path: string, update: Partial<FileOperation>) => void
    complete: (summary: string) => void
  }
>((set, get) => ({
  phase: 'scanning',
  files: [],
  operations: [],
  summary: null,

  setFiles: (files) => set({ files, phase: 'analyzing' }),

  addOperation: (op) =>
    set((state) => ({ operations: [...state.operations, op] })),

  updateOperation: (path, update) =>
    set((state) => ({
      operations: state.operations.map((op) =>
        op.path === path ? { ...op, ...update } : op
      ),
      phase: state.operations.every((op) =>
        op.path === path
          ? update.status === 'complete' || update.status === 'error'
          : op.status === 'complete' || op.status === 'error'
      )
        ? 'complete'
        : 'operating',
    })),

  complete: (summary) => set({ summary, phase: 'complete' }),
}))

// File manager persona
function FileManager() {
  return (
    <Persona role="File System Manager">
      You are an expert file system manager. You safely handle file operations,
      always checking before destructive operations, and providing clear
      feedback about what changes were made.
    </Persona>
  )
}

// Main file management agent
export function FileManagerAgent({
  rootPath,
  task,
}: {
  rootPath: string
  task: string
}) {
  const {
    phase,
    files,
    operations,
    setFiles,
    addOperation,
    updateOperation,
    complete,
  } = useFileStore()

  // Configure MCP filesystem server with allowed paths
  const mcpConfig = MCPPresets.filesystem([rootPath])

  // Phase 1: Scan the directory
  if (phase === 'scanning') {
    return (
      <Claude
        mcpServers={[mcpConfig]}
        onFinished={(result: { files: FileInfo[] }) => setFiles(result.files)}
      >
        <FileManager />

        <Constraints>
          - Only operate within the allowed path: {rootPath}
          - List all files and directories recursively
          - Include file sizes and modification times
          - Skip hidden files unless explicitly requested
        </Constraints>

        <Phase name="scan">
          <Step>Connect to the filesystem server</Step>
          <Step>List all files in: {rootPath}</Step>
          <Step>Gather metadata for each file</Step>
        </Phase>

        <OutputFormat
          schema={{
            files: [
              {
                path: 'string',
                size: 'number (bytes)',
                modified: 'ISO date string',
                type: 'file | directory',
              },
            ],
            totalFiles: 'number',
            totalSize: 'number (bytes)',
          }}
        >
          Return JSON with file listing.
        </OutputFormat>
      </Claude>
    )
  }

  // Phase 2: Analyze and plan operations
  if (phase === 'analyzing') {
    return (
      <Claude
        mcpServers={[mcpConfig]}
        onFinished={(result: { operations: FileOperation[] }) => {
          result.operations.forEach(addOperation)
          // Move to operating phase if there are operations
          if (result.operations.length > 0) {
            useFileStore.setState({ phase: 'operating' })
          } else {
            complete('No operations needed')
          }
        }}
      >
        <FileManager />

        <Constraints>
          - Analyze the task and determine required file operations
          - Be conservative - confirm before destructive operations
          - Batch similar operations together for efficiency
          - Respect file permissions and access rights
        </Constraints>

        <Phase name="analyze">
          Task to complete: {task}

          Available files:
          {files.map((f) => `${f.type}: ${f.path} (${f.size} bytes)`).join('\n')}

          <Step>Understand the requested task</Step>
          <Step>Identify files that need to be modified</Step>
          <Step>Plan the sequence of operations</Step>
          <Step>Check for potential conflicts or issues</Step>
        </Phase>

        <OutputFormat
          schema={{
            operations: [
              {
                operation: 'read | write | delete | move | search',
                path: 'string',
                status: 'pending',
                details: 'string - what will be done',
              },
            ],
            warnings: ['string - potential issues'],
            confirmation: 'string - summary of planned changes',
          }}
        >
          Return JSON with planned operations.
        </OutputFormat>
      </Claude>
    )
  }

  // Phase 3: Execute operations
  if (phase === 'operating') {
    const pendingOps = operations.filter((op) => op.status === 'pending')

    if (pendingOps.length === 0) {
      // All operations complete
      return (
        <Claude
          onFinished={(result: { summary: string }) => complete(result.summary)}
        >
          <FileManager />

          <Phase name="summarize">
            Completed operations:
            {operations.map((op) =>
              `${op.operation} ${op.path}: ${op.status}${
                op.error ? ` (${op.error})` : ''
              }`
            ).join('\n')}

            <Step>Summarize what was done</Step>
            <Step>Report any errors or issues</Step>
          </Phase>

          <OutputFormat schema={{ summary: 'string' }}>
            Return a summary of all operations performed.
          </OutputFormat>
        </Claude>
      )
    }

    // Execute pending operations in parallel (where safe)
    return (
      <>
        {pendingOps.map((op) => (
          <Subagent key={op.path} name={`op-${op.path}`}>
            <Claude
              mcpServers={[mcpConfig]}
              onFinished={(result: unknown) =>
                updateOperation(op.path, { status: 'complete', result })
              }
              onError={(error) =>
                updateOperation(op.path, { status: 'error', error: error.message })
              }
            >
              <FileManager />

              <Constraints>
                - Execute this single operation safely
                - Verify the operation completed successfully
                - Report any errors immediately
              </Constraints>

              <Phase name="execute">
                Execute {op.operation} on: {op.path}

                <Step>Perform the {op.operation} operation</Step>
                <Step>Verify success</Step>
              </Phase>

              <OutputFormat
                schema={{
                  success: 'boolean',
                  result: 'any - operation result',
                  details: 'string',
                }}
              >
                Return operation result.
              </OutputFormat>
            </Claude>
          </Subagent>
        ))}
      </>
    )
  }

  return null
}

// Specialized agent for code refactoring
export function CodeRefactorAgent({
  directory,
  pattern,
  replacement,
}: {
  directory: string
  pattern: string
  replacement: string
}) {
  const mcpConfig = MCPPresets.filesystem([directory])

  return (
    <Claude mcpServers={[mcpConfig]}>
      <Persona role="Code Refactoring Specialist">
        You are an expert at safely refactoring code across multiple files.
        You understand code syntax and ensure refactoring preserves behavior.
      </Persona>

      <Constraints>
        - Only modify files within: {directory}
        - Create backups before modifying files
        - Preserve file formatting and indentation
        - Skip binary files
        - Report all changes made
      </Constraints>

      <Phase name="search">
        <Step>Search for files containing: {pattern}</Step>
        <Step>Identify all occurrences</Step>
        <Step>Determine safe replacement strategy</Step>
      </Phase>

      <Phase name="refactor">
        <Step>Create backups of affected files</Step>
        <Step>Replace "{pattern}" with "{replacement}"</Step>
        <Step>Verify replacements are syntactically correct</Step>
      </Phase>

      <Phase name="report">
        <Step>List all files modified</Step>
        <Step>Show number of replacements per file</Step>
        <Step>Note any files that were skipped</Step>
      </Phase>

      <OutputFormat
        schema={{
          filesModified: ['string'],
          totalReplacements: 'number',
          skippedFiles: ['string'],
          backupLocation: 'string',
        }}
      >
        Return JSON with refactoring results.
      </OutputFormat>
    </Claude>
  )
}

// File organization agent
export function FileOrganizerAgent({
  sourceDir,
  rules,
}: {
  sourceDir: string
  rules: Array<{ pattern: string; destination: string }>
}) {
  const mcpConfig = MCPPresets.filesystem([sourceDir])

  return (
    <Claude mcpServers={[mcpConfig]}>
      <FileManager />

      <Constraints>
        - Only operate within: {sourceDir}
        - Preserve original files (copy, don't move) unless specified
        - Create destination directories if they don't exist
        - Handle name conflicts by appending numbers
      </Constraints>

      <Phase name="organize">
        Organize files according to these rules:

        {rules.map((rule, i) => (
          <Step key={i}>
            Move files matching "{rule.pattern}" to "{rule.destination}"
          </Step>
        ))}

        <Step>Report final organization</Step>
      </Phase>

      <OutputFormat
        schema={{
          moved: [{ from: 'string', to: 'string' }],
          created: ['string - new directories'],
          conflicts: ['string - files with naming conflicts'],
          unchanged: 'number - files that matched no rules',
        }}
      >
        Return JSON with organization results.
      </OutputFormat>
    </Claude>
  )
}
```

## Running with MCP Filesystem

```bash
# Basic file management
smithers run file-manager.tsx \
  --props '{
    "rootPath": "/home/user/project",
    "task": "Find all TODO comments and list them"
  }'

# Code refactoring
smithers run file-manager.tsx \
  --entry CodeRefactorAgent \
  --props '{
    "directory": "/home/user/project/src",
    "pattern": "oldFunction",
    "replacement": "newFunction"
  }'

# File organization
smithers run file-manager.tsx \
  --entry FileOrganizerAgent \
  --props '{
    "sourceDir": "/home/user/downloads",
    "rules": [
      {"pattern": "*.pdf", "destination": "documents/"},
      {"pattern": "*.jpg", "destination": "images/"},
      {"pattern": "*.mp3", "destination": "music/"}
    ]
  }'
```

## MCP Configuration Options

```tsx
import { MCPPresets, createMCPConfigs } from 'smithers/mcp'

// Single directory access
const singleDir = MCPPresets.filesystem(['/home/user/project'])

// Multiple directories
const multiDir = MCPPresets.filesystem([
  '/home/user/project',
  '/home/user/data',
  '/tmp',
])

// Combine with other MCP servers
const configs = createMCPConfigs([
  MCPPresets.filesystem(['/home/user/project']),
  MCPPresets.git('/home/user/project'),
  MCPPresets.memory(),
])

// Use in Claude component
<Claude mcpServers={configs}>
  {/* Agent can now access files, git, and memory */}
</Claude>
```

## Key Patterns Demonstrated

<CardGroup cols={2}>
  <Card title="MCP Integration" icon="plug">
    Connect to MCP filesystem server for file operations
  </Card>
  <Card title="Safe File Operations" icon="shield-check">
    Sandboxed access to specific directories only
  </Card>
  <Card title="Batch Processing" icon="layer-group">
    Execute multiple file operations in parallel
  </Card>
  <Card title="Path Restrictions" icon="lock">
    Limit agent access to allowed paths only
  </Card>
</CardGroup>

## Security Best Practices

```tsx
// Always specify allowed paths explicitly
const safeConfig = MCPPresets.filesystem([
  '/home/user/project', // Only this project
])

// Never do this in production:
// const unsafeConfig = MCPPresets.filesystem(['/']) // Full system access!

// Use separate configs for different operations
function SecureFileAgent({ readPath, writePath }) {
  const readConfig = MCPPresets.filesystem([readPath])
  const writeConfig = MCPPresets.filesystem([writePath])

  return (
    <Claude mcpServers={[readConfig]}>
      <Phase name="read-only-operations">
        {/* Can only read from readPath */}
      </Phase>
    </Claude>
  )
}
```

## Related Examples

<CardGroup cols={2}>
  <Card title="Tool Composition" icon="puzzle-piece" href="/examples/10-tool-composition">
    Combining multiple MCP servers
  </Card>
  <Card title="Code Review" icon="magnifying-glass" href="/examples/code-review">
    File analysis patterns
  </Card>
</CardGroup>
