---
title: "Rate Limited Batch"
description: "Large-scale batch processing with rate limiting and cost control"
---

# Rate Limited Batch

Large-scale batch processing with automatic rate limiting, usage tracking, and cost enforcement.

## What This Example Shows

- Processing many items with `<ClaudeProvider>`
- Enforcing rate limits (requests/tokens per minute)
- Tracking usage and costs in real-time
- Budget enforcement with automatic pausing
- Progress reporting for long-running jobs

## The Code

```tsx
import { executePlan, ClaudeProvider, Claude } from 'smithers'
import { create } from 'zustand'

interface BatchItem {
  id: string
  content: string
}

interface BatchState {
  items: BatchItem[]
  results: Record<string, string>
  totalCost: number
  addResult: (id: string, result: string, cost: number) => void
}

const useStore = create<BatchState>((set) => ({
  items: [],
  results: {},
  totalCost: 0,
  addResult: (id, result, cost) =>
    set((state) => ({
      results: { ...state.results, [id]: result },
      totalCost: state.totalCost + cost
    }))
}))

function BatchProcessor({
  items,
  requestsPerMinute = 50,
  budgetDollars = 1.0
}: {
  items: BatchItem[]
  requestsPerMinute?: number
  budgetDollars?: number
}) {
  const { addResult } = useStore()

  return (
    <ClaudeProvider
      rateLimit={{
        requestsPerMinute,
        inputTokensPerMinute: 40000,
        outputTokensPerMinute: 4000
      }}
      usageLimit={{
        maxTotalCost: budgetDollars
      }}
      onRateLimited={(reason, waitMs) => {
        console.log(`‚è∏Ô∏è  Rate limited (${reason}), waiting ${waitMs}ms`)
      }}
      onUsageUpdate={(stats) => {
        console.log(
          `üìä Progress: ${stats.requestCount}/${items.length} ` +
          `($${stats.totalCost.toFixed(4)})`
        )
      }}
    >
      {items.map((item) => (
        <Claude
          key={item.id}
          allowedTools={['Read']}
          onFinished={(result) => {
            const cost = (result.usage?.inputTokens || 0) * 0.000003 +
                        (result.usage?.outputTokens || 0) * 0.000015
            addResult(item.id, result.text, cost)
            console.log(`‚úì Processed: ${item.id}`)
          }}
        >
          Analyze this content and provide a summary:

          {item.content}

          Return a JSON object with:
          - sentiment: "positive" | "negative" | "neutral"
          - category: the primary topic category
          - summary: 1-2 sentence summary
        </Claude>
      ))}
    </ClaudeProvider>
  )
}

// CLI execution
const inputFile = process.argv[2] || './data/items.json'
const rateLimit = parseInt(process.argv[3] || '50')
const budget = parseFloat(process.argv[4] || '1.0')

console.log('üöÄ Batch Processor Starting')
console.log(`  Input: ${inputFile}`)
console.log(`  Rate limit: ${rateLimit} req/min`)
console.log(`  Budget: $${budget}`)

// Load items from file
const { readFileSync } = await import('fs')
const items: BatchItem[] = JSON.parse(readFileSync(inputFile, 'utf-8'))

const startTime = Date.now()

await executePlan(
  <BatchProcessor
    items={items}
    requestsPerMinute={rateLimit}
    budgetDollars={budget}
  />
)

const elapsed = ((Date.now() - startTime) / 1000).toFixed(1)
const state = useStore.getState()

console.log('‚úÖ Batch Processing Complete')
console.log(`  Processed: ${Object.keys(state.results).length}/${items.length}`)
console.log(`  Total cost: $${state.totalCost.toFixed(4)}`)
console.log(`  Duration: ${elapsed}s`)
console.log(`  Throughput: ${(items.length / parseFloat(elapsed)).toFixed(1)} items/sec`)
```

## Running

### Basic Batch Processing

```bash
# Process 100 items with default settings
bun run examples/11-rate-limited-batch/agent.tsx data/items.json
```

### Custom Rate Limit

```bash
# Process at 30 requests per minute
bun run examples/11-rate-limited-batch/agent.tsx data/items.json 30
```

### With Budget Limit

```bash
# Process with $0.50 budget limit
bun run examples/11-rate-limited-batch/agent.tsx data/items.json 50 0.50
```

## Example Output

```
üöÄ Batch Processor Starting
  Input: ./data/items.json
  Rate limit: 50 req/min
  Budget: $1.00

üìä Progress: 10/100 ($0.0045)
üìä Progress: 20/100 ($0.0089)
‚è∏Ô∏è  Rate limited (rpm), waiting 1234ms
üìä Progress: 30/100 ($0.0134)
‚úì Processed: item-001
‚úì Processed: item-002
...
üìä Progress: 100/100 ($0.0445)

‚úÖ Batch Processing Complete
  Processed: 100/100
  Total cost: $0.0445
  Duration: 125.3s
  Throughput: 0.8 items/sec
```

## Key Concepts

### ClaudeProvider Component

The `<ClaudeProvider>` component wraps multiple `<Claude>` agents and enforces shared limits:

```tsx
<ClaudeProvider
  rateLimit={{
    requestsPerMinute: 50,
    inputTokensPerMinute: 40000,
    outputTokensPerMinute: 4000
  }}
  usageLimit={{
    maxTotalCost: 1.0,
    window: 'session'
  }}
>
  {items.map(item => <Claude key={item.id}>...</Claude>)}
</ClaudeProvider>
```

All child agents share the same rate limits and budget.

### Rate Limiting

Three types of rate limits:

1. **Requests per minute** - Max number of API calls
2. **Input tokens per minute** - Max input token consumption
3. **Output tokens per minute** - Max output token generation

When any limit is reached, execution automatically pauses until the window resets.

### Usage Tracking

Track API usage in real-time:

```tsx
<ClaudeProvider
  onUsageUpdate={(stats) => {
    console.log(`Requests: ${stats.requestCount}`)
    console.log(`Input tokens: ${stats.inputTokens}`)
    console.log(`Output tokens: ${stats.outputTokens}`)
    console.log(`Total cost: $${stats.totalCost}`)
  }}
>
```

### Budget Enforcement

Automatically stop when budget is reached:

```tsx
<ClaudeProvider
  usageLimit={{
    maxTotalCost: 1.0,  // $1.00 maximum
    window: 'session'    // Track per execution
  }}
>
```

When the budget is exceeded, remaining agents are skipped.

## Use Cases

### 1. Content Moderation

Process thousands of user submissions:

```tsx
<ClaudeProvider rateLimit={{ requestsPerMinute: 100 }}>
  {submissions.map(sub => (
    <Claude key={sub.id}>
      Moderate this content for policy violations:
      {sub.content}
    </Claude>
  ))}
</ClaudeProvider>
```

### 2. Data Classification

Categorize large datasets:

```tsx
<ClaudeProvider
  rateLimit={{ requestsPerMinute: 50 }}
  usageLimit={{ maxTotalCost: 5.0 }}
>
  {records.map(record => (
    <Claude key={record.id}>
      Classify this record into: [categories]
      Data: {record.data}
    </Claude>
  ))}
</ClaudeProvider>
```

### 3. Translation Pipeline

Translate content in batches:

```tsx
<ClaudeProvider rateLimit={{ requestsPerMinute: 30 }}>
  {texts.map(text => (
    <Claude key={text.id}>
      Translate to {targetLanguage}: {text.content}
    </Claude>
  ))}
</ClaudeProvider>
```

### 4. Quality Assurance

Review generated content:

```tsx
<ClaudeProvider usageLimit={{ maxTotalCost: 2.0 }}>
  {outputs.map(output => (
    <Claude key={output.id}>
      Review this generated content for quality:
      - Accuracy
      - Completeness
      - Clarity

      Content: {output.text}
    </Claude>
  ))}
</ClaudeProvider>
```

## Cost Estimation

Claude API pricing (as of 2025):

| Model | Input | Output |
|-------|-------|--------|
| Sonnet 4.5 | $3/M tokens | $15/M tokens |
| Haiku 4 | $0.80/M tokens | $4/M tokens |

Example calculations:

```
100 items √ó 500 input tokens √ó $0.000003/token = $0.15
100 items √ó 200 output tokens √ó $0.000015/token = $0.30
Total: ~$0.45 for 100 items
```

## Extending This Example

### Add Retry Logic

Retry failed items:

```tsx
<Claude
  onError={(error) => {
    console.error(`Failed: ${item.id}`)
    failedItems.push(item)
  }}
>
  Process item
</Claude>

// After main batch:
{failedItems.map(item => (
  <Claude key={`retry-${item.id}`}>
    Retry: {item.id}
  </Claude>
))}
```

### Add Progress Bar

Show visual progress:

```tsx
import { createProgressBar } from './utils'

const progressBar = createProgressBar(items.length)

<ClaudeProvider
  onUsageUpdate={(stats) => {
    progressBar.update(stats.requestCount)
  }}
>
```

### Add Result Validation

Validate and retry invalid results:

```tsx
<Claude
  onFinished={(result) => {
    try {
      const parsed = JSON.parse(result.text)
      if (!parsed.sentiment || !parsed.category) {
        throw new Error('Invalid format')
      }
      addResult(item.id, parsed)
    } catch (error) {
      console.error(`Invalid result for ${item.id}:`, error)
      invalidItems.push(item)
    }
  }}
>
```

### Add Batching Strategy

Process in smaller batches:

```tsx
const batchSize = 25
for (let i = 0; i < items.length; i += batchSize) {
  const batch = items.slice(i, i + batchSize)

  await executePlan(
    <ClaudeProvider>
      {batch.map(item => <Claude key={item.id}>...</Claude>)}
    </ClaudeProvider>
  )

  console.log(`Completed batch ${i / batchSize + 1}`)
}
```

## Performance Tips

### 1. Optimize Prompts

Shorter prompts = lower costs:

```tsx
// Expensive (500 tokens)
<Claude>
  Long, detailed instructions with examples...
</Claude>

// Cheaper (100 tokens)
<Claude>
  Summarize: {content}
</Claude>
```

### 2. Use Appropriate Models

Choose model based on task complexity:

```tsx
// Simple classification - use Haiku
<ClaudeProvider defaults={{ model: 'claude-haiku-4-20250112' }}>
  {items.map(item => <Claude>Classify: {item}</Claude>)}
</ClaudeProvider>

// Complex analysis - use Sonnet
<ClaudeProvider defaults={{ model: 'claude-sonnet-4-5-20250929' }}>
  {items.map(item => <Claude>Analyze deeply: {item}</Claude>)}
</ClaudeProvider>
```

### 3. Parallelize When Possible

Use `parallel={true}` for independent items:

```tsx
<Subagent parallel={true}>
  <ClaudeProvider rateLimit={{ requestsPerMinute: 50 }}>
    {items.map(item => <Claude key={item.id}>...</Claude>)}
  </ClaudeProvider>
</Subagent>
```

### 4. Monitor and Adjust

Track metrics and adjust rates:

```tsx
<ClaudeProvider
  onRateLimited={(reason, waitMs) => {
    console.log(`Rate limited: ${reason}`)
    // Adjust rate limit dynamically if needed
  }}
>
```

## Related Examples

- [06-file-processor](/examples/06-file-processor) - File transformation pipeline
- [10-mcp-integration](/examples/10-mcp-integration) - External tool integration
- [04-parallel-research](/examples/04-parallel-research) - Parallel execution patterns

## Learn More

- [ClaudeProvider Component](/components/claude-provider)
- [Rate Limiting Guide](/guides/rate-limiting)
- [Cost Optimization Tips](/guides/cost-optimization)
