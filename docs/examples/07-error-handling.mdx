---
title: Error Handling
description: Demonstrates comprehensive error handling patterns for robust agents
---

# Error Handling

This example demonstrates robust error handling patterns including retries, fallbacks, graceful degradation, and error recovery strategies.

## Complete Example

```tsx
import { create } from 'zustand'
import { Claude, Phase, Step, Persona, Constraints, OutputFormat } from 'smithers'

// Error types for classification
type ErrorType = 'network' | 'rate_limit' | 'validation' | 'tool_failure' | 'timeout' | 'unknown'

interface AgentError {
  type: ErrorType
  message: string
  retryable: boolean
  context?: Record<string, unknown>
  timestamp: number
}

interface ErrorState {
  errors: AgentError[]
  retryCount: number
  maxRetries: number
  lastError: AgentError | null
  status: 'idle' | 'running' | 'retrying' | 'failed' | 'recovered' | 'complete'
}

// Classify errors to determine handling strategy
function classifyError(error: Error): AgentError {
  const message = error.message.toLowerCase()

  if (message.includes('network') || message.includes('fetch')) {
    return {
      type: 'network',
      message: error.message,
      retryable: true,
      timestamp: Date.now(),
    }
  }

  if (message.includes('rate limit') || message.includes('429')) {
    return {
      type: 'rate_limit',
      message: error.message,
      retryable: true,
      context: { waitTime: 60000 }, // Wait 60 seconds
      timestamp: Date.now(),
    }
  }

  if (message.includes('timeout')) {
    return {
      type: 'timeout',
      message: error.message,
      retryable: true,
      timestamp: Date.now(),
    }
  }

  if (message.includes('validation') || message.includes('invalid')) {
    return {
      type: 'validation',
      message: error.message,
      retryable: false, // Validation errors need human intervention
      timestamp: Date.now(),
    }
  }

  if (message.includes('tool') || message.includes('function')) {
    return {
      type: 'tool_failure',
      message: error.message,
      retryable: true,
      timestamp: Date.now(),
    }
  }

  return {
    type: 'unknown',
    message: error.message,
    retryable: false,
    timestamp: Date.now(),
  }
}

// State management with error tracking
const useErrorStore = create<
  ErrorState & {
    addError: (error: AgentError) => void
    retry: () => boolean
    recover: () => void
    complete: () => void
    reset: () => void
  }
>((set, get) => ({
  errors: [],
  retryCount: 0,
  maxRetries: 3,
  lastError: null,
  status: 'idle',

  addError: (error) => {
    set((state) => ({
      errors: [...state.errors, error],
      lastError: error,
      status: error.retryable && state.retryCount < state.maxRetries
        ? 'retrying'
        : 'failed',
    }))
  },

  retry: () => {
    const { retryCount, maxRetries } = get()
    if (retryCount < maxRetries) {
      set((state) => ({
        retryCount: state.retryCount + 1,
        status: 'running',
      }))
      return true
    }
    return false
  },

  recover: () => set({ status: 'recovered', lastError: null }),

  complete: () => set({ status: 'complete' }),

  reset: () =>
    set({
      errors: [],
      retryCount: 0,
      lastError: null,
      status: 'idle',
    }),
}))

// Resilient researcher persona
function ResilientResearcher() {
  return (
    <Persona role="Resilient Research Agent">
      You are a thorough researcher who handles failures gracefully.
      When tools fail, you adapt your approach and try alternatives.
      You always provide the best possible answer given the circumstances.
    </Persona>
  )
}

// Main error-handling agent
export function ResilientAgent({
  task,
  fallbackMode = false,
}: {
  task: string
  fallbackMode?: boolean
}) {
  const {
    status,
    lastError,
    retryCount,
    maxRetries,
    addError,
    retry,
    recover,
    complete,
  } = useErrorStore()

  // Error handler with classification and retry logic
  const handleError = (error: Error) => {
    const classifiedError = classifyError(error)
    console.error(`[Error] ${classifiedError.type}: ${classifiedError.message}`)

    addError(classifiedError)

    // Automatic retry for retryable errors
    if (classifiedError.retryable && retryCount < maxRetries) {
      const delay = classifiedError.type === 'rate_limit'
        ? (classifiedError.context?.waitTime as number) || 60000
        : Math.pow(2, retryCount) * 1000 // Exponential backoff

      console.log(`[Retry] Waiting ${delay}ms before retry ${retryCount + 1}/${maxRetries}`)

      setTimeout(() => {
        retry()
      }, delay)
    }
  }

  // Retrying state - show progress
  if (status === 'retrying') {
    return (
      <Claude onFinished={recover}>
        <Phase name="retry-preparation">
          Preparing retry attempt {retryCount + 1} of {maxRetries}.

          Previous error: {lastError?.message}
          Error type: {lastError?.type}

          <Step>Analyze what went wrong</Step>
          <Step>Adjust approach if needed</Step>
          <Step>Prepare for retry</Step>
        </Phase>
      </Claude>
    )
  }

  // Failed state - provide summary
  if (status === 'failed') {
    return (
      <Claude>
        <Phase name="failure-report">
          Task failed after {retryCount} retries.

          Error history:
          {useErrorStore.getState().errors.map((err, i) => (
            `${i + 1}. [${err.type}] ${err.message} (${new Date(err.timestamp).toISOString()})`
          )).join('\n')}

          <Step>Summarize what was attempted</Step>
          <Step>Provide partial results if any</Step>
          <Step>Suggest next steps for the user</Step>
        </Phase>

        <OutputFormat
          schema={{
            attempted: 'string',
            partialResults: 'any | null',
            recommendation: 'string',
            errorSummary: 'string',
          }}
        >
          Return JSON with failure summary.
        </OutputFormat>
      </Claude>
    )
  }

  // Fallback mode - reduced capability when tools are unavailable
  if (fallbackMode) {
    return (
      <Claude onFinished={complete}>
        <ResilientResearcher />

        <Constraints>
          - FALLBACK MODE: External tools are unavailable
          - Use only your training knowledge
          - Clearly indicate when information may be outdated
          - Suggest how to verify findings when tools are restored
        </Constraints>

        <Phase name="fallback-execution">
          <Step>Complete task using internal knowledge only</Step>
          <Step>Note any limitations or uncertainties</Step>
          <Step>Provide best-effort response</Step>
        </Phase>

        Task: {task}

        <OutputFormat
          schema={{
            result: 'any',
            limitations: ['string - What could not be verified'],
            confidence: 'low | medium | high',
            suggestedFollowUp: 'string',
          }}
        >
          Return JSON with fallback results.
        </OutputFormat>
      </Claude>
    )
  }

  // Normal execution with error handling
  return (
    <Claude
      tools={[webSearch, calculator, fileReader]}
      onFinished={complete}
      onError={handleError}
    >
      <ResilientResearcher />

      <Constraints>
        - If a tool fails, try an alternative approach
        - Always provide partial results if complete execution fails
        - Log any issues encountered for debugging
        - Gracefully handle missing or malformed data
      </Constraints>

      <Phase name="execute">
        <Step>Attempt to complete the task</Step>
        <Step>If tools fail, adapt and continue</Step>
        <Step>Provide the best possible result</Step>
      </Phase>

      Task: {task}

      <OutputFormat
        schema={{
          result: 'any',
          toolsUsed: ['string'],
          issuesEncountered: ['string'],
          status: 'complete | partial | failed',
        }}
      >
        Return JSON with execution results.
      </OutputFormat>
    </Claude>
  )
}

// Wrapper component with automatic fallback
export function AutoFallbackAgent({ task }: { task: string }) {
  const { status } = useErrorStore()
  const [useFallback, setUseFallback] = useState(false)

  // After 3 failures, switch to fallback mode
  useEffect(() => {
    if (status === 'failed') {
      setUseFallback(true)
    }
  }, [status])

  return <ResilientAgent task={task} fallbackMode={useFallback} />
}
```

## Error Handling Strategies

### Strategy 1: Exponential Backoff

```tsx
function withExponentialBackoff(fn: () => Promise<unknown>, maxRetries = 3) {
  return async () => {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await fn()
      } catch (error) {
        if (attempt === maxRetries - 1) throw error

        const delay = Math.pow(2, attempt) * 1000
        console.log(`Attempt ${attempt + 1} failed, waiting ${delay}ms`)
        await new Promise((resolve) => setTimeout(resolve, delay))
      }
    }
  }
}
```

### Strategy 2: Circuit Breaker

```tsx
const useCircuitBreaker = create<{
  state: 'closed' | 'open' | 'half-open'
  failures: number
  threshold: number
  resetTimeout: number
  lastFailure: number | null

  recordFailure: () => void
  recordSuccess: () => void
  canExecute: () => boolean
}>((set, get) => ({
  state: 'closed',
  failures: 0,
  threshold: 5,
  resetTimeout: 30000,
  lastFailure: null,

  recordFailure: () => {
    const { failures, threshold } = get()
    const newFailures = failures + 1

    set({
      failures: newFailures,
      lastFailure: Date.now(),
      state: newFailures >= threshold ? 'open' : 'closed',
    })
  },

  recordSuccess: () => {
    set({ failures: 0, state: 'closed' })
  },

  canExecute: () => {
    const { state, lastFailure, resetTimeout } = get()

    if (state === 'closed') return true

    if (state === 'open' && lastFailure) {
      const elapsed = Date.now() - lastFailure
      if (elapsed > resetTimeout) {
        set({ state: 'half-open' })
        return true
      }
    }

    return state === 'half-open'
  },
}))

export function CircuitBreakerAgent({ task }: { task: string }) {
  const { canExecute, recordFailure, recordSuccess } = useCircuitBreaker()

  if (!canExecute()) {
    return (
      <Claude>
        <Phase name="circuit-open">
          Service temporarily unavailable due to repeated failures.
          Please try again later.
        </Phase>
      </Claude>
    )
  }

  return (
    <Claude
      onFinished={recordSuccess}
      onError={(error) => {
        recordFailure()
        console.error('Task failed:', error)
      }}
    >
      <Phase name="execute">{task}</Phase>
    </Claude>
  )
}
```

### Strategy 3: Graceful Degradation

```tsx
export function GracefulDegradationAgent({
  task,
  tools,
}: {
  task: string
  tools: Tool[]
}) {
  const [availableTools, setAvailableTools] = useState(tools)
  const [degradedMode, setDegradedMode] = useState(false)

  const handleError = (error: Error) => {
    // If a tool fails, remove it and continue with remaining tools
    if (error.message.includes('tool')) {
      const failedTool = extractToolName(error.message)
      setAvailableTools((prev) => prev.filter((t) => t.name !== failedTool))

      if (availableTools.length <= 1) {
        setDegradedMode(true)
      }

      console.log(`Tool ${failedTool} disabled, continuing with ${availableTools.length - 1} tools`)
    }
  }

  return (
    <Claude
      tools={availableTools}
      onError={handleError}
    >
      {degradedMode && (
        <Constraints>
          DEGRADED MODE: Some tools are unavailable.
          Complete the task with reduced capabilities.
        </Constraints>
      )}

      <Phase name="execute">
        {task}

        Available tools: {availableTools.map((t) => t.name).join(', ')}
      </Phase>
    </Claude>
  )
}
```

## Running with Error Handling

```bash
# Normal run - errors will trigger retry logic
smithers run resilient-agent.tsx \
  --props '{"task": "Search for recent AI news"}'

# Force fallback mode for testing
smithers run resilient-agent.tsx \
  --props '{"task": "Search for recent AI news", "fallbackMode": true}'

# With verbose error logging
smithers run resilient-agent.tsx \
  --props '{"task": "..."}' \
  --verbose
```

## Key Patterns Demonstrated

<CardGroup cols={2}>
  <Card title="Error Classification" icon="filter">
    Categorize errors to determine appropriate handling strategy
  </Card>
  <Card title="Retry with Backoff" icon="rotate">
    Exponential backoff for transient failures
  </Card>
  <Card title="Fallback Mode" icon="parachute-box">
    Graceful degradation when tools are unavailable
  </Card>
  <Card title="Circuit Breaker" icon="toggle-off">
    Prevent cascade failures by stopping repeated attempts
  </Card>
</CardGroup>

## Error Reporting

```tsx
function ErrorReporter({ errors }: { errors: AgentError[] }) {
  const summary = {
    total: errors.length,
    byType: errors.reduce((acc, err) => {
      acc[err.type] = (acc[err.type] || 0) + 1
      return acc
    }, {} as Record<string, number>),
    retryable: errors.filter((e) => e.retryable).length,
  }

  return (
    <div className="error-report">
      <h3>Error Summary</h3>
      <p>Total errors: {summary.total}</p>
      <p>Retryable: {summary.retryable}</p>
      <ul>
        {Object.entries(summary.byType).map(([type, count]) => (
          <li key={type}>{type}: {count}</li>
        ))}
      </ul>
    </div>
  )
}
```

## Related Examples

<CardGroup cols={2}>
  <Card title="Streaming Progress" icon="signal-stream" href="/examples/06-streaming-progress">
    Handle errors during streaming
  </Card>
  <Card title="Data Pipeline" icon="database" href="/examples/data-pipeline">
    ETL with recovery
  </Card>
</CardGroup>
