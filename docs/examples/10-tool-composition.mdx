---
title: Tool Composition
description: Complex tool composition with multiple tools and MCP servers
---

# Tool Composition

This example demonstrates how to compose multiple tools and MCP servers together to create powerful, multi-capability agents.

## Complete Example

```tsx
import { create } from 'zustand'
import {
  Claude,
  Phase,
  Step,
  Subagent,
  Persona,
  Constraints,
  OutputFormat,
} from '@evmts/smithers'
import { MCPPresets, createMCPConfigs } from 'smithers/mcp'
import type { Tool } from '@evmts/smithers'

// Custom tool definitions
const calculatorTool: Tool = {
  name: 'calculator',
  description: 'Perform mathematical calculations',
  input_schema: {
    type: 'object',
    properties: {
      expression: {
        type: 'string',
        description: 'Mathematical expression to evaluate',
      },
    },
    required: ['expression'],
  },
  execute: async (args: { expression: string }) => {
    // Safe math evaluation (use a proper library in production)
    return { result: eval(args.expression) }
  },
}

const dateTimeTool: Tool = {
  name: 'datetime',
  description: 'Get current date/time or perform date calculations',
  input_schema: {
    type: 'object',
    properties: {
      operation: {
        type: 'string',
        enum: ['now', 'format', 'add', 'diff'],
        description: 'Date operation to perform',
      },
      date: { type: 'string', description: 'Date string (ISO format)' },
      format: { type: 'string', description: 'Output format' },
      amount: { type: 'number', description: 'Amount to add' },
      unit: { type: 'string', enum: ['days', 'hours', 'minutes'] },
    },
    required: ['operation'],
  },
  execute: async (args: any) => {
    if (args.operation === 'now') {
      return { result: new Date().toISOString() }
    }
    // Add more operations as needed
    return { result: new Date().toISOString() }
  },
}

const jsonValidatorTool: Tool = {
  name: 'validate_json',
  description: 'Validate JSON against a schema',
  input_schema: {
    type: 'object',
    properties: {
      json: { type: 'string', description: 'JSON string to validate' },
      schema: { type: 'object', description: 'JSON Schema to validate against' },
    },
    required: ['json', 'schema'],
  },
  execute: async (args: { json: string; schema: object }) => {
    try {
      JSON.parse(args.json)
      return { valid: true, errors: [] }
    } catch (e) {
      return { valid: false, errors: [(e as Error).message] }
    }
  },
}

// Combine tools for different use cases
const researchTools = [calculatorTool, dateTimeTool]
const developmentTools = [jsonValidatorTool]

// MCP server configurations for different capabilities
const createMCPStack = (projectPath: string) =>
  createMCPConfigs([
    // File system access for the project
    MCPPresets.filesystem([projectPath, '/tmp']),

    // Git operations
    MCPPresets.git(projectPath),

    // Memory for storing intermediate results
    MCPPresets.memory(),

    // Web fetching for documentation/research
    MCPPresets.fetch(),
  ])

// Full-stack development persona
function FullStackDeveloper() {
  return (
    <Persona role="Full-Stack Developer">
      You are an expert full-stack developer with access to multiple tools.
      You effectively combine different tools to accomplish complex tasks.
      You know when to use each tool and how to chain their outputs.
    </Persona>
  )
}

// Main tool composition agent
export function ToolCompositionAgent({
  task,
  projectPath,
  capabilities,
}: {
  task: string
  projectPath: string
  capabilities: {
    filesystem: boolean
    git: boolean
    web: boolean
    memory: boolean
  }
}) {
  // Build MCP config based on requested capabilities
  const mcpServers = createMCPConfigs([
    ...(capabilities.filesystem ? [MCPPresets.filesystem([projectPath])] : []),
    ...(capabilities.git ? [MCPPresets.git(projectPath)] : []),
    ...(capabilities.web ? [MCPPresets.fetch()] : []),
    ...(capabilities.memory ? [MCPPresets.memory()] : []),
  ])

  // Combine custom tools with MCP servers
  const allTools = [...researchTools, ...developmentTools]

  return (
    <Claude
      tools={allTools}
      mcpServers={mcpServers}
    >
      <FullStackDeveloper />

      <Constraints>
        Available capabilities:
        {capabilities.filesystem && '- File system access (read/write files)'}
        {capabilities.git && '- Git operations (commit, branch, diff)'}
        {capabilities.web && '- Web fetching (fetch URLs, documentation)'}
        {capabilities.memory && '- Memory storage (persist data between steps)'}

        Custom tools available:
        - calculator: Mathematical calculations
        - datetime: Date/time operations
        - validate_json: JSON validation

        - Chain tools effectively to accomplish the task
        - Store intermediate results in memory if needed
        - Validate outputs before proceeding to next step
      </Constraints>

      <Phase name="analyze">
        <Step>Understand the task requirements</Step>
        <Step>Identify which tools/capabilities are needed</Step>
        <Step>Plan the tool usage sequence</Step>
      </Phase>

      <Phase name="execute">
        Task: {task}

        <Step>Execute using available tools</Step>
        <Step>Validate intermediate results</Step>
        <Step>Store important data in memory</Step>
      </Phase>

      <OutputFormat
        schema={{
          result: 'any - task result',
          toolsUsed: ['string - tools that were invoked'],
          memoryKeys: ['string - keys stored in memory'],
          steps: [
            {
              tool: 'string',
              input: 'any',
              output: 'any',
            },
          ],
        }}
      >
        Return JSON with complete execution details.
      </OutputFormat>
    </Claude>
  )
}

// Research agent with specialized tool composition
export function ResearchAgent({
  topic,
  depth,
}: {
  topic: string
  depth: 'quick' | 'standard' | 'deep'
}) {
  const mcpServers = createMCPConfigs([
    MCPPresets.fetch(),           // Fetch web content
    MCPPresets.memory(),          // Store findings
    MCPPresets.braveSearch(),     // Web search
  ])

  const researchConstraints = {
    quick: '- Limit to 3 sources maximum',
    standard: '- Use 5-10 sources',
    deep: '- Be comprehensive, use 10+ sources',
  }

  return (
    <Claude
      tools={[calculatorTool, dateTimeTool]}
      mcpServers={mcpServers}
    >
      <Persona role="Research Analyst">
        You are a thorough research analyst who gathers and synthesizes
        information from multiple sources. You verify facts and cite sources.
      </Persona>

      <Constraints>
        {researchConstraints[depth]}
        - Verify information across multiple sources
        - Store key findings in memory
        - Use calculator for any numerical analysis
        - Include publication dates for time-sensitive info
      </Constraints>

      <Phase name="search">
        <Step>Search for information about: {topic}</Step>
        <Step>Fetch relevant pages</Step>
        <Step>Store raw findings in memory</Step>
      </Phase>

      <Phase name="analyze">
        <Step>Cross-reference information</Step>
        <Step>Identify consensus and contradictions</Step>
        <Step>Perform any needed calculations</Step>
      </Phase>

      <Phase name="synthesize">
        <Step>Compile findings into coherent summary</Step>
        <Step>Include citations and sources</Step>
        <Step>Note confidence level and caveats</Step>
      </Phase>

      <OutputFormat
        schema={{
          summary: 'string',
          keyFindings: ['string'],
          sources: [{ url: 'string', title: 'string', date: 'string' }],
          calculations: [{ description: 'string', result: 'number' }],
          confidence: 'low | medium | high',
          caveats: ['string'],
        }}
      >
        Return JSON with research results.
      </OutputFormat>
    </Claude>
  )
}

// Code analysis agent with tool composition
export function CodeAnalysisAgent({
  repoPath,
  analysisType,
}: {
  repoPath: string
  analysisType: 'security' | 'performance' | 'quality' | 'all'
}) {
  const mcpServers = createMCPConfigs([
    MCPPresets.filesystem([repoPath]),
    MCPPresets.git(repoPath),
  ])

  // Analysis-specific tools
  const securityTool: Tool = {
    name: 'security_scan',
    description: 'Scan code for security vulnerabilities',
    input_schema: {
      type: 'object',
      properties: {
        file: { type: 'string', description: 'File to scan' },
        patterns: { type: 'array', items: { type: 'string' } },
      },
    },
    execute: async (args: any) => {
      // Placeholder - integrate with real security scanner
      return { vulnerabilities: [] }
    },
  }

  const metricsTools: Tool = {
    name: 'code_metrics',
    description: 'Calculate code complexity and metrics',
    input_schema: {
      type: 'object',
      properties: {
        file: { type: 'string' },
        metrics: {
          type: 'array',
          items: { type: 'string' },
          description: 'Metrics to calculate: loc, complexity, dependencies',
        },
      },
    },
    execute: async (args: any) => {
      return { loc: 0, complexity: 0, dependencies: [] }
    },
  }

  const tools = [
    calculatorTool,
    ...(analysisType === 'security' || analysisType === 'all' ? [securityTool] : []),
    ...(analysisType === 'performance' || analysisType === 'quality' || analysisType === 'all'
      ? [metricsTools]
      : []),
  ]

  return (
    <Claude tools={tools} mcpServers={mcpServers}>
      <Persona role="Code Analyst">
        You are an expert code analyst who identifies issues and opportunities
        for improvement. You use multiple analysis tools in combination.
      </Persona>

      <Constraints>
        Analysis type: {analysisType}
        Repository: {repoPath}

        - Read files from the repository
        - Check git history for recent changes
        - Run appropriate analysis tools
        - Aggregate and prioritize findings
      </Constraints>

      {analysisType === 'security' || analysisType === 'all' ? (
        <Phase name="security-analysis">
          <Step>Scan for common vulnerability patterns</Step>
          <Step>Check for hardcoded secrets</Step>
          <Step>Analyze dependency security</Step>
        </Phase>
      ) : null}

      {analysisType === 'performance' || analysisType === 'all' ? (
        <Phase name="performance-analysis">
          <Step>Identify performance bottlenecks</Step>
          <Step>Analyze algorithmic complexity</Step>
          <Step>Check for resource leaks</Step>
        </Phase>
      ) : null}

      {analysisType === 'quality' || analysisType === 'all' ? (
        <Phase name="quality-analysis">
          <Step>Calculate code metrics</Step>
          <Step>Identify code smells</Step>
          <Step>Check test coverage</Step>
        </Phase>
      ) : null}

      <Phase name="report">
        <Step>Compile all findings</Step>
        <Step>Prioritize by severity</Step>
        <Step>Suggest remediation steps</Step>
      </Phase>

      <OutputFormat
        schema={{
          summary: 'string',
          findings: [
            {
              type: 'security | performance | quality',
              severity: 'critical | high | medium | low',
              file: 'string',
              line: 'number',
              description: 'string',
              suggestion: 'string',
            },
          ],
          metrics: {
            totalFiles: 'number',
            totalLoc: 'number',
            averageComplexity: 'number',
          },
          recommendations: ['string'],
        }}
      >
        Return JSON with complete analysis.
      </OutputFormat>
    </Claude>
  )
}

// Multi-agent orchestration with shared tools
export function OrchestratedTeam({
  project,
  projectPath,
}: {
  project: string
  projectPath: string
}) {
  const [phase, setPhase] = createSignal<'research' | 'implement' | 'review'>('research')
  const [researchFindings, setResearchFindings] = createSignal(null)
  const [implementation, setImplementation] = createSignal(null)

  const sharedMcp = createMCPConfigs([
    MCPPresets.filesystem([projectPath]),
    MCPPresets.memory(), // Shared memory between agents
  ])

  return () => {
    if (phase() === 'research') {
    return (
      <Subagent name="researcher">
        <Claude
          mcpServers={sharedMcp}
          tools={[dateTimeTool]}
          onFinished={(result) => {
            setResearchFindings(result)
            setPhase('implement')
          }}
        >
          <Phase name="research">
            Research requirements for: {project}
            Store findings in shared memory.
          </Phase>
        </Claude>
      </Subagent>
      )
    }

    if (phase() === 'implement') {
      return (
        <Subagent name="implementer">
          <Claude
            mcpServers={sharedMcp}
            tools={[jsonValidatorTool, calculatorTool]}
            onFinished={(result) => {
              setImplementation(result)
              setPhase('review')
            }}
          >
            <Phase name="implement">
              Retrieve research from memory.
              Implement based on findings.
              Validate outputs with tools.
            </Phase>
          </Claude>
        </Subagent>
      )
    }

    return (
      <Subagent name="reviewer">
        <Claude mcpServers={sharedMcp}>
          <Phase name="review">
            Review implementation against research findings.
            Both should be in shared memory.
          </Phase>
        </Claude>
      </Subagent>
    )
  }
}
```

## Running Tool Composition Agents

```bash
# Full capability agent
smithers run tool-composition.tsx \
  --props '{
    "task": "Analyze and optimize the API endpoints",
    "projectPath": "/home/user/project",
    "capabilities": {
      "filesystem": true,
      "git": true,
      "web": true,
      "memory": true
    }
  }'

# Research agent with deep analysis
smithers run tool-composition.tsx \
  --entry ResearchAgent \
  --props '{"topic": "GraphQL vs REST performance", "depth": "deep"}'

# Code analysis
smithers run tool-composition.tsx \
  --entry CodeAnalysisAgent \
  --props '{"repoPath": "/home/user/project", "analysisType": "all"}'
```

## Tool Composition Patterns

### Pattern 1: Capability Stacks

```tsx
// Define capability stacks for common use cases
const devStack = {
  tools: [jsonValidatorTool, calculatorTool],
  mcp: createMCPConfigs([
    MCPPresets.filesystem(['.']),
    MCPPresets.git(),
  ]),
}

const researchStack = {
  tools: [dateTimeTool, calculatorTool],
  mcp: createMCPConfigs([
    MCPPresets.fetch(),
    MCPPresets.braveSearch(),
    MCPPresets.memory(),
  ]),
}

// Use stacks in components
<Claude tools={devStack.tools} mcpServers={devStack.mcp}>
  ...
</Claude>
```

### Pattern 2: Tool Chaining

```tsx
function ToolChainingAgent({ data }) {
  return (
    <Claude tools={[fetchTool, parseTool, validateTool, transformTool]}>
      <Phase name="chain">
        <Step>Fetch data from URL using fetch tool</Step>
        <Step>Parse response using parse tool</Step>
        <Step>Validate structure using validate tool</Step>
        <Step>Transform data using transform tool</Step>
      </Phase>

      Process: {data}

      Each step should use the output of the previous step.
    </Claude>
  )
}
```

## Key Patterns Demonstrated

<CardGroup cols={2}>
  <Card title="Tool + MCP Combination" icon="puzzle-piece">
    Combine custom tools with MCP server capabilities
  </Card>
  <Card title="Capability Stacks" icon="layer-group">
    Pre-defined tool combinations for common tasks
  </Card>
  <Card title="Shared Memory" icon="database">
    MCP memory server for cross-agent state sharing
  </Card>
  <Card title="Conditional Tools" icon="filter">
    Enable/disable tools based on configuration
  </Card>
</CardGroup>

## Related Examples

<CardGroup cols={2}>
  <Card title="MCP Filesystem" icon="folder" href="/examples/08-mcp-filesystem">
    Deep dive into filesystem operations
  </Card>
  <Card title="Multi-Agent Team" icon="users" href="/examples/multi-agent">
    Coordinating multiple specialized agents
  </Card>
</CardGroup>
