---
title: State API
description: Key-value state storage with history and time-travel
---

# State API

The state API provides key-value storage with full history tracking and time-travel capabilities.

## Methods

All State API methods are **synchronous** (use SQLite's synchronous API via bun:sqlite).

### get

Get a value by key.

```tsx
const phase = db.state.get<string>("phase");
// "review" | null
```

### set

Set a value with optional trigger.

```tsx
db.state.set("phase", "review");

// With trigger for tracking what caused the change
db.state.set("phase", "review", "tests_passed");
```

### setMany

Set multiple values atomically.

```tsx
db.state.setMany({
  phase: "complete",
  completedAt: Date.now(),
  result: { success: true },
});

// With trigger
db.state.setMany(
  { phase: "review", reviewer: "claude" },
  "implementation_done"
);
```

### getAll

Get all state as an object.

```tsx
const state = db.state.getAll();
// { phase: "review", attempts: 3, data: {...} }
```

### reset

Clear all state.

```tsx
db.state.reset();
```

### history

Get state transition history.

```tsx
// History for a specific key (positional args: key, limit)
const phaseHistory = db.state.history("phase", 10);
// [
//   { id: "t1", key: "phase", old_value: null, new_value: "start", trigger: "init", ... },
//   { id: "t2", key: "phase", old_value: "start", new_value: "review", trigger: "tests_passed", ... },
// ]

// All history (no key filter)
const allHistory = db.state.history(undefined, 50);

// Default: last 100 transitions
const recentHistory = db.state.history();
```

### has

Check if a key exists in state.

```tsx
if (db.state.has("phase")) {
  console.log("Phase key exists");
}
```

### delete

Delete a key from state (with optional trigger for tracking).

```tsx
db.state.delete("tempData");

// With trigger for auditing
db.state.delete("cache", "cleanup");
```

### replayTo

Time-travel: restore state to a previous transition.

```tsx
// Get history
const history = db.state.history("phase");

// Replay to an earlier state
await db.state.replayTo(history[0].id);
// State is now what it was at that transition
```

### snapshot

Take a complete state snapshot.

```tsx
const snapshot = await db.state.snapshot();
// { phase: "review", attempts: 3, data: {...} }
```

### restore

Restore from a snapshot.

```tsx
const snapshot = await db.state.snapshot();

// ... do some work ...

// Restore to the snapshot
await db.state.restore(snapshot, "rollback");
```

## Usage Patterns

### Initialize from Database

```tsx
async function Workflow() {
  // Load persisted state
  const savedPhase = await db.state.get("phase");
  const [phase, setPhase] = useState(savedPhase ?? "start");

  // Sync updates to database
  const updatePhase = async (newPhase: string) => {
    setPhase(newPhase);
    await db.state.set("phase", newPhase);
  };

  return (
    <Ralph maxIterations={10}>
      <If condition={phase === "start"}>
        <Claude onFinished={() => updatePhase("done")}>
          Complete the task.
        </Claude>
      </If>
    </Ralph>
  );
}
```

### Track Causality with Triggers

```tsx
<Claude
  onFinished={async (result) => {
    if (result.output.includes("PASS")) {
      await db.state.set("phase", "complete", "tests_passed");
    } else {
      await db.state.set("phase", "retry", "tests_failed");
    }
  }}
>
  Run tests.
</Claude>
```

### Checkpoint and Rollback

```tsx
// Save checkpoint
const checkpoint = await db.state.snapshot();

// Try risky operation
try {
  await riskyOperation();
  await db.state.set("status", "success");
} catch (error) {
  // Rollback on failure
  await db.state.restore(checkpoint, "error_rollback");
}
```

## Types

```tsx
interface StateModule {
  get: <T>(key: string) => T | null;
  set: <T>(key: string, value: T, trigger?: string) => void;
  setMany: (updates: Record<string, unknown>, trigger?: string) => void;
  getAll: () => Record<string, unknown>;
  reset: () => void;
  history: (key?: string, limit?: number) => Transition[];
  has: (key: string) => boolean;
  delete: (key: string, trigger?: string) => void;
}

interface Transition {
  id: string;
  execution_id?: string;
  key: string;
  old_value: any;
  new_value: any;
  trigger?: string;
  trigger_agent_id?: string;
  created_at: Date;
}
```

## Related

<CardGroup cols={2}>
  <Card title="Database Persistence" icon="database" href="/concepts/database-persistence">
    State persistence concepts
  </Card>
  <Card title="Database API" icon="server" href="/api-reference/database">
    Database overview
  </Card>
</CardGroup>
