---
title: executePlan
description: Execute a Smithers agent with the Ralph Wiggum loop
---

# executePlan

Execute a Smithers component using the Ralph Wiggum loop - repeatedly rendering and executing until completion.

## Signature

```typescript
function executePlan(
  element: () => JSX.Element,
  options?: ExecuteOptions
): Promise<ExecutionResult>
```

## Parameters

<ParamField path="element" type="() => JSX.Element" required>
  A function that returns the JSX element to execute. Typically `() => <Agent />`.
</ParamField>

<ParamField path="options" type="ExecuteOptions">
  Configuration options for execution.

  ```typescript
  interface ExecuteOptions {
    autoApprove?: boolean      // Skip plan approval prompts
    maxFrames?: number         // Maximum iterations (default: 100)
    timeout?: number           // Total timeout in milliseconds
    verbose?: boolean          // Show detailed execution logs
    mockMode?: boolean         // Enable mock mode (no real API calls)
    model?: string             // Override the Claude model
    maxTokens?: number         // Maximum tokens for Claude responses
    onPlan?: (xml: string, frame: number) => void  // Called before each frame
    onFrame?: (result: FrameResult) => void        // Called after each frame
  }
  ```
</ParamField>

## Returns

<ParamField path="Promise<ExecutionResult>">
  A promise that resolves to the execution result.

  ```typescript
  interface ExecutionResult {
    output: any                // Final output from the last Claude call
    frames: number             // Total number of frames executed
    history: FrameHistory[]    // Detailed history of each frame
  }

  interface FrameHistory {
    frame: number
    plan: string               // XML plan for this frame
    executedNodes: string[]    // Node names that were executed
    duration: number           // Frame duration in milliseconds
  }
  ```
</ParamField>

## Usage

### Basic Execution

```tsx
import { executePlan, Claude } from '@evmts/smithers'

function SimpleAgent(props) {
  return (
    <Claude>
      Complete this task: {props.task}
    </Claude>
  )
}

const result = await executePlan(
  () => <SimpleAgent task="Write a haiku about coding" />
)

console.log('Output:', result.output)
console.log('Frames:', result.frames)
```

### With Options

```tsx
const result = await executePlan(() => <ResearchAgent topic="AI" />, {
  autoApprove: true,      // No approval prompts
  maxFrames: 50,          // Limit iterations
  timeout: 300000,        // 5 minute timeout

  onPlan: (xml, frame) => {
    console.log(`\n=== Frame ${frame} ===`)
    console.log(xml)
  },

  onFrame: (frameResult) => {
    console.log('Executed:', frameResult.executedNodes)
    console.log('Duration:', frameResult.duration, 'ms')
  },
})
```

### Multi-Phase Agent

```tsx
import { createSignal } from 'solid-js'

function MultiPhaseAgent(props) {
  const [phase, setPhase] = createSignal('research')
  const [data, setData] = createSignal(null)

  return () => {
    const p = phase()

    if (p === 'research') {
      return (
        <Claude tools={[webSearch]} onFinished={(res) => {
          setData(res)
          setPhase('write')
        }}>
          Research {props.topic}
        </Claude>
      )
    }

    return (
      <Claude>
        Write a report: {JSON.stringify(data())}
      </Claude>
    )
  }
}

const result = await executePlan(() => <MultiPhaseAgent topic="quantum" />, {
  onPlan: (xml, frame) => {
    console.log(`Frame ${frame}: ${xml.includes('research') ? 'Research' : 'Write'}`)
  }
})

console.log('Total frames:', result.frames)  // 2
```

### Error Handling

```tsx
try {
  const result = await executePlan(() => <RiskyAgent />, {
    maxFrames: 10,
    timeout: 60000,
  })
  console.log('Success:', result.output)
} catch (error) {
  if (error.code === 'MAX_FRAMES_EXCEEDED') {
    console.error('Agent took too many iterations')
  } else if (error.code === 'TIMEOUT') {
    console.error('Agent timed out')
  } else if (error.code === 'USER_CANCELLED') {
    console.error('User declined to approve plan')
  } else {
    console.error('Execution failed:', error.message)
  }
}
```

### Analyzing Execution History

```tsx
const result = await executePlan(() => <ComplexAgent />, { autoApprove: true })

console.log('\n=== Execution Summary ===')
console.log(`Total frames: ${result.frames}`)
console.log(`Total duration: ${result.history.reduce((sum, f) => sum + f.duration, 0)}ms`)

result.history.forEach((frame, i) => {
  console.log(`\nFrame ${i + 1}:`)
  console.log(`  Nodes: ${frame.executedNodes.join(', ')}`)
  console.log(`  Duration: ${frame.duration}ms`)
})
```

## Frame Lifecycle

Each frame in the Ralph Wiggum loop:

1. **Render**: Solid components render to SmithersNode tree
2. **Serialize**: Tree converts to XML plan
3. **Callback**: `onPlan` called with XML and frame number
4. **Execute**: Pending `<Claude>` nodes are executed
5. **Update**: `onFinished` callbacks update Solid signals
6. **Callback**: `onFrame` called with frame result
7. **Loop**: If state changed, repeat from step 1

```tsx
await executePlan(() => <Agent />, {
  onPlan: (xml, frame) => {
    // Called BEFORE execution
    console.log(`Frame ${frame} starting...`)
  },
  onFrame: (result) => {
    // Called AFTER execution
    console.log(`Frame completed in ${result.duration}ms`)
  },
})
```

## Parallel Execution

When `<Subagent>` components are present, they execute in parallel:

```tsx
const result = await executePlan(
  () => <ParallelResearch topics={['AI', 'ML', 'DL']} />,
  {
    onFrame: (frame) => {
      // May show multiple nodes executed in same frame
      console.log('Executed:', frame.executedNodes)
      // ['subagent-AI', 'subagent-ML', 'subagent-DL']
    }
  }
)
```

## Related

<CardGroup cols={2}>
  <Card title="renderPlan" icon="eye" href="/api-reference/render-plan">
    Preview plans without execution
  </Card>
  <Card title="Ralph Wiggum Loop" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the execution model
  </Card>
  <Card title="smithers run" icon="terminal" href="/cli/run">
    CLI command for execution
  </Card>
</CardGroup>
