---
title: executePlan
description: Execute a Smithers agent with the Ralph Wiggum loop
---

# executePlan

Execute a Smithers component using the Ralph Wiggum loop - repeatedly rendering and executing until completion.

## Signature

```typescript
function executePlan(
  element: ReactElement,
  options?: ExecuteOptions
): Promise<ExecutionResult>
```

## Parameters

<ParamField path="element" type="ReactElement" required>
  The React element to execute. Typically your agent component with props.
</ParamField>

<ParamField path="options" type="ExecuteOptions">
  Configuration options for execution.

  ```typescript
  interface ExecuteOptions {
    autoApprove?: boolean      // Skip plan approval prompts
    maxFrames?: number         // Maximum iterations (default: 100)
    timeout?: number           // Total timeout in milliseconds
    verbose?: boolean          // Show detailed execution logs
    mockMode?: boolean         // Enable mock mode (no real API calls)
    model?: string             // Override the Claude model
    maxTokens?: number         // Maximum tokens for Claude responses
    onPlan?: (xml: string, frame: number) => void  // Called before each frame
    onFrame?: (result: FrameResult) => void        // Called after each frame
  }
  ```
</ParamField>

## Returns

<ParamField path="Promise<ExecutionResult>">
  A promise that resolves to the execution result.

  ```typescript
  interface ExecutionResult {
    output: any                // Final output from the last Claude call
    frames: number             // Total number of frames executed
    history: FrameHistory[]    // Detailed history of each frame
  }

  interface FrameHistory {
    frame: number
    plan: string               // XML plan for this frame
    executedNodes: string[]    // Node names that were executed
    duration: number           // Frame duration in milliseconds
  }
  ```
</ParamField>

## Usage

### Basic Execution

```tsx
import { executePlan, Claude } from 'smithers'

function SimpleAgent({ task }) {
  return (
    <Claude>
      Complete this task: {task}
    </Claude>
  )
}

const result = await executePlan(
  <SimpleAgent task="Write a haiku about coding" />
)

console.log('Output:', result.output)
console.log('Frames:', result.frames)
```

### With Options

```tsx
const result = await executePlan(<ResearchAgent topic="AI" />, {
  autoApprove: true,      // No approval prompts
  maxFrames: 50,          // Limit iterations
  timeout: 300000,        // 5 minute timeout

  onPlan: (xml, frame) => {
    console.log(`\n=== Frame ${frame} ===`)
    console.log(xml)
  },

  onFrame: (frameResult) => {
    console.log('Executed:', frameResult.executedNodes)
    console.log('Duration:', frameResult.duration, 'ms')
  },
})
```

### Multi-Phase Agent

```tsx
import { create } from 'zustand'

const useStore = create((set) => ({
  phase: 'research',
  data: null,
  setData: (data) => set({ data, phase: 'write' }),
}))

function MultiPhaseAgent({ topic }) {
  const { phase, data, setData } = useStore()

  if (phase === 'research') {
    return (
      <Claude tools={[webSearch]} onFinished={setData}>
        Research {topic}
      </Claude>
    )
  }

  return (
    <Claude>
      Write a report: {JSON.stringify(data)}
    </Claude>
  )
}

const result = await executePlan(<MultiPhaseAgent topic="quantum" />, {
  onPlan: (xml, frame) => {
    console.log(`Frame ${frame}: ${xml.includes('research') ? 'Research' : 'Write'}`)
  }
})

console.log('Total frames:', result.frames)  // 2
```

### Error Handling

```tsx
try {
  const result = await executePlan(<RiskyAgent />, {
    maxFrames: 10,
    timeout: 60000,
  })
  console.log('Success:', result.output)
} catch (error) {
  if (error.code === 'MAX_FRAMES_EXCEEDED') {
    console.error('Agent took too many iterations')
  } else if (error.code === 'TIMEOUT') {
    console.error('Agent timed out')
  } else if (error.code === 'USER_CANCELLED') {
    console.error('User declined to approve plan')
  } else {
    console.error('Execution failed:', error.message)
  }
}
```

### Analyzing Execution History

```tsx
const result = await executePlan(<ComplexAgent />, { autoApprove: true })

console.log('\n=== Execution Summary ===')
console.log(`Total frames: ${result.frames}`)
console.log(`Total duration: ${result.history.reduce((sum, f) => sum + f.duration, 0)}ms`)

result.history.forEach((frame, i) => {
  console.log(`\nFrame ${i + 1}:`)
  console.log(`  Nodes: ${frame.executedNodes.join(', ')}`)
  console.log(`  Duration: ${frame.duration}ms`)
})
```

## Frame Lifecycle

Each frame in the Ralph Wiggum loop:

1. **Render**: React components render to SmithersNode tree
2. **Serialize**: Tree converts to XML plan
3. **Callback**: `onPlan` called with XML and frame number
4. **Execute**: Pending `<Claude>` nodes are executed
5. **Update**: `onFinished` callbacks update React state
6. **Callback**: `onFrame` called with frame result
7. **Loop**: If state changed, repeat from step 1

```tsx
await executePlan(<Agent />, {
  onPlan: (xml, frame) => {
    // Called BEFORE execution
    console.log(`Frame ${frame} starting...`)
  },
  onFrame: (result) => {
    // Called AFTER execution
    console.log(`Frame completed in ${result.duration}ms`)
  },
})
```

## Parallel Execution

When `<Subagent>` components are present, they execute in parallel:

```tsx
const result = await executePlan(
  <ParallelResearch topics={['AI', 'ML', 'DL']} />,
  {
    onFrame: (frame) => {
      // May show multiple nodes executed in same frame
      console.log('Executed:', frame.executedNodes)
      // ['subagent-AI', 'subagent-ML', 'subagent-DL']
    }
  }
)
```

## Related

<CardGroup cols={2}>
  <Card title="renderPlan" icon="eye" href="/api-reference/render-plan">
    Preview plans without execution
  </Card>
  <Card title="Ralph Wiggum Loop" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the execution model
  </Card>
  <Card title="smithers run" icon="terminal" href="/cli/run">
    CLI command for execution
  </Card>
</CardGroup>
