---
title: serialize
description: Convert a SmithersNode tree to XML string format
---

# serialize

The `serialize` function converts a SmithersNode tree into an XML string representation. This is useful for inspecting the plan structure or debugging rendering issues.

## Import

```typescript
import { serialize } from 'smithers'
```

## Signature

```typescript
function serialize(node: SmithersNode): string
```

## Parameters

<ParamField path="node" type="SmithersNode" required>
  The root node of the SmithersNode tree to serialize.
</ParamField>

## Returns

Returns a formatted XML string representation of the node tree.

## Description

The `serialize` function:

1. **Converts nodes to XML tags**: Each `SmithersNode` becomes an XML element with the node type as the tag name (lowercased).

2. **Serializes props as attributes**: Node props become XML attributes, with these behaviors:
   - Functions: Serialized as their string representation
   - Objects: JSON stringified and XML-escaped
   - Primitives: Converted to strings and XML-escaped

3. **Filters runtime-only props**: These props are excluded from XML output:
   - `children` (handled separately)
   - `value` (for TEXT nodes)
   - `schema` (Zod schema objects)
   - `tools` (tool definitions with execute functions)
   - Callbacks: `onFinished`, `onError`, `onToolError`, `onStreamStart`, `onStreamDelta`, `onStreamEnd`, `onApprove`, `onReject`
   - `mcpServers` (MCP server configs)
   - `toolRetry` (retry configuration)
   - `debug` (debug options)

4. **Handles special node types**:
   - `TEXT` nodes: Serialized as escaped text content
   - `ROOT` nodes: Children serialized and joined with newlines
   - Element nodes: Rendered as XML with attributes and children

5. **Formats output**: Indents nested elements by 2 spaces for readability.

6. **Escapes XML special characters**: `<`, `>`, `&`, `"`, `'` are properly escaped.

## Examples

### Basic Usage

```typescript
import { createRoot, serialize } from 'smithers'
import { Claude, Phase } from 'smithers'

const root = createRoot()
const tree = await root.render(
  <Claude>
    <Phase name="analysis">
      Analyze the codebase
    </Phase>
  </Claude>
)

const xml = serialize(tree)
console.log(xml)
```

**Output:**
```xml
<claude>
  <phase name="analysis">
    Analyze the codebase
  </phase>
</claude>
```

### Inspecting Component Props

```typescript
const tree = await root.render(
  <Claude model="claude-opus-4" maxTokens={4096}>
    <Persona role="senior engineer" />
    Fix the authentication bug
  </Claude>
)

const xml = serialize(tree)
console.log(xml)
```

**Output:**
```xml
<claude model="claude-opus-4" maxTokens="4096">
  <persona role="senior engineer" />
  Fix the authentication bug
</claude>
```

### Debugging Complex Trees

```typescript
import { Subagent, Step } from 'smithers'

const tree = await root.render(
  <Phase name="implementation">
    <Subagent name="backend">
      <Step>Design API schema</Step>
      <Step>Implement endpoints</Step>
    </Subagent>
    <Subagent name="frontend">
      <Step>Create UI components</Step>
      <Step>Integrate with API</Step>
    </Subagent>
  </Phase>
)

const xml = serialize(tree)
console.log(xml)
```

**Output:**
```xml
<phase name="implementation">
  <subagent name="backend">
    <step>
      Design API schema
    </step>
    <step>
      Implement endpoints
    </step>
  </subagent>
  <subagent name="frontend">
    <step>
      Create UI components
    </step>
    <step>
      Integrate with API
    </step>
  </subagent>
</phase>
```

## Use Cases

### 1. Plan Inspection

Examine the structure of a plan before execution:

```typescript
const xml = serialize(tree)
console.log('Plan structure:')
console.log(xml)

// Proceed with execution
await executePlan(...)
```

### 2. Debugging Rendering

Verify that your JSX components are rendering correctly:

```typescript
import { renderPlan } from 'smithers'

// renderPlan internally uses serialize
const xml = await renderPlan(<MyAgent />)
console.log('Rendered plan:', xml)
```

### 3. Plan Storage

Save plans to disk for later analysis or versioning:

```typescript
import { writeFileSync } from 'fs'

const xml = serialize(tree)
writeFileSync('plan-v1.xml', xml, 'utf-8')
```

### 4. Testing

Assert on serialized output in tests:

```typescript
import { test, expect } from 'bun:test'

test('renders phase correctly', async () => {
  const root = createRoot()
  const tree = await root.render(
    <Phase name="test">Content</Phase>
  )

  const xml = serialize(tree)
  expect(xml).toContain('<phase name="test">')
  expect(xml).toContain('Content')
})
```

## Related APIs

- [`renderPlan`](./render-plan.mdx): Renders JSX to XML (uses serialize internally)
- [`executePlan`](./execute-plan.mdx): Executes a rendered plan
- [`SmithersNode`](./types.mdx#smithersnode): The node type that serialize operates on

## Notes

- **Output-only function**: `serialize` does not modify the node tree.
- **No validation**: `serialize` does not validate the tree structure; it serializes whatever it receives.
- **Performance**: Serialization is fast and synchronous, typically completing in single-digit milliseconds even for complex trees.
- **Not reversible**: XML cannot be deserialized back to a SmithersNode tree. Serialization is one-way for plan display only.
- **Callback exclusion**: Functions like `onFinished` are excluded because they can't be meaningfully represented in XML.
