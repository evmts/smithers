---
title: renderPlan
description: Render a React element to XML plan without execution
---

# renderPlan

Render a Smithers component to its XML plan representation without executing it.

## Signature

```typescript
function renderPlan(element: ReactElement): Promise<string>
```

## Parameters

<ParamField path="element" type="ReactElement" required>
  The React element to render. Typically your agent component with props.
</ParamField>

## Returns

<ParamField path="Promise<string>">
  A promise that resolves to the XML string representation of the plan.
</ParamField>

## Usage

```tsx
import { renderPlan, Claude, Phase, Step } from 'smithers'

function MyAgent({ topic }) {
  return (
    <Claude tools={[webSearch]}>
      <Phase name="research">
        <Step>Search for {topic}</Step>
        <Step>Collect sources</Step>
      </Phase>
    </Claude>
  )
}

// Render to XML
const xml = await renderPlan(<MyAgent topic="AI safety" />)
console.log(xml)
```

Output:

```xml
<claude tools="web-search">
  <phase name="research">
    <step>Search for AI safety</step>
    <step>Collect sources</step>
  </phase>
</claude>
```

## Use Cases

### Testing

Write tests that verify plan output without making API calls:

```tsx
import { renderPlan } from 'smithers'
import { expect, test } from 'bun:test'

test('renders correct research plan', async () => {
  const xml = await renderPlan(<ResearchAgent topic="quantum computing" />)

  expect(xml).toContain('<phase name="research">')
  expect(xml).toContain('quantum computing')
  expect(xml).toContain('tools="web-search"')
})

test('includes constraints when strict mode', async () => {
  const xml = await renderPlan(<ReviewAgent strict={true} />)

  expect(xml).toContain('<constraints>')
  expect(xml).toContain('strict')
})
```

### Debugging

Inspect the plan to debug component issues:

```tsx
async function debugAgent() {
  const xml = await renderPlan(
    <MyAgent
      files={['a.ts', 'b.ts']}
      options={{ strict: true }}
    />
  )

  console.log('Plan preview:')
  console.log(xml)

  // Verify structure before execution
  if (!xml.includes('<phase name="validate">')) {
    throw new Error('Missing validation phase!')
  }
}
```

### Plan Comparison

Compare plans across different configurations:

```tsx
async function comparePlans() {
  const basicPlan = await renderPlan(<Agent mode="basic" />)
  const advancedPlan = await renderPlan(<Agent mode="advanced" />)

  console.log('Basic plan length:', basicPlan.length)
  console.log('Advanced plan length:', advancedPlan.length)

  // Advanced should have more phases
  const basicPhases = (basicPlan.match(/<phase/g) || []).length
  const advancedPhases = (advancedPlan.match(/<phase/g) || []).length

  console.log(`Basic: ${basicPhases} phases, Advanced: ${advancedPhases} phases`)
}
```

### Documentation Generation

Generate example plans for documentation:

```tsx
import { writeFile } from 'fs/promises'

async function generateDocs() {
  const examples = [
    { name: 'basic', element: <BasicAgent /> },
    { name: 'advanced', element: <AdvancedAgent /> },
    { name: 'parallel', element: <ParallelAgent topics={['A', 'B']} /> },
  ]

  for (const { name, element } of examples) {
    const xml = await renderPlan(element)
    await writeFile(`docs/examples/${name}.xml`, xml)
  }
}
```

## Notes

<Warning>
  `renderPlan` only shows the **initial** render. For stateful agents, subsequent frames depend on Claude's responses updating state. To see all phases, you need to use `executePlan`.
</Warning>

## Related

<CardGroup cols={2}>
  <Card title="executePlan" icon="play" href="/api-reference/execute-plan">
    Execute the full Ralph Wiggum loop
  </Card>
  <Card title="smithers plan" icon="terminal" href="/cli/plan">
    CLI command for plan preview
  </Card>
</CardGroup>
