---
title: Lifecycle Hooks
description: Mount, unmount, and async-safe state hooks
---

# Lifecycle Hooks

```tsx
import { useMount, useUnmount, useMountedState } from "smithers-orchestrator";

function MyComponent() {
  const isMounted = useMountedState();
  
  useMount(() => {
    fetchData().then(result => {
      if (isMounted()) db.state.set("data", result);
    });
  });
  
  useUnmount(() => cleanup());
}
```

## useMount

Runs once on mount. Uses idempotency guard for strict mode.

```tsx
function useMount(fn: () => void): void
```

## useUnmount

Cleanup on unmount. Uses ref to avoid stale closures.

```tsx
function useUnmount(fn: () => void): void
```

```tsx
// ❌ Stale closure
useEffect(() => {
  const id = startTask();
  return () => completeTask(id); // May be stale
}, []);

// ✅ Always current
const idRef = useRef<string | null>(null);
useMount(() => { idRef.current = startTask(); });
useUnmount(() => { completeTask(idRef.current); });
```

## useMountedState

Returns getter for current mount state. Prevents setState on unmounted components.

```tsx
function useMountedState(): () => boolean
```

## useEffectOnValueChange

Runs effect when value changes with idempotency. Won't run twice for same value.

```tsx
function useEffectOnValueChange<T>(
  value: T,
  effect: () => void | (() => void),
  deps?: DependencyList
): void
```

```tsx
const ralphCount = useRalphCount();
useEffectOnValueChange(ralphCount, () => executeTask());
```

## When to Use

| Hook | Use Case |
|------|----------|
| `useMount` | One-time setup on mount |
| `useUnmount` | Cleanup needing latest state |
| `useMountedState` | Async operations setting state |
| `useEffectOnValueChange` | Re-run on value change with idempotency |
| `useEffect` | Standard React effect behavior |

## Related

<CardGroup cols={2}>
  <Card title="Smithers Hooks" icon="hook" href="/api-reference/hooks" />
  <Card title="Reactive Hooks" icon="bolt" href="/api-reference/reactive-hooks" />
</CardGroup>
