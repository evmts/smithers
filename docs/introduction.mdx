---
title: Introduction
description: Let your agent write agents
---

# Smithers

**Let your agent write agents.**

```tsx
#!/usr/bin/env bun
import { createSmithersRoot, createSmithersDB, SmithersProvider, Claude } from "smithers-orchestrator";

const db = createSmithersDB({ path: ".smithers/demo" });
const executionId = db.execution.start("Demo", "demo.tsx");

function Demo() {
  return (
    <SmithersProvider db={db} executionId={executionId} maxIterations={5}>
      <Claude model="sonnet" onFinished={(r) => console.log(r.output)}>
        Fix the failing tests in this repository.
      </Claude>
    </SmithersProvider>
  );
}

const root = createSmithersRoot();
await root.mount(Demo);
await db.close();
```

Run it:

```bash
bun demo.tsx
```

Smithers is a JSX framework for coding agents. You write the plan; Claude executes it. The plan evolves reactively based on agent output.

---

## Core Idea

You program the **plan**, not the agents.

| Other Frameworks | Smithers |
|------------------|----------|
| `agent.do_step_1()` | `<Phase name="implement">` |
| `agent.do_step_2()` | `<Step name="code">` |
| `if failed: retry()` | `<Claude>Fix it</Claude>` |

The plan is declarative. Like Terraform, not AWS SDK.

Each iteration:
1. Render JSX → execution plan
2. Execute runnable agents
3. Agent output updates state
4. State change triggers re-render
5. Loop until done

Ralph is the event loop. React handles the diffing.

---

## Why JSX?

LLMs are trained on XML. The nested tagged structure matches how they think. Claude generates valid Smithers workflows naturally.

JSX gives you:
- Composition and reuse
- Version control diffs that make sense
- Agent-generated code you can review

---

## Quick Examples

### Sequential Phases

```tsx
<SmithersProvider db={db} executionId={executionId} maxIterations={10}>
  <Phase name="implement">
    <Step name="code">
      <Claude>Implement the feature</Claude>
    </Step>
    <Step name="test">
      <Claude>Write tests</Claude>
    </Step>
  </Phase>
  <Phase name="review">
    <Claude>Review the changes</Claude>
  </Phase>
</SmithersProvider>
```

### Parallel Agents

```tsx
<Parallel>
  <Claude>Fix auth</Claude>
  <Claude>Fix database</Claude>
  <Claude>Fix API</Claude>
</Parallel>
```

### Structured Output

```tsx
const ReviewSchema = z.object({
  approved: z.boolean(),
  issues: z.array(z.string()),
});

<Claude schema={ReviewSchema}>
  Review the PR.
</Claude>
// result.structured: { approved: boolean, issues: string[] }
```

### Worktree Isolation

```tsx
<Worktree branch="feature-auth" cleanup>
  <Claude>Implement authentication</Claude>
</Worktree>
```

---

## Persistence

State lives in SQLite. Survives restarts.

```tsx
// Set state
db.state.set("phase", "review");

// Get state
const phase = db.state.get("phase");

// Resume after crash
const incomplete = db.execution.findIncomplete();
if (incomplete) {
  executionId = incomplete.id;
}
```

---

## Observability

The JSX is the observability. What you write is what gets logged.

```tsx
<Phase name="deploy">
  <Step name="build" status="complete">...</Step>
  <Step name="test" status="running">...</Step>
</Phase>
```

SQLite stores every frame. Use JJ or git to rewind.

---

## Roadmap

**North Star: SuperSmithers** — A meta-agent that watches your agents and rewrites their code to optimize. The architecture supports it. Not yet implemented.

---

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/quickstart">
    Your first workflow
  </Card>
  <Card title="Components" icon="cube" href="/components/claude">
    API reference
  </Card>
  <Card title="Examples" icon="code" href="/examples/hello-world">
    Production workflows
  </Card>
  <Card title="Concepts" icon="lightbulb" href="/concepts/ralph-wiggum-loop">
    How it works
  </Card>
</CardGroup>
