---
title: Introduction
description: JSX workflow engine for coding agents—phases, parallelism, and persistent state
---

# Welcome to Smithers

**JSX workflow engine for coding agents—phases, parallelism, and persistent state for long-running repo automation.**

Run CI recovery, PR finalization, stacked merges, release smoketests, and review processing as resumable workflows—not fragile scripts.

```jsx
import { SmithersProvider, Phase, Claude, Parallel } from 'smithers-orchestrator'
import { createSmithersDB } from 'smithers-orchestrator/db'

function FeatureWorkflow({ featureSpec }) {
  const db = createSmithersDB({ path: '.smithers/workflow.db' })
  const executionId = db.execution.start('feature-workflow', 'feature.tsx')

  return (
    <SmithersProvider db={db} executionId={executionId} maxIterations={20}>
      <Phase name="Plan">
        <Claude model="sonnet">
          Analyze the codebase and create an implementation plan for: {featureSpec}
        </Claude>
      </Phase>

      <Phase name="Implement">
        <Parallel>
          <Claude model="sonnet">Implement the backend changes from the plan</Claude>
          <Claude model="sonnet">Implement the frontend changes from the plan</Claude>
        </Parallel>
      </Phase>

      <Phase name="Verify">
        <Claude
          model="sonnet"
          onFinished={(result) => {
            if (result.output.includes('All tests pass')) {
              db.state.set('status', 'complete')
            }
          }}
        >
          Run the test suite. If any tests fail, fix them and re-run.
        </Claude>
      </Phase>
    </SmithersProvider>
  )
}
```

## Why Smithers?

### The Problem

Simple Ralph loops work great for basic iteration. But as workflows grow complex:
- Multi-phase orchestration becomes hard to manage
- Parallel agents need coordination
- Plans live in prompts, not reviewable code
- Manual orchestration doesn't scale

### The Solution

- **Agent-native syntax** - Easy for Claude Code to generate, easy for humans to review
- **Sophisticated Ralph loops** - Multi-phase, parallel agents, conditional branches
- **Composable components** - Build complex workflows from simple pieces
- **One syntax for humans and agents** - You can read it, Claude can generate it, Git can version it

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/quickstart">
    Get up and running in 2 minutes
  </Card>
  <Card title="Durable Ralphing" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the execution model
  </Card>
  <Card title="Components" icon="cube" href="/components/claude">
    Explore the component API
  </Card>
  <Card title="Examples" icon="code" href="/examples/hello-world">
    Copy-paste starter workflows
  </Card>
</CardGroup>

## Key Features

### Sophisticated Ralph Loops

Smithers lets you build complex Ralph loops with structure:

```tsx
<SmithersProvider db={db} executionId={executionId} maxIterations={50}>
  <Phase name="Implement">
    <Parallel>
      <Claude model="sonnet">Fix auth module</Claude>
      <Claude model="sonnet">Fix database module</Claude>
    </Parallel>
  </Phase>

  <Phase name="Verify">
    <Claude
      model="sonnet"
      onFinished={(result) => {
        if (result.output.includes("All tests pass")) {
          db.state.set("complete", "true");
        }
      }}
    >
      Run tests. If any fail, go back to Implement phase.
    </Claude>
  </Phase>
</SmithersProvider>
```

**What Smithers adds:**
- Multi-phase workflows with conditional transitions
- Parallel agent execution with coordination
- Composable, reusable components
- Optional persistence for long-running workflows

### Claude Component

The core agent component that executes Claude with full tool access:

```tsx
<Claude
  model="sonnet"           // opus | sonnet | haiku
  maxTurns={10}            // Limit agentic loops
  permissionMode="acceptEdits"  // Auto-accept file edits
  onFinished={(result) => handleResult(result)}
>
  Your prompt here
</Claude>
```

### Structured Output with Zod

Get typed, validated responses with automatic retry:

```tsx
const UserSchema = z.object({
  name: z.string(),
  email: z.string().email(),
})

<Claude schema={UserSchema} schemaRetries={2}>
  Extract user info from: John Doe (john@example.com)
</Claude>
// result.structured: { name: string, email: string }
```

### Database Persistence (Flight Recorder)

Every run persists in SQLite - your workflow's audit trail:

```tsx
// Set state (survives restarts)
db.state.set("phase", "review");

// Resume incomplete executions
const incomplete = db.execution.findIncomplete();
if (incomplete) {
  executionId = incomplete.id; // Pick up where you left off
}

// Query history - see how state evolved
const history = db.state.getHistory("phase");
```

### MCP Tool Integration

Give Claude access to external tools via Model Context Protocol:

```tsx
<Claude model="sonnet" maxTurns={5}>
  <Sqlite path="./analytics.db">
    The database contains user_events and sessions tables.
  </Sqlite>
  What are the top 10 most common user actions this week?
</Claude>
```

## Component Naming

| Component | Purpose |
|-----------|---------|
| `<SmithersProvider>` | Root orchestration context (required) |
| `<Subagent>` | Named grouping boundary for organizing agent tasks |
| `<Smithers>` | Nested orchestration - spawns planner + executor |

See component docs for details. `<Smithers>` is the only component that spawns a separate planning model.

## How It Works

```
┌──────────┐    ┌─────────┐    ┌──────────────────┐
│  Render  │───▶│ Execute │───▶│ Update State     │
│   JSX    │    │ Claude  │    │ (onFinished)     │
└──────────┘    └─────────┘    └──────────────────┘
     ▲                                   │
     │                                   │
     └───────────────────────────────────┘
              (re-render on state change)
```

1. **Render**: Your JSX components render
2. **Execute**: `<Claude>` nodes execute via Claude Code CLI
3. **Update**: `onFinished` callbacks update state (persisted to SQLite)
4. **Re-render**: State changes trigger reactive updates
5. **Loop**: Repeat until no pending agents remain

## Installation

```bash
bun add smithers-orchestrator
```

## FAQ

### Is this actually React? Do I need to run a UI?

No UI. React is a component model + markup-like syntax. People already use it to render to non-DOM targets (CLI, PDFs, native). Smithers renders to **execution**, not DOM.

### Why not YAML/JSON for workflows?

Because you want:
- Composition and reuse
- Version control diffs that make sense
- Something your coding agent can generate AND you can review like normal code

### How does this relate to Ralphing?

Ralphing is the outer loop (iterate until verification passes). Smithers gives it structure, persistence, and inspectability.

## Next Steps

<CardGroup cols={2}>
  <Card title="Quick Start" icon="play" href="/quickstart">
    Create your first Smithers workflow
  </Card>
  <Card title="Durable Ralphing" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the core execution model
  </Card>
</CardGroup>
