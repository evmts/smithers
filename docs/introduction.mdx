---
title: Introduction
description: Let your agent write agents - React-style orchestration for durable Ralph loops
---

# Welcome to Smithers

**Let your agent write agents.**

Smithers is React-style orchestration your coding agent can generate, then run safely as durable Ralph loops. Built for long-running "night shift" sessions with persistence, history, and restart-safe execution.

```tsx
<SmithersProvider db={db}>
  <Phase name="Plan">
    <Claude model="sonnet">Analyze the codebase and create a plan</Claude>
  </Phase>
  <Phase name="Execute">
    <Parallel>
      <Claude>Implement feature A</Claude>
      <Claude>Implement feature B</Claude>
    </Parallel>
  </Phase>
  <Phase name="Verify">
    <Claude>Run tests and fix any failures</Claude>
  </Phase>
</SmithersProvider>
```

## Why Smithers?

### The Problem

Simple Ralph loops work great for basic iteration. But as workflows grow complex:
- Multi-phase orchestration becomes hard to manage
- Parallel agents need coordination
- Plans live in prompts, not reviewable code
- Manual orchestration doesn't scale

### The Solution

- **Agent-native syntax** - Easy for Claude Code to generate, easy for humans to review
- **Sophisticated Ralph loops** - Multi-phase, parallel agents, conditional branches
- **Composable components** - Build complex workflows from simple pieces
- **One syntax for humans and agents** - You can read it, Claude can generate it, Git can version it

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/quickstart">
    Get up and running in 2 minutes
  </Card>
  <Card title="Durable Ralphing" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the execution model
  </Card>
  <Card title="Components" icon="cube" href="/components/claude">
    Explore the component API
  </Card>
  <Card title="Examples" icon="code" href="/examples/hello-world">
    Copy-paste starter workflows
  </Card>
</CardGroup>

## Key Features

### Sophisticated Ralph Loops

Smithers lets you build complex Ralph loops with structure:

```tsx
<SmithersProvider db={db} executionId={executionId} maxIterations={50}>
  <Phase name="Implement">
    <Parallel>
      <Claude model="sonnet">Fix auth module</Claude>
      <Claude model="sonnet">Fix database module</Claude>
    </Parallel>
  </Phase>

  <Phase name="Verify">
    <Claude
      model="sonnet"
      onFinished={(result) => {
        if (result.output.includes("All tests pass")) {
          db.state.set("complete", "true");
        }
      }}
    >
      Run tests. If any fail, go back to Implement phase.
    </Claude>
  </Phase>
</SmithersProvider>
```

**What Smithers adds:**
- Multi-phase workflows with conditional transitions
- Parallel agent execution with coordination
- Composable, reusable components
- Optional persistence for long-running workflows

### Claude Component

The core agent component that executes Claude with full tool access:

```tsx
<Claude
  model="sonnet"           // opus | sonnet | haiku
  maxTurns={10}            // Limit agentic loops
  permissionMode="acceptEdits"  // Auto-accept file edits
  onFinished={(result) => handleResult(result)}
>
  Your prompt here
</Claude>
```

### Structured Output with Zod

Get typed, validated responses with automatic retry:

```tsx
const UserSchema = z.object({
  name: z.string(),
  email: z.string().email(),
})

<Claude schema={UserSchema} schemaRetries={2}>
  Extract user info from: John Doe (john@example.com)
</Claude>
// result.structured: { name: string, email: string }
```

### Database Persistence (Flight Recorder)

Every run persists in SQLite - your workflow's audit trail:

```tsx
// Set state (survives restarts)
await db.state.set("phase", "review");

// Resume incomplete executions
const incomplete = await db.execution.findIncomplete();
if (incomplete) {
  executionId = incomplete.id; // Pick up where you left off
}

// Query history - see how state evolved
const history = await db.state.getHistory("phase");
```

### MCP Tool Integration

Give Claude access to external tools via Model Context Protocol:

```tsx
<Claude model="sonnet" maxTurns={5}>
  <Sqlite path="./analytics.db">
    The database contains user_events and sessions tables.
  </Sqlite>
  What are the top 10 most common user actions this week?
</Claude>
```

## How It Works

```
┌──────────┐    ┌─────────┐    ┌──────────────────┐
│  Render  │───▶│ Execute │───▶│ Update State     │
│   JSX    │    │ Claude  │    │ (onFinished)     │
└──────────┘    └─────────┘    └──────────────────┘
     ▲                                   │
     │                                   │
     └───────────────────────────────────┘
              (re-render on state change)
```

1. **Render**: Your JSX components render
2. **Execute**: `<Claude>` nodes execute via Claude Code CLI
3. **Update**: `onFinished` callbacks update state (persisted to SQLite)
4. **Re-render**: State changes trigger reactive updates
5. **Loop**: Repeat until no pending agents remain

## Installation

```bash
bun add smithers-orchestrator
```

## FAQ

### Is this actually React? Do I need to run a UI?

No UI. React is a component model + markup-like syntax. People already use it to render to non-DOM targets (CLI, PDFs, native). Smithers renders to **execution**, not DOM.

### Why not YAML/JSON for workflows?

Because you want:
- Composition and reuse
- Version control diffs that make sense
- Something your coding agent can generate AND you can review like normal code

### How does this relate to Ralphing?

Ralphing is the outer loop (iterate until verification passes). Smithers gives it structure, persistence, and inspectability.

## Next Steps

<CardGroup cols={2}>
  <Card title="Quick Start" icon="play" href="/quickstart">
    Create your first Smithers workflow
  </Card>
  <Card title="Durable Ralphing" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the core execution model
  </Card>
</CardGroup>
