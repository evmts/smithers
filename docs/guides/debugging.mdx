---
title: Debugging
description: How to debug execution issues, understand the Ralph Wiggum loop, and avoid common pitfalls
---

# Debugging

This guide covers techniques for debugging Smithers agents and understanding execution behavior.

## Verbose Mode

Enable verbose logging to see what happens in each frame:

```bash
smithers run agent.tsx --verbose
```

Or programmatically:

```tsx
import { executePlan } from '@evmts/smithers'

const result = await executePlan(<MyAgent />, {
  verbose: true,
  onPlan: (xml, frame) => {
    console.log(`=== Frame ${frame} Plan ===`)
    console.log(xml)
  },
  onFrame: (frameResult) => {
    console.log(`Frame ${frameResult.frame}:`)
    console.log(`  Executed: ${frameResult.executedNodes.join(', ')}`)
    console.log(`  State changed: ${frameResult.stateChanges}`)
    console.log(`  Duration: ${frameResult.duration}ms`)
  },
})
```

### Verbose Output Explained

```
[Frame 1] Rendering element...
[Frame 1] Raw tree structure:
[Frame 1]   root.type: ROOT
[Frame 1]   root.children.length: 1
[Frame 1]   first child.type: render-frame
[Frame 1] Found 1 pending nodes
[Frame 1]   - claude, onFinished: [Function], _execution: none
[Frame 1] Executing claude node
[Frame 1] onFinished called, marking stateChanged=true
[Frame 1] Callback invoked, waiting for state updates to propagate
[Frame 2] Rendering element...
...
```

Key things to look for:
- **pending nodes**: Which nodes are ready to execute
- **onFinished called**: State transitions happening
- **stateChanged**: Whether re-render will occur

## Understanding the Ralph Wiggum Loop

### Frame-by-Frame Execution

Each frame follows this sequence:

1. **Render**: JSX components render to SmithersNode tree
2. **Find Pending**: Locate nodes without `_execution` status
3. **Execute**: Run pending Claude/Subagent nodes
4. **Callback**: `onFinished` triggers state updates
5. **Re-render**: If state changed, loop continues

### Why No Progress?

If your agent seems stuck, check these:

```tsx
// PROBLEM: onFinished never changes state
<Claude onFinished={(result) => console.log(result)}>
  Do something
</Claude>

// SOLUTION: Update state to progress
<Claude onFinished={(result) => setPhase('next')}>
  Do something
</Claude>
```

### Why Infinite Loop?

If you hit max frames, check for:

```tsx
// PROBLEM: State keeps changing but renders same node
function BadAgent() {
  const [count, setCount] = useState(0)

  return (
    <Claude onFinished={() => setCount(count + 1)}>
      Count: {count}  {/* Content changes but Claude keeps running */}
    </Claude>
  )
}

// SOLUTION: Add completion condition
function GoodAgent() {
  const [count, setCount] = useState(0)

  if (count >= 5) return null  // Exit condition

  return (
    <Claude onFinished={() => setCount(count + 1)}>
      Count: {count}
    </Claude>
  )
}
```

## Common Pitfalls and Solutions

### Stale Closures (Not an issue in Solid)

In React, stale closures were a common issue. In Solid, signals always return the current value, so this class of bugs is largely eliminated.

### Node Re-execution on Content Change

**Problem**: Node re-executes when content changes unexpectedly

```tsx
// BUG: timestamp changes every render, causing re-execution
function BadAgent() {
  return (
    <Claude>
      Current time: {new Date().toISOString()}
      Do task...
    </Claude>
  )
}
```

**Solution**: Keep prompt content stable

```tsx
// CORRECT: Static content
function GoodAgent(props) {
  return (
    <Claude>
      Task: {props.task}
    </Claude>
  )
}
```

### Missing Exit Condition

**Problem**: No condition to stop the loop

```tsx
// BUG: Loops forever
import { createSignal } from 'solid-js'

function ForeverAgent() {
  const [phase, setPhase] = createSignal('start')

  return () => {
    const p = phase()
    if (p === 'start') {
      return <Claude onFinished={() => setPhase('process')}>Init</Claude>
    }
    if (p === 'process') {
      return <Claude onFinished={() => setPhase('start')}>Process</Claude>
    }
    // Never returns null or exits
  }
}
```

**Solution**: Always have a terminal state

```tsx
// CORRECT: Has exit condition
function FiniteAgent() {
  const [phase, setPhase] = createSignal('start')

  return () => {
    const p = phase()
    if (p === 'start') {
      return <Claude onFinished={() => setPhase('process')}>Init</Claude>
    }
    if (p === 'process') {
      return <Claude onFinished={() => setPhase('done')}>Process</Claude>
    }

    return null  // Exit when phase === 'done'
  }
}
```

### onError Not Handling Failures

**Problem**: Errors propagate and crash execution

```tsx
// BUG: Error crashes the agent
function FragileAgent() {
  return (
    <Claude>
      This might fail...
    </Claude>
  )
}
```

**Solution**: Handle errors with onError

```tsx
import { createSignal } from 'solid-js'

// CORRECT: Error is handled
function RobustAgent() {
  const [error, setError] = createSignal(null)

  return () => {
    const e = error()
    if (e) {
      return (
        <Claude>
          Previous operation failed: {e.message}
          Attempting recovery...
        </Claude>
      )
    }

    return (
      <Claude onError={setError}>
        This might fail...
      </Claude>
    )
  }
}
```

## Inspecting Execution State

### Adding Debug Logging

```tsx
import { createStore } from 'solid-js/store'

function DebugAgent() {
  const [state, setState] = createStore({ phase: 'init', data: {} })

  // Log on every execution
  console.log('[DebugAgent] Executing:', state)

  return () => {
    if (state.phase === 'process') {
      return (
        <Claude
          onFinished={(result) => {
            console.log('[DebugAgent] onFinished:', result)
            setState('phase', 'done')
          }}
          onError={(error) => {
            console.error('[DebugAgent] onError:', error)
          }}
        >
          Process data...
        </Claude>
      )
    }

    return null
  }
}
```

### Using Solid DevTools

Smithers uses SolidJS, so Solid DevTools work:

1. Install Solid DevTools browser extension (for Desktop app/web)
2. Run your agent
3. Inspect component tree and signals

### Store Debugging

Monitor store changes:

```tsx
import { createStore } from 'solid-js/store'
import { createEffect } from 'solid-js'

const [state, setState] = createStore({ phase: 'init' })

createEffect(() => {
  console.log('State changed:', state)
})
```

## Frame Inspection

### Capturing Frame History

```tsx
const result = await executePlan(<MyAgent />, {
  onFrame: (frame) => {
    // Log each frame
    console.log(JSON.stringify(frame, null, 2))
  },
})

// After execution
console.log('Total frames:', result.frames)
console.log('Frame history:', result.history)
```

### Frame History Structure

```typescript
interface FrameResult {
  frame: number            // Frame number (1-indexed)
  plan: string             // XML plan for this frame
  executedNodes: string[]  // Types of nodes executed
  stateChanges: boolean    // Whether state changed
  duration: number         // Frame execution time (ms)
}
```

## Troubleshooting Guide

### Agent Not Starting

```bash
# Check for errors
smithers plan agent.tsx --verbose

# Verify JSX syntax
bun run build
```

**Common causes**:
- Missing export (component must be exported)
- JSX syntax errors
- Missing dependencies

### Agent Runs Forever

1. Check max frames setting:
```bash
smithers run agent.tsx --max-frames 10
```

2. Add logging to trace state:
```tsx
console.log('Current phase:', phase)
```

3. Verify exit conditions exist

### Agent Stops Early

1. Check for unhandled errors:
```tsx
<Claude onError={(e) => console.error('Error:', e)}>
```

2. Verify state transitions:
```tsx
console.log('Before setPhase:', phase)
setPhase('next')
```

### Unexpected Re-execution

1. Check content stability:
```tsx
// Add to see content hash changes
console.log('Prompt:', JSON.stringify(children))
```

2. Verify no accidental prop changes

### MCP Server Connection Issues

```bash
# List connected servers
smithers run agent.tsx --verbose | grep "MCP"

# Check server configuration
cat mcp.json
```

## Testing in Isolation

### Render Without Execution

```tsx
import { renderPlan } from '@evmts/smithers'

// Just render, don't execute
const xml = await renderPlan(<MyAgent initialState="test" />)
console.log(xml)
```

### Mock Mode

```bash
# Enable mock mode (no API calls)
SMITHERS_MOCK_MODE=true smithers run agent.tsx
```

```tsx
// Or in code
process.env.SMITHERS_MOCK_MODE = 'true'

await executePlan(<MyAgent />)
```

### Custom Timeout

```tsx
await executePlan(<MyAgent />, {
  timeout: 60000,  // 1 minute
  maxFrames: 20,   // Stop after 20 frames
})
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Advanced Patterns" icon="code" href="/guides/advanced-patterns">
    Complex state and workflow patterns
  </Card>
  <Card title="Ralph Wiggum Loop" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Deep dive into execution model
  </Card>
</CardGroup>
