---
title: "Error Handling"
description: "Patterns for robust error recovery in Smithers agents"
---

# Error Handling

This guide covers strategies for handling errors gracefully in Smithers agents, from basic error callbacks to sophisticated retry and recovery mechanisms.

## Error Types

Smithers agents can encounter several types of errors:

| Error Type | Description | Recovery Strategy |
|------------|-------------|-------------------|
| **API Errors** | Rate limits, auth failures, network issues | Retry with exponential backoff |
| **Execution Errors** | Tool failures, invalid output, timeouts | Fallback to simpler approach |
| **State Errors** | Invalid transitions, corrupted state | Reset to known good state |
| **Logic Errors** | Infinite loops, maxFrames exceeded | Escape hatch with Stop component |

## Basic Error Handling

### The onError Callback

Every `<Claude>` component accepts an `onError` callback:

```tsx
function Agent() {
  return (
    <Claude
      onError={(error) => {
        console.error('Agent failed:', error)
        // Handle error
      }}
    >
      Perform task
    </Claude>
  )
}
```

### ExecutionError Context

The `ExecutionError` provides rich context about what failed:

```tsx
<Claude
  onError={(error: ExecutionError) => {
    console.log('Error:', error.message)
    console.log('Node path:', error.nodePath)
    console.log('Frame:', error.frame)
    console.log('Original cause:', error.cause)
  }}
>
  Task
</Claude>
```

## Retry Strategies

### Automatic Retries

Configure automatic retries for transient failures:

```tsx
<Claude
  retries={{
    maxRetries: 3,
    initialDelay: 1000,      // 1 second
    maxDelay: 10000,         // 10 seconds
    backoffMultiplier: 2,    // Exponential backoff
  }}
>
  API call that might fail
</Claude>
```

### Retry with State Reset

For state-dependent failures, reset state before retrying:

```tsx
function Agent() {
  const { data, clearData } = useStore()

  return (
    <Claude
      onError={(error) => {
        console.error('Attempt failed, resetting state')
        clearData()
      }}
      retries={{ maxRetries: 2 }}
    >
      Process {JSON.stringify(data)}
    </Claude>
  )
}
```

### Conditional Retry

Only retry certain types of errors:

```tsx
<Claude
  onError={(error) => {
    if (error.message.includes('rate_limit')) {
      // Will be retried automatically
      console.log('Rate limited, will retry')
    } else {
      // Non-retryable error, abort
      throw error
    }
  }}
  retries={{ maxRetries: 3 }}
>
  Task
</Claude>
```

## Fallback Patterns

### Graceful Degradation

Try a sophisticated approach first, fall back to simpler methods:

```tsx
function Agent() {
  const { phase, setPhase } = useStore()

  if (phase === 'advanced') {
    return (
      <Claude
        tools={[complexTool]}
        onError={() => setPhase('simple')}
      >
        Use advanced analysis
      </Claude>
    )
  }

  if (phase === 'simple') {
    return (
      <Claude onError={() => setPhase('failed')}>
        Use basic analysis (no tools)
      </Claude>
    )
  }

  if (phase === 'failed') {
    return <Stop reason="All approaches failed" />
  }

  return null
}
```

### Alternative Agent

Switch to a backup agent on failure:

```tsx
function RobustAgent() {
  const { agent, switchAgent } = useStore()

  if (agent === 'primary') {
    return (
      <Claude
        model="claude-opus-4-5"
        onError={() => switchAgent('fallback')}
      >
        Complex reasoning task
      </Claude>
    )
  }

  if (agent === 'fallback') {
    return (
      <Claude
        model="claude-sonnet-4-5"
        onError={() => switchAgent('minimal')}
      >
        Simpler approach
      </Claude>
    )
  }

  return <Claude>Minimal safe task</Claude>
}
```

## Error Recovery Workflows

### Two-Phase Recovery

Detect failure, then recover in next phase:

```tsx
function TwoPhaseRecovery() {
  const { phase, error, setError, nextPhase } = useStore()

  if (phase === 'attempt') {
    return (
      <Claude
        onFinished={nextPhase}
        onError={(err) => {
          setError(err)
          nextPhase()
        }}
      >
        Primary task
      </Claude>
    )
  }

  if (phase === 'recovery') {
    if (!error) {
      return null // Success, done
    }

    return (
      <Claude>
        Previous task failed with: {error.message}
        Recover by: [recovery strategy]
      </Claude>
    )
  }

  return null
}
```

### Supervisor Agent

A supervisor monitors and recovers from worker failures:

```tsx
function SupervisedWorkflow() {
  const { workers, failedWorkers, retryWorker } = useStore()

  // Worker agents
  const activeWorkers = workers
    .filter(w => w.status === 'active')
    .map(worker => (
      <Subagent key={worker.id} name={worker.id}>
        <Claude
          onError={(error) => {
            console.error(`Worker ${worker.id} failed`)
            failedWorkers.add(worker.id)
          }}
        >
          {worker.task}
        </Claude>
      </Subagent>
    ))

  // Supervisor monitors and recovers
  if (failedWorkers.size > 0) {
    return (
      <Claude onFinished={() => {
        failedWorkers.forEach(id => retryWorker(id))
      }}>
        <Persona role="supervisor">
          You monitor worker agents and decide recovery strategies.
        </Persona>

        Failed workers: {Array.from(failedWorkers).join(', ')}
        Determine why they failed and how to recover.
      </Claude>
    )
  }

  return <>{activeWorkers}</>
}
```

## Rate Limit Handling

### ClaudeProvider Rate Limiting

Use `<ClaudeProvider>` for automatic rate limit management:

```tsx
import { ClaudeProvider } from '@evmts/smithers'

function App() {
  return (
    <ClaudeProvider
      rateLimit={{
        requestsPerMinute: 50,
        inputTokensPerMinute: 40000,
        outputTokensPerMinute: 8000,
      }}
      onRateLimited={(info) => {
        console.log(`Rate limited: ${info.limitType}`)
        console.log(`Retry after: ${info.retryAfter}ms`)
      }}
    >
      <MyAgent />
    </ClaudeProvider>
  )
}
```

### Manual Rate Limit Handling

Handle rate limits with custom retry logic:

```tsx
<Claude
  retries={{
    maxRetries: 5,
    initialDelay: 5000, // Start with 5s delay for rate limits
    maxDelay: 60000,    // Max 1 minute
    backoffMultiplier: 2,
  }}
  onError={(error) => {
    if (error.message.includes('rate_limit_exceeded')) {
      console.log('Rate limited, exponential backoff will retry')
    }
  }}
>
  API-heavy task
</Claude>
```

## Timeout Handling

### Per-Agent Timeout

Set timeouts on individual agents:

```tsx
<Claude
  timeout={30000} // 30 seconds
  onError={(error) => {
    if (error.message.includes('timeout')) {
      console.error('Agent took too long')
      // Retry with lower complexity or abort
    }
  }}
>
  Time-consuming task
</Claude>
```

### Global Execution Timeout

Set a timeout for the entire execution:

```tsx
await executePlan(<MyAgent />, {
  timeout: 300000, // 5 minutes total
  onError: (error) => {
    console.error('Execution timed out')
  }
})
```

## Human-in-the-Loop Error Recovery

### Manual Intervention

Let humans decide recovery strategy:

```tsx
function AgentWithManualRecovery() {
  const { phase, error, setRecoveryAction } = useStore()

  if (error && phase === 'recovery-prompt') {
    return (
      <Human
        message={`Agent failed: ${error.message}. How should we proceed?`}
        onApprove={(action) => {
          setRecoveryAction(action)
        }}
      >
        Options:
        1. Retry with same approach
        2. Try alternative method
        3. Abort and report failure
      </Human>
    )
  }

  // ... rest of workflow
}
```

### Approval for Risky Recovery

Require approval before potentially destructive recovery:

```tsx
<Claude
  onError={(error) => {
    if (error.severity === 'critical') {
      // Pause for human approval
      setPhase('recovery-approval')
    }
  }}
>
  Critical operation
</Claude>

{phase === 'recovery-approval' && (
  <Human
    message="Critical error occurred. Approve recovery action?"
    onApprove={() => setPhase('recovery')}
    onReject={() => setPhase('aborted')}
  >
    Recovery will: {recoveryPlan}
  </Human>
)}
```

## Validation and Prevention

### Pre-Execution Validation

Validate inputs before execution:

```tsx
function ValidatedAgent({ data }) {
  // Validate before rendering Claude
  if (!data || data.length === 0) {
    return <Stop reason="No data to process" />
  }

  if (data.some(item => !item.id)) {
    return <Stop reason="Data missing required 'id' field" />
  }

  return <Claude>Process {data.length} items</Claude>
}
```

### Output Validation

Verify agent output matches expectations:

```tsx
<Claude
  onFinished={(result) => {
    try {
      const output = JSON.parse(result.output)

      // Validate structure
      if (!output.tasks || !Array.isArray(output.tasks)) {
        throw new Error('Invalid output structure')
      }

      // Validate each task
      output.tasks.forEach((task, i) => {
        if (!task.name || !task.status) {
          throw new Error(`Task ${i} missing required fields`)
        }
      })

      // Output valid, proceed
      setTasks(output.tasks)
      nextPhase()
    } catch (error) {
      console.error('Output validation failed:', error)
      // Retry with more explicit instructions
      setPhase('retry-with-examples')
    }
  }}
>
  <OutputFormat schema={taskSchema}>
    Generate task list
  </OutputFormat>
</Claude>
```

### Circuit Breaker

Prevent repeated failures from consuming resources:

```tsx
function CircuitBreakerAgent() {
  const failures = useRef(0)
  const lastFailure = useRef<number>(0)

  if (failures.current >= 3) {
    const timeSinceFailure = Date.now() - lastFailure.current
    if (timeSinceFailure < 60000) { // 1 minute
      return <Stop reason="Circuit breaker open: too many failures" />
    }
    // Reset after cooldown
    failures.current = 0
  }

  return (
    <Claude
      onError={() => {
        failures.current++
        lastFailure.current = Date.now()
      }}
      onFinished={() => {
        failures.current = 0 // Reset on success
      }}
    >
      Task
    </Claude>
  )
}
```

## Debugging Errors

### Verbose Error Logging

Enable detailed logging in development:

```tsx
const isDev = process.env.NODE_ENV === 'development'

<Claude
  onError={(error) => {
    if (isDev) {
      console.error('Full error context:', {
        message: error.message,
        stack: error.stack,
        nodePath: error.nodePath,
        frame: error.frame,
        cause: error.cause,
      })
    } else {
      console.error('Agent failed:', error.message)
    }
  }}
>
  Task
</Claude>
```

### Error Telemetry

Send errors to monitoring service:

```tsx
<Claude
  onError={async (error) => {
    await logError({
      service: 'smithers-agent',
      error: error.message,
      context: {
        nodePath: error.nodePath,
        frame: error.frame,
      },
      timestamp: Date.now(),
    })
  }}
>
  Task
</Claude>
```

### TUI for Visual Debugging

Use the TUI to visualize errors in the execution tree:

```bash
smithers run agent.tsx --tui
```

Navigate to failed nodes to inspect error details.

## Best Practices

### 1. Fail Fast for Fatal Errors

Don't retry unrecoverable errors:

```tsx
<Claude
  onError={(error) => {
    // Fatal errors
    if (error.message.includes('invalid_api_key')) {
      throw error // Don't retry, needs human intervention
    }

    // Transient errors
    if (error.message.includes('rate_limit')) {
      // Will be retried automatically
      return
    }
  }}
  retries={{ maxRetries: 3 }}
>
  Task
</Claude>
```

### 2. Provide Context in Error Messages

```tsx
// ✅ Good: Specific, actionable
throw new Error(`Failed to parse agent output as JSON: ${output.slice(0, 100)}...`)

// ❌ Bad: Vague
throw new Error('Parse failed')
```

### 3. Use Structured Error Responses

```tsx
interface ErrorResult {
  success: false
  error: string
  recoverable: boolean
  suggestedAction?: string
}

<Claude
  onFinished={(result) => {
    const output: ErrorResult = JSON.parse(result.output)

    if (!output.success) {
      if (output.recoverable) {
        // Attempt recovery
        handleRecovery(output.suggestedAction)
      } else {
        // Abort
        throw new Error(output.error)
      }
    }
  }}
>
  Task
</Claude>
```

### 4. Log Errors for Post-Mortem

```tsx
const errorLog: Array<{ timestamp: number; error: Error; context: any }> = []

<Claude
  onError={(error) => {
    errorLog.push({
      timestamp: Date.now(),
      error,
      context: { phase, data },
    })
  }}
>
  Task
</Claude>
```

### 5. Test Error Paths

```tsx
test('Agent handles API failure gracefully', async () => {
  // Force error condition
  process.env.ANTHROPIC_API_KEY = 'invalid'

  let errorHandled = false

  function Agent() {
    return (
      <Claude onError={() => { errorHandled = true }}>
        Task
      </Claude>
    )
  }

  await executePlan(<Agent />)

  expect(errorHandled).toBe(true)
})
```

## Error Recovery Checklist

When designing error handling for your agent:

- [ ] Identify all possible failure modes
- [ ] Determine which errors are transient vs fatal
- [ ] Configure appropriate retry strategies
- [ ] Implement fallback mechanisms for critical paths
- [ ] Add validation for inputs and outputs
- [ ] Log errors with sufficient context
- [ ] Test error paths in development
- [ ] Monitor error rates in production
- [ ] Document recovery procedures for operators

## Related Guides

- [Testing](/guides/testing) - Testing error scenarios
- [Debugging](/guides/debugging) - Debugging failed executions
- [Rate Limiting](/guides/rate-limiting) - Managing API rate limits
- [State Management](/concepts/state-management) - Managing state during errors
