---
title: Migration Guide
description: Migrating from other agent frameworks and upgrading between Smithers versions
---

# Migration Guide

This guide covers migrating to Smithers from other frameworks and upgrading between versions.

## Migrating from LangChain

LangChain uses chains and agents with tool bindings. Here's how to translate common patterns.

### Simple Chain to Smithers

**LangChain:**
```python
from langchain import LLMChain, PromptTemplate

template = """You are a helpful assistant.
Question: {question}
Answer:"""

chain = LLMChain(llm=llm, prompt=PromptTemplate.from_template(template))
result = chain.run(question="What is React?")
```

**Smithers:**
```tsx
function Assistant({ question }) {
  return (
    <Claude>
      <Persona role="helpful assistant" />
      Question: {question}
    </Claude>
  )
}

const result = await executePlan(<Assistant question="What is React?" />)
```

### Tool-Using Agent

**LangChain:**
```python
from langchain.agents import initialize_agent, Tool

tools = [
    Tool(name="Search", func=search, description="Search the web"),
    Tool(name="Calculator", func=calc, description="Do math"),
]

agent = initialize_agent(tools, llm, agent="zero-shot-react-description")
result = agent.run("What is 25 * 4?")
```

**Smithers:**
```tsx
const searchTool = {
  name: 'search',
  description: 'Search the web',
  execute: async (args) => search(args.query),
}

const calcTool = {
  name: 'calculator',
  description: 'Do math',
  execute: async (args) => calc(args.expression),
}

function ToolAgent({ task }) {
  return (
    <Claude tools={[searchTool, calcTool]}>
      {task}
    </Claude>
  )
}

const result = await executePlan(<ToolAgent task="What is 25 * 4?" />)
```

### Sequential Chain

**LangChain:**
```python
from langchain import SequentialChain

research_chain = LLMChain(llm=llm, prompt=research_prompt, output_key="research")
write_chain = LLMChain(llm=llm, prompt=write_prompt, output_key="report")

chain = SequentialChain(
    chains=[research_chain, write_chain],
    input_variables=["topic"]
)
```

**Smithers:**
```tsx
function SequentialAgent({ topic }) {
  const [phase, setPhase] = useState('research')
  const [research, setResearch] = useState(null)

  if (phase === 'research') {
    return (
      <Claude onFinished={(data) => { setResearch(data); setPhase('write') }}>
        Research this topic: {topic}
      </Claude>
    )
  }

  return (
    <Claude>
      Write a report based on: {JSON.stringify(research)}
    </Claude>
  )
}
```

## Migrating from AutoGPT / BabyAGI

### Task Queue Pattern

**AutoGPT/BabyAGI style:**
```python
task_queue = ["Research topic", "Write outline", "Draft content"]
while task_queue:
    task = task_queue.pop(0)
    result = agent.execute(task)
    new_tasks = agent.create_tasks(result)
    task_queue.extend(new_tasks)
```

**Smithers:**
```tsx
const useTaskStore = create((set, get) => ({
  tasks: ['Research topic', 'Write outline', 'Draft content'],
  completed: [],

  completeTask: (task, result) => {
    set({
      tasks: get().tasks.filter(t => t !== task),
      completed: [...get().completed, { task, result }],
    })
  },

  addTasks: (newTasks) => {
    set({ tasks: [...get().tasks, ...newTasks] })
  },
}))

function TaskAgent() {
  const { tasks, completed, completeTask, addTasks } = useTaskStore()

  if (tasks.length === 0) {
    return null // Done
  }

  const currentTask = tasks[0]

  return (
    <Claude
      onFinished={(result) => {
        completeTask(currentTask, result)
        if (result.newTasks) {
          addTasks(result.newTasks)
        }
      }}
    >
      <Phase name="execute">
        Execute task: {currentTask}

        Completed so far:
        {completed.map(c => `- ${c.task}: ${c.result.summary}`).join('\n')}
      </Phase>

      <OutputFormat schema={{
        result: 'string',
        summary: 'string',
        newTasks: 'string[] (optional)'
      }} />
    </Claude>
  )
}
```

## Migrating from CrewAI

### Multi-Agent Crew

**CrewAI:**
```python
from crewai import Agent, Task, Crew

researcher = Agent(
    role='Researcher',
    goal='Find information',
    tools=[search_tool]
)

writer = Agent(
    role='Writer',
    goal='Write content'
)

crew = Crew(agents=[researcher, writer], tasks=[...])
result = crew.kickoff()
```

**Smithers:**
```tsx
function Researcher({ onComplete }) {
  return (
    <Claude tools={[searchTool]} onFinished={onComplete}>
      <Persona role="Researcher">
        You find and analyze information.
      </Persona>
      <Phase name="research">
        Search and compile findings.
      </Phase>
    </Claude>
  )
}

function Writer({ research, onComplete }) {
  return (
    <Claude onFinished={onComplete}>
      <Persona role="Writer">
        You write clear, engaging content.
      </Persona>
      <Phase name="write">
        Create content based on: {JSON.stringify(research)}
      </Phase>
    </Claude>
  )
}

function Crew({ topic }) {
  const [phase, setPhase] = useState('research')
  const [research, setResearch] = useState(null)

  if (phase === 'research') {
    return (
      <Researcher onComplete={(data) => {
        setResearch(data)
        setPhase('write')
      }} />
    )
  }

  return <Writer research={research} onComplete={() => setPhase('done')} />
}
```

## Migrating from Semantic Kernel

### Skill to Component

**Semantic Kernel:**
```csharp
[SKFunction("Summarize text")]
public async Task<string> Summarize(string text) {
    return await kernel.InvokePromptAsync($"Summarize: {text}");
}
```

**Smithers:**
```tsx
function Summarizer({ text, onComplete }) {
  return (
    <Claude onFinished={onComplete}>
      <Phase name="summarize">
        Summarize: {text}
      </Phase>
    </Claude>
  )
}

// Usage - composable like React components
function MyAgent({ document }) {
  const [summary, setSummary] = useState(null)

  if (!summary) {
    return <Summarizer text={document} onComplete={setSummary} />
  }

  return (
    <Claude>
      Based on this summary: {summary}
      Take next action...
    </Claude>
  )
}
```

## Key Concept Mappings

| Other Frameworks | Smithers Equivalent |
|-----------------|---------------------|
| Chain / Pipeline | Multi-phase component with state |
| Agent | `<Claude>` component with tools |
| Tool | Tool object with `execute` function |
| Memory | Zustand store or React state |
| Prompt Template | JSX with interpolation |
| Sequential Chain | `useState` phase transitions |
| Parallel Agents | `<Subagent>` components |
| Agent Executor | Ralph Wiggum loop (`executePlan`) |

## Upgrading Between Versions

### v0.x to v1.0 (Planned)

When Smithers reaches 1.0, migration will include:

**Import Changes:**
```tsx
// Before (0.x)
import { Claude, renderPlan, executePlan } from 'plue-jsx'

// After (1.0)
import { Claude, renderPlan, executePlan } from 'smithers'
```

**Package Name:**
```bash
# Before
npm install plue-jsx

# After
npm install smithers
```

### Breaking Changes to Watch

Keep these areas in mind for future upgrades:

1. **Component Props**: New required props or changed defaults
2. **Store API**: State management patterns
3. **Tool Format**: Tool definition structure
4. **Output Parsing**: How `onFinished` receives data

### Upgrade Checklist

When upgrading Smithers versions:

1. Read the changelog for breaking changes
2. Update import statements if package renamed
3. Run tests to catch breaking changes
4. Check for deprecated APIs in console warnings
5. Update tool definitions if format changed

### Version Compatibility

```json
{
  "dependencies": {
    "smithers": "^0.5.0",
    "zustand": "^4.0.0",
    "react": "^19.0.0"
  }
}
```

**React Version**: Smithers requires React 19+ for synchronous rendering features.

**Zustand Version**: Zustand 4.x is recommended for TypeScript support.

## Quick Reference: Framework Translation

### Prompt Construction

```tsx
// String interpolation
<Claude>
  You are a {role}. Your task is to {task}.
  Input: {JSON.stringify(input)}
</Claude>

// Conditional sections
<Claude>
  {context && <Phase name="context">{context}</Phase>}
  <Phase name="main">{mainPrompt}</Phase>
</Claude>

// Dynamic lists
<Claude>
  <Phase name="review">
    {files.map(f => <Step key={f}>Review: {f}</Step>)}
  </Phase>
</Claude>
```

### State Management

```tsx
// Simple state
const [phase, setPhase] = useState('start')

// Complex state with Zustand
const useStore = create((set, get) => ({
  phase: 'start',
  data: {},
  setPhase: (phase) => set({ phase }),
  addData: (key, value) => set((s) => ({
    data: { ...s.data, [key]: value }
  })),
}))
```

### Tool Definition

```tsx
const myTool = {
  name: 'toolName',
  description: 'What the tool does',
  input_schema: {
    type: 'object',
    properties: {
      param1: { type: 'string', description: 'First param' },
    },
    required: ['param1'],
  },
  execute: async (args) => {
    // Tool implementation
    return result
  },
}

// Usage
<Claude tools={[myTool]}>
  Use the tool to complete the task.
</Claude>
```

### Error Handling

```tsx
<Claude
  onFinished={(result) => handleSuccess(result)}
  onError={(error) => handleError(error)}
>
  Task that might fail
</Claude>
```

## Getting Help

- **Discord**: Join our community for migration support
- **GitHub Issues**: Report migration problems
- **Examples**: Check `/examples` for real-world patterns

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/quickstart">
    Start fresh with Smithers
  </Card>
  <Card title="Examples" icon="code" href="/examples/code-review">
    See complete examples
  </Card>
</CardGroup>
