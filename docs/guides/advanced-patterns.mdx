---
title: Advanced Patterns
description: Complex state management, multi-phase workflows, and parallel coordination
---

# Advanced Patterns

This guide covers advanced patterns for building sophisticated agent workflows with Smithers.

## Complex State Management with Zustand

### Hierarchical State Machines

For agents with complex flows, model explicit state machines:

```tsx
import { create } from 'zustand'

interface WorkflowState {
  // State machine
  status: 'idle' | 'planning' | 'executing' | 'reviewing' | 'complete' | 'error'

  // Data at each stage
  plan: Plan | null
  results: Result[]
  review: Review | null
  error: Error | null

  // Transitions
  startPlanning: () => void
  finishPlanning: (plan: Plan) => void
  addResult: (result: Result) => void
  finishReview: (review: Review) => void
  handleError: (error: Error) => void
  reset: () => void
}

const useWorkflowStore = create<WorkflowState>((set, get) => ({
  status: 'idle',
  plan: null,
  results: [],
  review: null,
  error: null,

  startPlanning: () => set({ status: 'planning' }),

  finishPlanning: (plan) => set({
    plan,
    status: 'executing',
  }),

  addResult: (result) => {
    const results = [...get().results, result]
    const allDone = results.length === get().plan!.tasks.length
    set({
      results,
      status: allDone ? 'reviewing' : 'executing',
    })
  },

  finishReview: (review) => set({
    review,
    status: 'complete',
  }),

  handleError: (error) => set({
    error,
    status: 'error',
  }),

  reset: () => set({
    status: 'idle',
    plan: null,
    results: [],
    review: null,
    error: null,
  }),
}))
```

### Atomic State Updates

When multiple parallel agents update state, use functional updates to avoid race conditions:

```tsx
const useStore = create((set, get) => ({
  results: {} as Record<string, Result>,

  // CORRECT: Functional update with latest state
  addResult: (key: string, result: Result) =>
    set((state) => ({
      results: { ...state.results, [key]: result }
    })),
}))

// Usage in parallel subagents
function ParallelProcessor({ items }) {
  const { addResult } = useStore()

  return (
    <>
      {items.map(item => (
        <Subagent key={item.id} name={`processor-${item.id}`}>
          <Claude onFinished={(result) => addResult(item.id, result)}>
            Process: {item.data}
          </Claude>
        </Subagent>
      ))}
    </>
  )
}
```

### Computed State with Selectors

Derive computed values efficiently:

```tsx
const useStore = create((set, get) => ({
  tasks: [] as Task[],
  completedIds: new Set<string>(),

  addTask: (task: Task) =>
    set((s) => ({ tasks: [...s.tasks, task] })),

  completeTask: (id: string) =>
    set((s) => ({ completedIds: new Set([...s.completedIds, id]) })),
}))

// Selectors
const selectPendingTasks = (state: ReturnType<typeof useStore.getState>) =>
  state.tasks.filter(t => !state.completedIds.has(t.id))

const selectProgress = (state: ReturnType<typeof useStore.getState>) =>
  state.tasks.length > 0
    ? state.completedIds.size / state.tasks.length
    : 0

// Usage
function TaskAgent() {
  const pendingTasks = useStore(selectPendingTasks)
  const progress = useStore(selectProgress)

  if (pendingTasks.length === 0) {
    return <div>All tasks complete! Progress: {progress * 100}%</div>
  }

  return (
    <Claude onFinished={() => completeTask(pendingTasks[0].id)}>
      Working on: {pendingTasks[0].description}
    </Claude>
  )
}
```

## Multi-Phase Workflows with Conditional Logic

### Branching Workflows

Create workflows that branch based on intermediate results:

```tsx
function BranchingAgent({ input }) {
  const [phase, setPhase] = useState<'analyze' | 'simple' | 'complex' | 'done'>('analyze')
  const [complexity, setComplexity] = useState<string | null>(null)
  const [result, setResult] = useState(null)

  if (phase === 'analyze') {
    return (
      <Claude
        onFinished={(analysis) => {
          setComplexity(analysis.complexity)
          setPhase(analysis.complexity === 'high' ? 'complex' : 'simple')
        }}
      >
        <Phase name="analyze">
          Analyze this input and determine complexity (low/medium/high):
          {JSON.stringify(input)}
        </Phase>
        <OutputFormat schema={{ complexity: 'low | medium | high', reason: 'string' }} />
      </Claude>
    )
  }

  if (phase === 'simple') {
    return (
      <Claude onFinished={(r) => { setResult(r); setPhase('done') }}>
        <Phase name="simple-processing">
          Apply simple processing to: {JSON.stringify(input)}
        </Phase>
      </Claude>
    )
  }

  if (phase === 'complex') {
    return (
      <Claude
        tools={[analysisTools, transformTools]}
        onFinished={(r) => { setResult(r); setPhase('done') }}
      >
        <Phase name="complex-processing">
          <Step>Deep analysis of input structure</Step>
          <Step>Apply complex transformations</Step>
          <Step>Validate output quality</Step>
        </Phase>
        Input: {JSON.stringify(input)}
      </Claude>
    )
  }

  return null
}
```

### Retry with Backoff

Implement retry logic for transient failures:

```tsx
const useRetryStore = create((set, get) => ({
  attempt: 0,
  maxAttempts: 3,
  lastError: null as Error | null,
  result: null,

  recordFailure: (error: Error) => {
    const attempt = get().attempt + 1
    set({
      attempt,
      lastError: error,
      // Exponential backoff could be added here
    })
  },

  recordSuccess: (result: any) => set({ result }),
}))

function RetryableAgent({ task }) {
  const { attempt, maxAttempts, lastError, result, recordFailure, recordSuccess } = useRetryStore()

  if (result) {
    return null // Done
  }

  if (attempt >= maxAttempts) {
    return (
      <Claude>
        <Phase name="failure-report">
          Task failed after {maxAttempts} attempts.
          Last error: {lastError?.message}
          Please investigate manually.
        </Phase>
      </Claude>
    )
  }

  return (
    <Claude
      onFinished={recordSuccess}
      onError={(error) => {
        console.log(`Attempt ${attempt + 1} failed:`, error.message)
        recordFailure(error)
      }}
    >
      <Phase name="execute">
        {attempt > 0 && (
          <Step>Previous attempt failed: {lastError?.message}. Trying again...</Step>
        )}
        <Step>Execute task: {task}</Step>
      </Phase>
    </Claude>
  )
}
```

### Conditional Phase Skipping

Skip phases based on input or previous results:

```tsx
function ConditionalWorkflow({ config }) {
  const [phase, setPhase] = useState('init')
  const [data, setData] = useState({})

  // Skip validation if config.skipValidation is true
  const phases = [
    'init',
    ...(config.skipValidation ? [] : ['validate']),
    'process',
    ...(config.generateReport ? ['report'] : []),
    'done'
  ]

  const currentIndex = phases.indexOf(phase)
  const nextPhase = () => setPhase(phases[currentIndex + 1] || 'done')

  if (phase === 'init') {
    return (
      <Claude onFinished={(d) => { setData(d); nextPhase() }}>
        Initialize workflow with config: {JSON.stringify(config)}
      </Claude>
    )
  }

  if (phase === 'validate') {
    return (
      <Claude onFinished={(d) => { setData({...data, ...d}); nextPhase() }}>
        Validate data: {JSON.stringify(data)}
      </Claude>
    )
  }

  // ... other phases

  return null
}
```

## Parallel Subagent Coordination

### Fan-Out / Fan-In Pattern

Process items in parallel, then aggregate:

```tsx
function FanOutFanIn({ items }) {
  const [phase, setPhase] = useState<'process' | 'aggregate' | 'done'>('process')
  const [results, setResults] = useState<Record<string, any>>({})

  const addResult = (id: string, result: any) => {
    setResults(prev => {
      const updated = { ...prev, [id]: result }
      // Check if all items processed
      if (Object.keys(updated).length === items.length) {
        setPhase('aggregate')
      }
      return updated
    })
  }

  if (phase === 'process') {
    return (
      <>
        {items.map(item => (
          <Subagent key={item.id} name={`worker-${item.id}`}>
            <Claude onFinished={(r) => addResult(item.id, r)}>
              Process item: {JSON.stringify(item)}
            </Claude>
          </Subagent>
        ))}
      </>
    )
  }

  if (phase === 'aggregate') {
    return (
      <Claude onFinished={() => setPhase('done')}>
        <Phase name="aggregate">
          Combine these results into a final output:
          {JSON.stringify(results, null, 2)}
        </Phase>
      </Claude>
    )
  }

  return null
}
```

### Dependency-Ordered Parallel Execution

Execute tasks respecting dependencies:

```tsx
interface Task {
  id: string
  dependencies: string[]
  description: string
}

function DependencyAwareExecutor({ tasks }: { tasks: Task[] }) {
  const [completed, setCompleted] = useState<Set<string>>(new Set())
  const [results, setResults] = useState<Record<string, any>>({})

  const completeTask = (id: string, result: any) => {
    setCompleted(prev => new Set([...prev, id]))
    setResults(prev => ({ ...prev, [id]: result }))
  }

  // Find tasks ready to execute (all dependencies met)
  const readyTasks = tasks.filter(
    task =>
      !completed.has(task.id) &&
      task.dependencies.every(dep => completed.has(dep))
  )

  if (readyTasks.length === 0) {
    if (completed.size === tasks.length) {
      return null // All done
    }
    // Circular dependency or error
    return (
      <Claude>
        <Phase name="error">
          Cannot proceed - possible circular dependency detected.
          Completed: {[...completed].join(', ')}
          Remaining: {tasks.filter(t => !completed.has(t.id)).map(t => t.id).join(', ')}
        </Phase>
      </Claude>
    )
  }

  return (
    <>
      {readyTasks.map(task => (
        <Subagent key={task.id} name={`task-${task.id}`}>
          <Claude onFinished={(r) => completeTask(task.id, r)}>
            <Phase name={`execute-${task.id}`}>
              Task: {task.description}

              {task.dependencies.length > 0 && (
                <>
                  Dependency results:
                  {task.dependencies.map(dep => (
                    <Step key={dep}>{dep}: {JSON.stringify(results[dep])}</Step>
                  ))}
                </>
              )}
            </Phase>
          </Claude>
        </Subagent>
      ))}
    </>
  )
}
```

### Rate-Limited Parallel Execution

Control concurrency to avoid overwhelming resources:

```tsx
function RateLimitedExecutor({ items, maxConcurrent = 3 }) {
  const [pending, setPending] = useState(items)
  const [running, setRunning] = useState<string[]>([])
  const [completed, setCompleted] = useState<Record<string, any>>({})

  const startItem = (id: string) => {
    setRunning(prev => [...prev, id])
    setPending(prev => prev.filter(i => i.id !== id))
  }

  const finishItem = (id: string, result: any) => {
    setRunning(prev => prev.filter(i => i !== id))
    setCompleted(prev => ({ ...prev, [id]: result }))
  }

  // Calculate how many more we can start
  const availableSlots = maxConcurrent - running.length
  const toStart = pending.slice(0, availableSlots)

  if (toStart.length === 0 && running.length === 0) {
    return null // All done
  }

  // Start new items
  toStart.forEach(item => startItem(item.id))

  return (
    <>
      {running.map(id => {
        const item = items.find(i => i.id === id)!
        return (
          <Subagent key={id} name={`worker-${id}`}>
            <Claude onFinished={(r) => finishItem(id, r)}>
              Process: {JSON.stringify(item)}
            </Claude>
          </Subagent>
        )
      })}
    </>
  )
}
```

## Error Handling Strategies

### Graceful Degradation

Continue with partial results when some operations fail:

```tsx
function GracefulAgent({ sources }) {
  const [results, setResults] = useState<Record<string, any>>({})
  const [errors, setErrors] = useState<Record<string, Error>>({})
  const [phase, setPhase] = useState<'fetch' | 'process' | 'done'>('fetch')

  const recordResult = (id: string, result: any) => {
    setResults(prev => ({ ...prev, [id]: result }))
    checkCompletion()
  }

  const recordError = (id: string, error: Error) => {
    setErrors(prev => ({ ...prev, [id]: error }))
    checkCompletion()
  }

  const checkCompletion = () => {
    const total = Object.keys(results).length + Object.keys(errors).length
    if (total === sources.length) {
      setPhase('process')
    }
  }

  if (phase === 'fetch') {
    return (
      <>
        {sources.map(source => (
          <Subagent key={source.id} name={`fetch-${source.id}`}>
            <Claude
              onFinished={(r) => recordResult(source.id, r)}
              onError={(e) => recordError(source.id, e)}
            >
              Fetch data from: {source.url}
            </Claude>
          </Subagent>
        ))}
      </>
    )
  }

  if (phase === 'process') {
    const successCount = Object.keys(results).length
    const failCount = Object.keys(errors).length

    return (
      <Claude onFinished={() => setPhase('done')}>
        <Phase name="process-with-partial">
          Process available data ({successCount} succeeded, {failCount} failed):

          Successful results:
          {JSON.stringify(results, null, 2)}

          {failCount > 0 && (
            <>
              Note: These sources failed and were skipped:
              {Object.entries(errors).map(([id, err]) => (
                <Step key={id}>{id}: {err.message}</Step>
              ))}
            </>
          )}
        </Phase>
      </Claude>
    )
  }

  return null
}
```

### Circuit Breaker Pattern

Stop attempting operations after repeated failures:

```tsx
const useCircuitBreaker = create((set, get) => ({
  failures: 0,
  threshold: 3,
  isOpen: false,
  lastFailure: null as Date | null,
  cooldownMs: 30000,

  recordFailure: () => {
    const failures = get().failures + 1
    set({
      failures,
      lastFailure: new Date(),
      isOpen: failures >= get().threshold,
    })
  },

  recordSuccess: () => set({ failures: 0, isOpen: false }),

  canAttempt: () => {
    const { isOpen, lastFailure, cooldownMs } = get()
    if (!isOpen) return true
    if (!lastFailure) return true
    return Date.now() - lastFailure.getTime() > cooldownMs
  },
}))

function CircuitBreakerAgent({ operation }) {
  const { isOpen, canAttempt, recordFailure, recordSuccess } = useCircuitBreaker()

  if (isOpen && !canAttempt()) {
    return (
      <Claude>
        <Phase name="circuit-open">
          Circuit breaker is open due to repeated failures.
          Waiting for cooldown before retrying.
          Please check the service status manually.
        </Phase>
      </Claude>
    )
  }

  return (
    <Claude
      onFinished={recordSuccess}
      onError={recordFailure}
    >
      <Phase name="execute">
        Execute operation: {operation}
      </Phase>
    </Claude>
  )
}
```

## Testing Patterns

### Unit Testing Components

Test individual agent components in isolation:

```tsx
import { describe, test, expect } from 'bun:test'
import { renderPlan } from '@evmts/smithers'

describe('MyAgent', () => {
  test('renders correct plan for initial state', async () => {
    const plan = await renderPlan(<MyAgent initialPhase="research" />)

    expect(plan).toContain('<phase name="research">')
    expect(plan).toContain('Search for sources')
  })

  test('renders different plan based on props', async () => {
    const strictPlan = await renderPlan(<MyAgent strict={true} />)
    const normalPlan = await renderPlan(<MyAgent strict={false} />)

    expect(strictPlan).toContain('Apply strict validation')
    expect(normalPlan).not.toContain('Apply strict validation')
  })
})
```

### Integration Testing with Mock Mode

Test full execution flows with mock responses:

```tsx
import { describe, test, expect, beforeEach } from 'bun:test'
import { executePlan } from '@evmts/smithers'

// Enable mock mode
process.env.SMITHERS_MOCK_MODE = 'true'

describe('MyAgent integration', () => {
  test('completes multi-phase workflow', async () => {
    const phases: string[] = []

    // Track phase transitions
    const TrackedAgent = () => {
      const { phase } = useStore()
      phases.push(phase)
      return <MyAgent />
    }

    await executePlan(<TrackedAgent />)

    expect(phases).toContain('research')
    expect(phases).toContain('analyze')
    expect(phases).toContain('report')
  })

  test('handles errors gracefully', async () => {
    let errorHandled = false

    const ErrorAgent = () => (
      <Claude onError={() => { errorHandled = true }}>
        This will fail intentionally for testing.
      </Claude>
    )

    await executePlan(<ErrorAgent />)
    expect(errorHandled).toBe(true)
  })
})
```

### Testing State Transitions

Verify correct state machine behavior:

```tsx
describe('Workflow state machine', () => {
  test('transitions through phases correctly', async () => {
    const stateHistory: string[] = []

    // Subscribe to state changes
    useWorkflowStore.subscribe(
      (state) => stateHistory.push(state.status)
    )

    await executePlan(<WorkflowAgent task="test" />)

    expect(stateHistory).toEqual([
      'planning',
      'executing',
      'reviewing',
      'complete'
    ])
  })

  test('handles errors and transitions to error state', async () => {
    const { handleError, status } = useWorkflowStore.getState()

    handleError(new Error('Test error'))

    expect(useWorkflowStore.getState().status).toBe('error')
    expect(useWorkflowStore.getState().error?.message).toBe('Test error')
  })
})
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Debugging" icon="bug" href="/guides/debugging">
    Learn to debug execution issues
  </Card>
  <Card title="Ralph Wiggum Loop" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the execution model
  </Card>
</CardGroup>
