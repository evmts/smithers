---
title: "Testing Agents"
description: "Best practices for testing Smithers agents"
---

# Testing Agents

This guide covers strategies and patterns for testing Smithers agents, from unit tests to integration tests.

## Overview

Testing AI agents presents unique challenges:
- Non-deterministic responses from LLMs
- External API dependencies
- Long execution times
- Complex state transitions

Smithers provides **mock mode** to address these challenges, enabling fast, deterministic tests.

## Mock Mode

Mock mode bypasses real Claude API calls and returns predictable responses based on prompt content.

### Enabling Mock Mode

```tsx
import { executePlan } from '@evmts/smithers'

// Option 1: Pass mockMode option
await executePlan(<MyAgent />, { mockMode: true })

// Option 2: Set environment variable
process.env.SMITHERS_MOCK = 'true'
await executePlan(<MyAgent />)
```

### How Mock Mode Works

The mock executor analyzes your prompt and generates responses:

1. **Structured Output Detection**: If prompt contains JSON schema or `OutputFormat`, returns matching JSON
2. **Plan Detection**: If prompt mentions phases/steps, returns acknowledgment
3. **Default Response**: Returns a generic success message

### Example Mock Response

```tsx
// Prompt with JSON schema
<Claude>
  <OutputFormat schema={{ issues: z.array(z.object({ severity: z.string() })) }}>
    Return code review issues
  </OutputFormat>
</Claude>

// Mock response (automatically generated)
{
  issues: [
    { severity: "high", file: "mock.ts", line: 1, message: "Mock issue" }
  ]
}
```

## Unit Testing Components

Test individual components in isolation using Bun's test framework.

### Basic Component Test

```tsx
import { test, expect } from 'bun:test'
import { executePlan, Claude } from '@evmts/smithers'

test('HelloWorld component renders and executes', async () => {
  function HelloWorld() {
    return <Claude>Say hello</Claude>
  }

  const result = await executePlan(<HelloWorld />, { mockMode: true })

  expect(result.frames).toBe(1)
  expect(result.output).toBeDefined()
  expect(result.totalDuration).toBeGreaterThan(0)
})
```

### Testing Callbacks

```tsx
test('onFinished callback is called with result', async () => {
  let callbackResult: any = null

  function Agent() {
    return (
      <Claude onFinished={(result) => { callbackResult = result }}>
        Analyze data
      </Claude>
    )
  }

  await executePlan(<Agent />, { mockMode: true })

  expect(callbackResult).toBeDefined()
  expect(callbackResult.output).toBeDefined()
})
```

### Testing State Transitions

```tsx
import { create } from 'zustand'

test('Multi-phase agent transitions through states', async () => {
  const useStore = create((set) => ({
    phase: 'start',
    nextPhase: () => set({ phase: 'end' })
  }))

  function Agent() {
    const { phase, nextPhase } = useStore()

    if (phase === 'start') {
      return <Claude onFinished={nextPhase}>Phase 1</Claude>
    }
    return null
  }

  const result = await executePlan(<Agent />, { mockMode: true })

  expect(result.frames).toBe(2) // start + end
  expect(useStore.getState().phase).toBe('end')
})
```

## Integration Testing

Test complete workflows with multiple agents and phases.

### Multi-Agent Test

```tsx
test('Dev team workflow completes all stages', async () => {
  const useDevTeam = create((set) => ({
    stage: 'planning',
    plan: null,
    nextStage: () => {
      const stages = ['planning', 'implementing', 'reviewing', 'done']
      set((state) => {
        const idx = stages.indexOf(state.stage)
        return { stage: stages[idx + 1] || 'done' }
      })
    }
  }))

  function DevTeam() {
    const { stage, nextStage } = useDevTeam()

    switch (stage) {
      case 'planning':
        return <Claude onFinished={nextStage}>Plan task</Claude>
      case 'implementing':
        return <Claude onFinished={nextStage}>Implement</Claude>
      case 'reviewing':
        return <Claude onFinished={nextStage}>Review</Claude>
      default:
        return null
    }
  }

  const result = await executePlan(<DevTeam />, { mockMode: true })

  expect(result.frames).toBe(4) // All 3 stages + done
  expect(useDevTeam.getState().stage).toBe('done')
})
```

### Parallel Execution Test

```tsx
test('Parallel subagents execute concurrently', async () => {
  const completions: string[] = []

  function ParallelResearch({ topics }: { topics: string[] }) {
    return (
      <>
        {topics.map(topic => (
          <Subagent key={topic} name={topic} parallel>
            <Claude onFinished={() => completions.push(topic)}>
              Research {topic}
            </Claude>
          </Subagent>
        ))}
      </>
    )
  }

  await executePlan(
    <ParallelResearch topics={['AI', 'ML', 'NLP']} />,
    { mockMode: true }
  )

  expect(completions).toHaveLength(3)
  expect(completions).toContain('AI')
  expect(completions).toContain('ML')
  expect(completions).toContain('NLP')
})
```

## Testing with Real API

For critical workflows, test against the real Claude API.

### API Test Setup

```tsx
import { test, expect, beforeAll } from 'bun:test'

beforeAll(() => {
  if (!process.env.ANTHROPIC_API_KEY) {
    throw new Error('ANTHROPIC_API_KEY required for API tests')
  }
})

test('Real API: Code review returns structured output', async () => {
  function CodeReviewer() {
    return (
      <Claude tools={[{ name: 'read', /* ... */ }]}>
        <OutputFormat schema={{ issues: z.array(z.object({
          severity: z.string(),
          message: z.string()
        })) }}>
          Review code for issues
        </OutputFormat>
      </Claude>
    )
  }

  const result = await executePlan(<CodeReviewer />, { mockMode: false })

  expect(result.output).toBeDefined()
  const parsed = JSON.parse(result.output)
  expect(Array.isArray(parsed.issues)).toBe(true)
}, { timeout: 30000 }) // Longer timeout for API calls
```

### Conditional API Tests

```tsx
const shouldRunApiTests = process.env.RUN_API_TESTS === 'true'

test.skipIf(!shouldRunApiTests)('Real API test', async () => {
  // Test implementation
})
```

## Testing Error Handling

### Testing Error Recovery

```tsx
test('Agent handles execution errors gracefully', async () => {
  let errorCaught: Error | null = null

  function FailingAgent() {
    return (
      <Claude
        onError={(error) => { errorCaught = error }}
      >
        fail intentionally
      </Claude>
    )
  }

  await executePlan(<FailingAgent />, { mockMode: true })

  expect(errorCaught).toBeDefined()
  expect(errorCaught?.message).toContain('intentionally')
})
```

### Testing Retries

```tsx
test('Agent retries on failure', async () => {
  let attempts = 0

  function RetryAgent() {
    return (
      <Claude
        retries={{ maxRetries: 3, initialDelay: 100 }}
        onFinished={() => attempts++}
      >
        Task that might fail
      </Claude>
    )
  }

  await executePlan(<RetryAgent />, { mockMode: true })

  expect(attempts).toBeGreaterThan(0)
})
```

## Testing Human Component

### Mock Approval Flow

```tsx
test('Human component auto-approves in mock mode', async () => {
  let approvalCalled = false

  function AgentWithApproval() {
    return (
      <Human
        message="Approve plan?"
        onApprove={() => { approvalCalled = true }}
      >
        Plan details
      </Human>
    )
  }

  await executePlan(<AgentWithApproval />, { mockMode: true })

  expect(approvalCalled).toBe(true)
})
```

### Custom Approval Handler

```tsx
test('Human component with custom handler', async () => {
  const approved: string[] = []

  const handleHumanPrompt = (info: HumanPromptInfo) => {
    approved.push(info.message)
    return { approved: true }
  }

  function Agent() {
    return <Human message="Review step 1">Step 1 content</Human>
  }

  await executePlan(<Agent />, {
    mockMode: true,
    onHumanPrompt: handleHumanPrompt
  })

  expect(approved).toContain('Review step 1')
})
```

## Testing Worktrees

### Mock Worktree Tests

```tsx
test('Worktree component in mock mode', async () => {
  let worktreeCreated = false

  function ParallelFeatures() {
    return (
      <Worktree
        path="./test-worktree"
        branch="feature-test"
        onCreated={() => { worktreeCreated = true }}
      >
        <Claude>Implement feature</Claude>
      </Worktree>
    )
  }

  await executePlan(<ParallelFeatures />, { mockMode: true })

  expect(worktreeCreated).toBe(true)
})
```

## Testing Tools

### Mock Tool Execution

```tsx
test('Tool is called with correct input', async () => {
  const toolCalls: any[] = []

  const mockTool: Tool = {
    name: 'calculator',
    description: 'Perform calculations',
    input_schema: {
      type: 'object',
      properties: {
        expression: { type: 'string' }
      }
    },
    execute: async (input) => {
      toolCalls.push(input)
      return { result: 42 }
    }
  }

  function CalculatorAgent() {
    return (
      <Claude tools={[mockTool]}>
        Calculate 2 + 2
      </Claude>
    )
  }

  await executePlan(<CalculatorAgent />, { mockMode: false })

  // In real mode, tool would be called
  // In mock mode, tool calls are skipped
})
```

## Snapshot Testing

For agents with predictable structured output, use snapshots.

```tsx
test('Agent produces consistent plan structure', async () => {
  function PlanningAgent() {
    return (
      <Claude>
        <OutputFormat schema={{
          tasks: z.array(z.object({
            name: z.string(),
            status: z.enum(['pending', 'complete'])
          }))
        }}>
          Create task plan
        </OutputFormat>
      </Claude>
    )
  }

  const result = await executePlan(<PlanningAgent />, { mockMode: true })
  const output = JSON.parse(result.output)

  expect(output).toMatchSnapshot()
})
```

## Performance Testing

### Measure Execution Time

```tsx
test('Agent completes within time limit', async () => {
  const start = Date.now()

  await executePlan(<MyAgent />, { mockMode: true })

  const duration = Date.now() - start
  expect(duration).toBeLessThan(1000) // 1 second
})
```

### Test Frame Limits

```tsx
test('Agent respects maxFrames limit', async () => {
  await expect(
    executePlan(<InfiniteLoopAgent />, {
      mockMode: true,
      maxFrames: 5
    })
  ).rejects.toThrow('Maximum frames exceeded')
})
```

## Best Practices

### 1. Use Mock Mode by Default

Run most tests in mock mode for speed and determinism. Reserve real API tests for critical paths.

```tsx
// ✅ Good: Fast, deterministic
test('Component renders correctly', async () => {
  await executePlan(<Component />, { mockMode: true })
})

// ❌ Slow: Only use when necessary
test('Critical: Real API integration', async () => {
  await executePlan(<Component />, { mockMode: false })
})
```

### 2. Test State Transitions, Not Output Content

Focus on testing workflow logic rather than LLM response content.

```tsx
// ✅ Good: Tests state machine
test('Workflow transitions through all phases', async () => {
  const phases: string[] = []

  function Agent() {
    const { phase } = useStore()
    phases.push(phase)
    // ...
  }

  await executePlan(<Agent />, { mockMode: true })
  expect(phases).toEqual(['plan', 'implement', 'review', 'done'])
})

// ❌ Fragile: Tests LLM output content
test('Agent response contains specific text', async () => {
  const result = await executePlan(<Agent />)
  expect(result.output).toContain('specific phrase') // Brittle!
})
```

### 3. Isolate Tests

Each test should be independent with its own state.

```tsx
// ✅ Good: Fresh store per test
test('Test 1', async () => {
  const useStore = create(() => ({ phase: 'start' }))
  // ...
})

test('Test 2', async () => {
  const useStore = create(() => ({ phase: 'start' }))
  // ...
})
```

### 4. Use Descriptive Test Names

```tsx
// ✅ Good: Clear what's being tested
test('Multi-phase agent transitions from gather to analyze to report', async () => {
  // ...
})

// ❌ Vague
test('Agent works', async () => {
  // ...
})
```

### 5. Test Error Paths

```tsx
test('Agent handles missing dependencies gracefully', async () => {
  function Agent() {
    return <Claude>Task requiring unavailable tool</Claude>
  }

  await expect(
    executePlan(<Agent />, { mockMode: true })
  ).resolves.toBeDefined() // Should not crash
})
```

## Test Organization

### File Structure

```
evals/
  hello-world.test.tsx       # Basic functionality
  multi-phase.test.tsx       # State management
  parallel-execution.test.tsx # Subagent tests
  error-recovery.test.tsx    # Error handling
  worktree.test.tsx          # Worktree component
  integration.test.tsx       # Full workflows
```

### Test Suites

```tsx
import { describe, test, expect } from 'bun:test'

describe('CodeReviewer', () => {
  describe('with structured output', () => {
    test('returns JSON matching schema', async () => {
      // ...
    })

    test('handles empty results', async () => {
      // ...
    })
  })

  describe('with tools', () => {
    test('calls read tool for files', async () => {
      // ...
    })
  })
})
```

## Debugging Failed Tests

### Enable Verbose Logging

```tsx
await executePlan(<Agent />, {
  mockMode: true,
  verbose: true // Prints execution details
})
```

### Inspect Execution History

```tsx
const result = await executePlan(<Agent />, { mockMode: true })

console.log('Frames:', result.frames)
console.log('History:', result.history)
result.history.forEach((frame, i) => {
  console.log(`Frame ${i + 1}:`, frame)
})
```

### Use TUI for Visual Debugging

```tsx
await executePlan(<Agent />, {
  mockMode: true,
  tui: true // Launch TUI to see execution tree
})
```

## Related Guides

- [Error Handling](/guides/error-handling) - Patterns for robust error recovery
- [State Management](/concepts/state-management) - Managing state in agents
- [Debugging](/guides/debugging) - Debugging techniques
