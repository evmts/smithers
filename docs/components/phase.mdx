---
title: Phase Component
description: Define a named phase in a multi-step workflow
---

# Phase Component

The `<Phase>` component defines a named phase in a multi-step workflow. It provides semantic organization for complex agent plans and makes prompts more readable.

## Basic Usage

```tsx
import { Claude, Phase, Step } from 'smithers'

function ResearchAgent({ topic }) {
  return (
    <Claude tools={[webSearch, filesystem]}>
      <Phase name="research">
        <Step>Search for academic papers on {topic}</Step>
        <Step>Find industry reports and case studies</Step>
        <Step>Identify key experts and their publications</Step>
      </Phase>

      <Phase name="synthesis">
        <Step>Identify common themes across sources</Step>
        <Step>Note any contradictions or debates</Step>
        <Step>Summarize key findings</Step>
      </Phase>

      <Phase name="output">
        <Step>Write a comprehensive report</Step>
        <Step>Save to output/report.md</Step>
      </Phase>
    </Claude>
  )
}
```

Renders to:

```xml
<claude tools="web-search,filesystem">
  <phase name="research">
    <step>Search for academic papers on quantum computing</step>
    <step>Find industry reports and case studies</step>
    <step>Identify key experts and their publications</step>
  </phase>

  <phase name="synthesis">
    <step>Identify common themes across sources</step>
    <step>Note any contradictions or debates</step>
    <step>Summarize key findings</step>
  </phase>

  <phase name="output">
    <step>Write a comprehensive report</step>
    <step>Save to output/report.md</step>
  </phase>
</claude>
```

## Props

<ParamField path="name" type="string" required>
  Identifier for the phase. Appears in the rendered XML and execution logs.
</ParamField>

<ParamField path="completed" type="boolean" default="false">
  Mark the phase as already completed. Completed phases are skipped by the Ralph loop.

  ```tsx
  <Phase name="research" completed>
    Already completed research...
  </Phase>
  ```
</ParamField>

<ParamField path="children" type="ReactNode" required>
  The content of the phase - typically `<Step>` components or plain text.
</ParamField>

## Conditional Phases

Use React conditionals to include or exclude phases:

```tsx
function FlexibleAgent({ includeReview, includeDocs, task }) {
  return (
    <Claude tools={[filesystem]}>
      <Phase name="implement">
        <Step>Implement {task}</Step>
        <Step>Write tests</Step>
      </Phase>

      {includeReview && (
        <Phase name="review">
          <Step>Self-review the implementation</Step>
          <Step>Check for edge cases</Step>
          <Step>Verify error handling</Step>
        </Phase>
      )}

      {includeDocs && (
        <Phase name="document">
          <Step>Add JSDoc comments</Step>
          <Step>Update README if needed</Step>
        </Phase>
      )}
    </Claude>
  )
}
```

## Phases Without Steps

Phases can contain plain text instead of steps:

```tsx
<Claude>
  <Phase name="analysis">
    Analyze the codebase structure.
    Look for patterns and anti-patterns.
    Consider maintainability and scalability.
  </Phase>

  <Phase name="recommendations">
    Based on your analysis, provide concrete recommendations.
    Prioritize by impact and effort.
  </Phase>
</Claude>
```

## Mixed Content

Combine steps with prose:

```tsx
<Phase name="security-audit">
  Focus on the authentication and authorization modules.

  <Step>Check for SQL injection vulnerabilities</Step>
  <Step>Verify password hashing is secure</Step>
  <Step>Audit session management</Step>

  Pay special attention to any user input handling.
</Phase>
```

## Reusable Phase Components

Create custom phase components for common patterns:

```tsx
function SecurityReviewPhase({ focus }) {
  return (
    <Phase name="security-review">
      <Step>Check for injection vulnerabilities in {focus}</Step>
      <Step>Verify authentication and authorization</Step>
      <Step>Review sensitive data handling</Step>
      <Step>Check for common security misconfigurations</Step>
    </Phase>
  )
}

function TestingPhase({ coverage }) {
  return (
    <Phase name="testing">
      <Step>Write unit tests (target {coverage}% coverage)</Step>
      <Step>Add integration tests for critical paths</Step>
      <Step>Verify all tests pass</Step>
    </Phase>
  )
}

// Usage
function SecureFeature({ feature }) {
  return (
    <Claude tools={[filesystem, terminal]}>
      <Phase name="implement">
        <Step>Implement {feature}</Step>
      </Phase>

      <SecurityReviewPhase focus={feature} />
      <TestingPhase coverage={80} />
    </Claude>
  )
}
```

## Semantic Benefits

<CardGroup cols={2}>
  <Card title="Clarity for Claude" icon="brain">
    Phases help Claude understand the expected workflow structure
  </Card>
  <Card title="Readable plans" icon="eye">
    The XML output is easy to review and understand
  </Card>
  <Card title="Composability" icon="puzzle-piece">
    Create reusable phase components for common patterns
  </Card>
  <Card title="Debugging" icon="bug">
    Phase names appear in logs, making it easier to track progress
  </Card>
</CardGroup>

## Related

<CardGroup cols={2}>
  <Card title="Step" icon="list" href="/components/step">
    Define individual steps within a phase
  </Card>
  <Card title="Claude" icon="cube" href="/components/claude">
    The container for phases
  </Card>
  <Card title="Ralph Wiggum Loop" icon="rotate" href="/concepts/ralph-wiggum-loop">
    Understand the execution model
  </Card>
</CardGroup>
