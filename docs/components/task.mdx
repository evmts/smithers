---
title: Task
description: Track individual tasks within workflows
---

# Task Component

<Note>
**Not to be confused with `db.tasks.*`**

- `<Task>` component = Declarative UI element for displaying task progress in workflows (this page)
- `db.tasks.*` = Internal API for tracking async component lifecycle (start/complete/fail)

Components like `<Claude>`, `<Step>`, and `<Worktree>` use `db.tasks.start()` and `db.tasks.complete()` internally to signal when they're running. The `<Task>` component is purely presentationalâ€”it renders a checkbox-style task item.
</Note>

The `<Task>` component represents a trackable task within a workflow. Tasks can be marked as done/not done to track progress through complex workflows.

## Usage

```tsx
import { Task, Phase, Step } from "smithers-orchestrator";

<Phase name="implementation">
  <Step name="tasks">
    <Task done={false}>Research existing patterns</Task>
    <Task done={true}>Design component API</Task>
    <Task done={false}>Implement component</Task>
    <Task done={false}>Write tests</Task>
  </Step>
</Phase>
```

## Props

<ParamField path="done" type="boolean" default="false">
  Whether the task is complete.
</ParamField>

<ParamField path="children" type="ReactNode">
  Description of the task.
</ParamField>

## Examples

### Basic Task List

```tsx
<SmithersProvider db={db} executionId={executionId}>
  <Phase name="setup">
    <Step name="tasks">
      <Task done={true}>Initialize project</Task>
      <Task done={true}>Configure TypeScript</Task>
      <Task done={false}>Set up testing framework</Task>
    </Step>
  </Phase>
</SmithersProvider>
```

### Dynamic Task Tracking

```tsx
function TaskTracker() {
  const { db } = useSmithers();
  
  const tasks = useQueryValue<Array<{id: number, name: string, done: boolean}>>(
    db.db,
    "SELECT value FROM state WHERE key = 'tasks'"
  ) ?? [
    { id: 1, name: "Research", done: false },
    { id: 2, name: "Design", done: false },
    { id: 3, name: "Implement", done: false },
    { id: 4, name: "Test", done: false },
  ];

  const markDone = (id: number) => {
    const updated = tasks.map(t =>
      t.id === id ? { ...t, done: true } : t
    );
    db.state.set('tasks', updated);
  };

  return (
    <Phase name="feature-development">
      <Step name="tasks">
        {tasks.map(task => (
          <Task key={task.id} done={task.done}>
            {task.name}
          </Task>
        ))}

        <Claude
          onFinished={() => markDone(getCurrentTaskId())}
        >
          Complete the next incomplete task.
        </Claude>
      </Step>
    </Phase>
  );
}
```

### With Database Persistence

```tsx
function PersistentTasks() {
  const { db } = useSmithers();
  
  const tasks = useQueryValue<Array<{name: string, done: boolean}>>(
    db.db,
    "SELECT value FROM state WHERE key = 'tasks'"
  ) ?? [];

  const completeTask = (index: number) => {
    const newTasks = [...tasks];
    newTasks[index].done = true;
    db.state.set("tasks", newTasks, "task-tracker");
  };

  return (
    <Phase name="tracked-work">
      <Step name="tasks">
        {tasks.map((task, i) => (
          <Task key={i} done={task.done}>
            {task.name}
          </Task>
        ))}
      </Step>
    </Phase>
  );
}
```

### Task-Driven Workflow

```tsx
function TaskDrivenWorkflow() {
  const { db } = useSmithers();
  
  const currentTaskIndex = useQueryValue<number>(
    db.db,
    "SELECT value FROM state WHERE key = 'currentTaskIndex'"
  ) ?? 0;

  const tasks = [
    "Analyze the current implementation",
    "Identify areas for improvement",
    "Refactor the component",
    "Update tests",
    "Document changes",
  ];

  return (
    <SmithersProvider db={db} executionId={executionId}>
      <Ralph maxIterations={tasks.length}>
        <Phase name="tasks">
          <Step name="tasks">
            {tasks.map((task, i) => (
              <Task key={i} done={i < currentTaskIndex}>
                {task}
              </Task>
            ))}
          </Step>
        </Phase>

        <If condition={currentTaskIndex < tasks.length}>
          <Claude
            onFinished={() => db.state.set('currentTaskIndex', currentTaskIndex + 1)}
          >
            Complete this task: {tasks[currentTaskIndex]}
          </Claude>
        </If>
      </Ralph>
    </SmithersProvider>
  );
}
```

## Rendering

The Task component renders as a `<task>` element with a `done` attribute, which can be styled or processed by your workflow visualization:

```xml
<task done="true">Research existing patterns</task>
<task done="false">Implement component</task>
```

## Best Practices

<AccordionGroup>
  <Accordion title="Keep tasks atomic">
    Each task should represent a single, well-defined action:
    ```tsx
    // Good - atomic tasks
    <Task done={false}>Create user model</Task>
    <Task done={false}>Add validation rules</Task>
    <Task done={false}>Write migration</Task>

    // Less effective - compound task
    <Task done={false}>Create user model with validation and migration</Task>
    ```
  </Accordion>

  <Accordion title="Use with Phase for organization">
    Group related tasks within phases:
    ```tsx
    <Phase name="backend">
      <Step name="tasks">
        <Task done={true}>Create API endpoint</Task>
        <Task done={false}>Add authentication</Task>
      </Step>
    </Phase>

    <Phase name="frontend">
      <Step name="tasks">
        <Task done={false}>Create form component</Task>
        <Task done={false}>Add validation</Task>
      </Step>
    </Phase>
    ```
  </Accordion>
</AccordionGroup>

## Related

<CardGroup cols={2}>
  <Card title="Phase" icon="layer-group" href="/components/phase">
    Organize tasks into phases
  </Card>
  <Card title="Step" icon="shoe-prints" href="/components/step">
    Sequential workflow steps
  </Card>
</CardGroup>
