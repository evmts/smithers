---
title: Task Component
description: Trackable task with completion state
---

# Task Component

The `<Task>` component represents a trackable task with completion state. It's useful for building workflows where you need to track progress and show what work has been done.

## Basic Usage

```tsx
import { Claude, Task } from '@evmts/smithers'

function TaskList({ tasks }) {
  return (
    <Claude>
      Complete the following tasks:

      {tasks.map(task => (
        <Task key={task.id} done={task.completed}>
          {task.description}
        </Task>
      ))}
    </Claude>
  )
}
```

Renders to:

```xml
<claude>
  Complete the following tasks:

  <task done="false">Research the topic</task>
  <task done="true">Write the outline</task>
  <task done="false">Draft the content</task>
</claude>
```

## Props

<ParamField path="done" type="boolean" default="false">
  Whether the task has been completed.

  ```tsx
  <Task done={false}>Research the topic</Task>
  <Task done={true}>Write the outline</Task>
  ```
</ParamField>

<ParamField path="children" type="ReactNode" required>
  The task description.
</ParamField>

## Tracking Task Progress

Use state to track task completion:

```tsx
import { create } from 'zustand'

const useStore = create((set) => ({
  completedTasks: new Set(),
  completeTask: (id) => set((s) => ({
    completedTasks: new Set([...s.completedTasks, id])
  }))
}))

function ProgressAgent({ tasks }) {
  const { completedTasks, completeTask } = useStore()
  const pending = tasks.filter(t => !completedTasks.has(t.id))

  if (pending.length === 0) {
    return <div>All tasks completed!</div>
  }

  const currentTask = pending[0]

  return (
    <Claude onFinished={() => completeTask(currentTask.id)}>
      Current progress:
      {tasks.map(task => (
        <Task key={task.id} done={completedTasks.has(task.id)}>
          {task.description}
        </Task>
      ))}

      Now complete: {currentTask.description}
    </Claude>
  )
}
```

## Task Lists in Prompts

Show task lists to help Claude understand what needs to be done:

```tsx
function ProjectAgent({ project }) {
  const [completed, setCompleted] = useState([])

  return (
    <Claude
      tools={[filesystem]}
      onFinished={(result) => {
        setCompleted(prev => [...prev, result.taskId])
      }}
    >
      <Persona role="Project Manager" />

      Project: {project.name}

      Task list:
      {project.tasks.map(task => (
        <Task key={task.id} done={completed.includes(task.id)}>
          {task.title}: {task.description}
        </Task>
      ))}

      Complete the next uncompleted task and report which one you finished.
    </Claude>
  )
}
```

## Conditional Task Display

Show different content based on task state:

```tsx
function SmartTaskList({ tasks }) {
  const completedTasks = tasks.filter(t => t.done)
  const pendingTasks = tasks.filter(t => !t.done)

  return (
    <Claude>
      {completedTasks.length > 0 && (
        <>
          Completed tasks:
          {completedTasks.map(t => (
            <Task key={t.id} done={true}>{t.description}</Task>
          ))}
        </>
      )}

      {pendingTasks.length > 0 && (
        <>
          Remaining tasks:
          {pendingTasks.map(t => (
            <Task key={t.id} done={false}>{t.description}</Task>
          ))}

          Focus on the first pending task.
        </>
      )}
    </Claude>
  )
}
```

## Tasks with Phases

Combine tasks with phases for organized workflows:

```tsx
function PhasedProject({ phases }) {
  return (
    <Claude tools={[filesystem]}>
      {phases.map(phase => (
        <Phase key={phase.name} name={phase.name}>
          {phase.tasks.map(task => (
            <Task key={task.id} done={task.completed}>
              {task.description}
            </Task>
          ))}
        </Phase>
      ))}

      Complete all pending tasks in order, one phase at a time.
    </Claude>
  )
}
```

## Dynamic Task Generation

Generate tasks based on analysis:

```tsx
function AdaptiveAgent({ codebase }) {
  const [tasks, setTasks] = useState(null)
  const [completed, setCompleted] = useState([])

  if (!tasks) {
    return (
      <Claude
        tools={[filesystem, grep]}
        onFinished={(analysis) => setTasks(analysis.tasks)}
      >
        Analyze {codebase} and create a list of improvement tasks.

        <OutputFormat schema={{
          tasks: [{
            id: 'string',
            description: 'string',
            priority: 'high | medium | low'
          }]
        }} />
      </Claude>
    )
  }

  const pending = tasks.filter(t => !completed.includes(t.id))

  if (pending.length === 0) {
    return <div>All improvements complete!</div>
  }

  return (
    <Claude
      tools={[filesystem]}
      onFinished={() => setCompleted(prev => [...prev, pending[0].id])}
    >
      Task progress:
      {tasks.map(task => (
        <Task key={task.id} done={completed.includes(task.id)}>
          [{task.priority}] {task.description}
        </Task>
      ))}

      Complete the next pending task: {pending[0].description}
    </Claude>
  )
}
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Clear descriptions" icon="text">
    Task descriptions should be actionable and specific
  </Card>
  <Card title="Track state externally" icon="database">
    Use Zustand or React state to track completion
  </Card>
  <Card title="Show progress" icon="chart-line">
    Display both completed and pending tasks for context
  </Card>
  <Card title="Order matters" icon="sort">
    Present tasks in the order they should be completed
  </Card>
</CardGroup>

## Related

<CardGroup cols={2}>
  <Card title="Step" icon="list" href="/components/step">
    Steps within phases
  </Card>
  <Card title="Phase" icon="layer-group" href="/components/phase">
    Group tasks into phases
  </Card>
  <Card title="Stop" icon="stop" href="/components/stop">
    Halt execution when tasks are complete
  </Card>
</CardGroup>
