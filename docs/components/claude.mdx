---
title: Claude Component
description: The core execution component for AI agent invocations
---

# Claude Component

The `<Claude>` component is the core of Smithers. It represents a single Claude agent invocation - everything inside becomes the prompt sent to the Claude API.

## Basic Usage

```tsx
import { Claude } from 'smithers'

function SimpleAgent() {
  return (
    <Claude>
      Analyze the current directory structure and summarize what this project does.
    </Claude>
  )
}
```

## Props

<ParamField path="tools" type="Tool[]">
  Array of tools to make available to Claude. Tools are automatically connected as MCP (Model Context Protocol) servers.

  ```tsx
  <Claude tools={[filesystem, webSearch, database]}>
    Search for information and save results to a file.
  </Claude>
  ```
</ParamField>

<ParamField path="onFinished" type="(output: T) => void">
  Callback invoked when Claude completes execution. The output is parsed from Claude's response.

  ```tsx
  <Claude onFinished={(result) => {
    console.log('Agent completed:', result)
    setData(result)
  }}>
    Return a JSON object with your analysis.
  </Claude>
  ```
</ParamField>

<ParamField path="onError" type="(error: Error) => void">
  Callback invoked if execution fails.

  ```tsx
  <Claude
    onError={(error) => {
      console.error('Agent failed:', error)
      setError(error)
    }}
  >
    Perform a risky operation.
  </Claude>
  ```
</ParamField>

<ParamField path="model" type="string" default="claude-sonnet-4-20250514">
  Override the Claude model to use.

  ```tsx
  <Claude model="claude-opus-4-20250514">
    Complex reasoning task requiring the most capable model.
  </Claude>
  ```
</ParamField>

<ParamField path="children" type="ReactNode" required>
  The prompt content. Can be plain text, markdown, or nested components.
</ParamField>

## Children as Prompt

Everything inside `<Claude>` becomes the prompt. You can mix text, JSX, and dynamic values:

```tsx
<Claude tools={[filesystem]}>
  <Persona role="Senior Engineer">
    You have 10 years of experience with distributed systems.
  </Persona>

  <Constraints>
    - Focus on performance issues
    - Suggest concrete fixes with code examples
    - Prioritize by impact
  </Constraints>

  Analyze the codebase at {projectPath} for performance bottlenecks.

  <OutputFormat>
    Return JSON: {"{"} issues: [{"{"} file, description, fix {"}"}] {"}"}
  </OutputFormat>
</Claude>
```

This renders to XML that Claude interprets:

```xml
<claude tools="filesystem">
  <persona role="Senior Engineer">
    You have 10 years of experience with distributed systems.
  </persona>
  <constraints>
    - Focus on performance issues
    - Suggest concrete fixes with code examples
    - Prioritize by impact
  </constraints>

  Analyze the codebase at /path/to/project for performance bottlenecks.

  <output-format>
    Return JSON: { issues: [{ file, description, fix }] }
  </output-format>
</claude>
```

## State-Driven Rendering

Use React state to control what the agent does:

```tsx
import { create } from 'zustand'

const useStore = create((set) => ({
  phase: 'research' as 'research' | 'write',
  findings: null,
  setFindings: (findings) => set({ findings, phase: 'write' }),
}))

function StatefulAgent({ topic }) {
  const { phase, findings, setFindings } = useStore()

  if (phase === 'research') {
    return (
      <Claude tools={[webSearch]} onFinished={setFindings}>
        Research {topic}. Find 5 authoritative sources.
      </Claude>
    )
  }

  return (
    <Claude tools={[filesystem]} onFinished={() => console.log('Done!')}>
      Write a report synthesizing these findings:
      {JSON.stringify(findings)}

      Save to output/report.md
    </Claude>
  )
}
```

## Composition Patterns

### Reusable Prompt Components

Create reusable components for common patterns:

```tsx
function SecurityExpert({ children }) {
  return (
    <Persona role="Security Expert">
      You are a senior application security engineer with expertise in
      OWASP Top 10, secure coding practices, and threat modeling.
      {children}
    </Persona>
  )
}

function JSONOutput({ schema }) {
  return (
    <OutputFormat schema={schema}>
      Respond with valid JSON matching the schema. No markdown, no explanation.
    </OutputFormat>
  )
}

// Usage
function SecurityAudit({ codebase }) {
  return (
    <Claude tools={[filesystem, grep]}>
      <SecurityExpert />

      <Constraints>
        - Focus on high and critical severity issues
        - Provide actionable remediation steps
      </Constraints>

      Audit {codebase} for security vulnerabilities.

      <JSONOutput schema={{
        vulnerabilities: [{
          severity: 'critical | high | medium | low',
          location: 'string',
          description: 'string',
          remediation: 'string'
        }]
      }} />
    </Claude>
  )
}
```

### Conditional Sections

Include or exclude prompt sections based on props:

```tsx
function FlexibleReviewer({ strict, includeTests, files }) {
  return (
    <Claude tools={[filesystem, grep]}>
      Review these files: {files.join(', ')}

      {strict && (
        <Constraints>
          - Apply strict code standards
          - Flag any potential issues, even minor ones
          - Require documentation for all public APIs
        </Constraints>
      )}

      {includeTests && (
        <Phase name="test-review">
          Also review test coverage and test quality.
          Suggest additional test cases if needed.
        </Phase>
      )}
    </Claude>
  )
}
```

## Nested Claude Components

You can nest `<Claude>` components for sub-agent patterns:

```tsx
function OrchestratorAgent({ task }) {
  return (
    <Claude>
      You are an orchestrator. Break down this task: {task}

      <Subagent name="researcher">
        <Claude tools={[webSearch]}>
          Research background information for the task.
        </Claude>
      </Subagent>

      <Subagent name="implementer">
        <Claude tools={[filesystem]}>
          Implement the solution based on research.
        </Claude>
      </Subagent>
    </Claude>
  )
}
```

## Error Handling

Handle errors gracefully with the `onError` callback:

```tsx
function ResilientAgent({ task }) {
  const [error, setError] = useState(null)
  const [retries, setRetries] = useState(0)

  if (error && retries < 3) {
    return (
      <Claude onFinished={() => {
        setError(null)
        setRetries(r => r + 1)
      }}>
        The previous attempt failed with: {error.message}
        Try a different approach to complete: {task}
      </Claude>
    )
  }

  return (
    <Claude onError={setError} onFinished={console.log}>
      Complete this task: {task}
    </Claude>
  )
}
```

## TypeScript

Full type definitions are available:

```tsx
import type { ClaudeProps, Tool } from 'smithers'

interface AnalysisResult {
  summary: string
  issues: Array<{ severity: string; message: string }>
}

function TypedAgent({ code }: { code: string }) {
  const handleResult = (result: AnalysisResult) => {
    console.log(result.summary)
    result.issues.forEach(issue => console.log(issue.message))
  }

  return (
    <Claude<AnalysisResult>
      tools={[filesystem]}
      onFinished={handleResult}
    >
      Analyze this code and return a summary with issues:
      {code}
    </Claude>
  )
}
```

## Related Components

<CardGroup cols={2}>
  <Card title="Subagent" icon="layer-group" href="/components/subagent">
    Run Claude components in parallel
  </Card>
  <Card title="Phase & Step" icon="list-check" href="/components/phase-step">
    Organize multi-step prompts
  </Card>
  <Card title="Prompt Structure" icon="cube" href="/components/prompt-structure">
    Persona, Constraints, OutputFormat
  </Card>
</CardGroup>
