---
title: Claude Component
description: The core execution component for AI agent invocations
---

# Claude Component

The `<Claude>` component is the core of Smithers. It represents a single Claude agent invocation - everything inside becomes the prompt sent to the Claude API.

## Basic Usage

```tsx
import { Claude } from '@evmts/smithers'

function SimpleAgent() {
  return (
    <Claude>
      Analyze the current directory structure and summarize what this project does.
    </Claude>
  )
}
```

## Props

<ParamField path="tools" type="Tool[]">
  Array of tools to make available to Claude. Tools are automatically connected as MCP (Model Context Protocol) servers.

  ```tsx
  <Claude tools={[filesystem, webSearch, database]}>
    Search for information and save results to a file.
  </Claude>
  ```
</ParamField>

<ParamField path="onFinished" type="(output: T) => void">
  Callback invoked when Claude completes execution. The output is parsed from Claude's response.

  ```tsx
  <Claude onFinished={(result) => {
    console.log('Agent completed:', result)
    setData(result)
  }}>
    Return a JSON object with your analysis.
  </Claude>
  ```
</ParamField>

<ParamField path="onError" type="(error: Error) => void">
  Callback invoked if execution fails.

  ```tsx
  <Claude
    onError={(error) => {
      console.error('Agent failed:', error)
      setError(error)
    }}
  >
    Perform a risky operation.
  </Claude>
  ```
</ParamField>

<ParamField path="model" type="string" default="claude-sonnet-4-20250514">
  Override the Claude model to use.

  ```tsx
  <Claude model="claude-opus-4-20250514">
    Complex reasoning task requiring the most capable model.
  </Claude>
  ```
</ParamField>

<ParamField path="children" type="JSX.Element" required>
  The prompt content. Can be plain text, markdown, or nested components.
</ParamField>

## Children as Prompt

Everything inside `<Claude>` becomes the prompt. You can mix text, JSX, and dynamic values:

```tsx
<Claude tools={[filesystem]}>
  <Persona role="Senior Engineer">
    You have 10 years of experience with distributed systems.
  </Persona>

  <Constraints>
    - Focus on performance issues
    - Suggest concrete fixes with code examples
    - Prioritize by impact
  </Constraints>

  Analyze the codebase at {projectPath} for performance bottlenecks.

  <OutputFormat>
    Return JSON: {"{"} issues: [{"{"} file, description, fix {"}"}] {"}"}
  </OutputFormat>
</Claude>
```

This renders to XML that Claude interprets:

```xml
<claude tools="filesystem">
  <persona role="Senior Engineer">
    You have 10 years of experience with distributed systems.
  </persona>
  <constraints>
    - Focus on performance issues
    - Suggest concrete fixes with code examples
    - Prioritize by impact
  </constraints>

  Analyze the codebase at /path/to/project for performance bottlenecks.

  <output-format>
    Return JSON: { issues: [{ file, description, fix }] }
  </output-format>
</claude>
```

## State-Driven Rendering

Use SolidJS state to control what the agent does:

```tsx
import { createStore } from 'solid-js/store'

function StatefulAgent(props) {
  const [state, setState] = createStore({
    phase: 'research' as 'research' | 'write',
    findings: null,
  })

  const setFindings = (findings) => setState({ findings, phase: 'write' })

  return () => {
    if (state.phase === 'research') {
      return (
        <Claude tools={[webSearch]} onFinished={setFindings}>
          Research {props.topic}. Find 5 authoritative sources.
        </Claude>
      )
    }

    return (
      <Claude tools={[filesystem]} onFinished={() => console.log('Done!')}>
        Write a report synthesizing these findings:
        {JSON.stringify(state.findings)}

        Save to output/report.md
      </Claude>
    )
  }
}
```

## Composition Patterns

### Reusable Prompt Components

Create reusable components for common patterns:

```tsx
function SecurityExpert(props) {
  return (
    <Persona role="Security Expert">
      You are a senior application security engineer with expertise in
      OWASP Top 10, secure coding practices, and threat modeling.
      {props.children}
    </Persona>
  )
}

function JSONOutput(props) {
  return (
    <OutputFormat schema={props.schema}>
      Respond with valid JSON matching the schema. No markdown, no explanation.
    </OutputFormat>
  )
}

// Usage
function SecurityAudit(props) {
  return (
    <Claude tools={[filesystem, grep]}>
      <SecurityExpert />

      <Constraints>
        - Focus on high and critical severity issues
        - Provide actionable remediation steps
      </Constraints>

      Audit {props.codebase} for security vulnerabilities.

      <JSONOutput schema={{
        vulnerabilities: [{
          severity: 'critical | high | medium | low',
          location: 'string',
          description: 'string',
          remediation: 'string'
        }]
      }} />
    </Claude>
  )
}
```

### Conditional Sections

Include or exclude prompt sections based on props:

```tsx
function FlexibleReviewer(props) {
  return (
    <Claude tools={[filesystem, grep]}>
      Review these files: {props.files.join(', ')}

      {props.strict && (
        <Constraints>
          - Apply strict code standards
          - Flag any potential issues, even minor ones
          - Require documentation for all public APIs
        </Constraints>
      )}

      {props.includeTests && (
        <Phase name="test-review">
          Also review test coverage and test quality.
          Suggest additional test cases if needed.
        </Phase>
      )}
    </Claude>
  )
}
```

## Nested Claude Components

You can nest `<Claude>` components for sub-agent patterns:

```tsx
function OrchestratorAgent(props) {
  return (
    <Claude>
      You are an orchestrator. Break down this task: {props.task}

      <Subagent name="researcher">
        <Claude tools={[webSearch]}>
          Research background information for the task.
        </Claude>
      </Subagent>

      <Subagent name="implementer">
        <Claude tools={[filesystem]}>
          Implement the solution based on research.
        </Claude>
      </Subagent>
    </Claude>
  )
}
```

## Error Handling

Handle errors gracefully with the `onError` callback:

```tsx
import { createSignal } from 'solid-js'

function ResilientAgent(props) {
  const [error, setError] = createSignal(null)
  const [retries, setRetries] = createSignal(0)

  return () => {
    const err = error()
    const r = retries()

    if (err && r < 3) {
      return (
        <Claude onFinished={() => {
          setError(null)
          setRetries(prev => prev + 1)
        }}>
          The previous attempt failed with: {err.message}
          Try a different approach to complete: {props.task}
        </Claude>
      )
    }

    return (
      <Claude onError={setError} onFinished={console.log}>
        Complete this task: {props.task}
      </Claude>
    )
  }
}
```

## TypeScript

Full type definitions are available:

```tsx
import type { ClaudeProps, Tool } from '@evmts/smithers'

interface AnalysisResult {
  summary: string
  issues: Array<{ severity: string; message: string }>
}

function TypedAgent(props: { code: string }) {
  const handleResult = (result: AnalysisResult) => {
    console.log(result.summary)
    result.issues.forEach(issue => console.log(issue.message))
  }

  return (
    <Claude<AnalysisResult>
      tools={[filesystem]}
      onFinished={handleResult}
    >
      Analyze this code and return a summary with issues:
      {props.code}
    </Claude>
  )
}
```

## Related Components

<CardGroup cols={2}>
  <Card title="ClaudeApi" icon="code" href="/components/claude-api">
    Direct API access with custom tools
  </Card>
  <Card title="Subagent" icon="layer-group" href="/components/subagent">
    Run Claude components in parallel
  </Card>
  <Card title="Phase" icon="list-check" href="/components/phase">
    Organize multi-step prompts
  </Card>
  <Card title="Persona" icon="user" href="/components/persona">
    Define agent role and expertise
  </Card>
</CardGroup>
