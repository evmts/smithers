---
title: Claude
description: Execute Claude with tool access
---

# Claude

Execute Claude via Claude Code CLI. Children are the prompt.

```tsx
<Claude model="sonnet" maxTurns={10} onFinished={(r) => console.log(r.output)}>
  Fix the failing tests.
</Claude>
```

## Props

### Model Configuration

<ParamField path="model" type="'opus' | 'sonnet' | 'haiku'" default="sonnet">
  The Claude model to use.

  ```tsx
  <Claude model="opus">Complex reasoning task</Claude>
  <Claude model="sonnet">Standard task</Claude>
  <Claude model="haiku">Quick, simple task</Claude>
  ```
</ParamField>

<ParamField path="maxTurns" type="number">
  Maximum number of agentic turns (tool use cycles).

  ```tsx
  <Claude maxTurns={5}>Limited iteration task</Claude>
  ```
</ParamField>

<ParamField path="maxTokens" type="number">
  Maximum tokens for the response. When specified, execution stops if total tokens
  (input + output) exceed this limit.

  ```tsx
  <Claude maxTokens={4096}>Task with token limit</Claude>
  ```
</ParamField>

<ParamField path="timeout" type="number">
  Timeout in milliseconds.

  ```tsx
  <Claude timeout={60000}>Task with 1 minute timeout</Claude>
  ```
</ParamField>

### System Prompt

<ParamField path="systemPrompt" type="string">
  Custom system prompt for Claude.

  ```tsx
  <Claude systemPrompt="You are a security expert. Focus on vulnerabilities.">
    Review this code.
  </Claude>
  ```
</ParamField>

### Tool Configuration

<ParamField path="tools" type="Tool[]">
  Custom tools to provide to Claude.
  
  <Warning>**Experimental.** Custom tool support is functional but API may change. Use `allowedTools`/`disallowedTools` for built-in tools, or the `<Sqlite>` component for database access.</Warning>

  ```tsx
  <Claude
    tools={[
      {
        name: "query_database",
        description: "Query the PostgreSQL database",
        inputSchema: {
          type: "object",
          properties: {
            query: { type: "string", description: "SQL query" },
          },
          required: ["query"],
        },
        execute: async (input) => {
          const result = await db.query(input.query);
          return JSON.stringify(result);
        },
      },
    ]}
  >
    Query the database for statistics.
  </Claude>
  ```
</ParamField>

<ParamField path="allowedTools" type="string[]">
  Restrict Claude to only these built-in tools.

  ```tsx
  <Claude allowedTools={["Read", "Glob", "Grep"]}>
    Research only - no edits.
  </Claude>
  ```
</ParamField>

<ParamField path="disallowedTools" type="string[]">
  Prevent Claude from using these tools.

  ```tsx
  <Claude disallowedTools={["Bash"]}>
    No shell commands.
  </Claude>
  ```
</ParamField>

<ParamField path="permissionMode" type="'default' | 'acceptEdits' | 'plan'">
  Permission handling mode.

  ```tsx
  <Claude permissionMode="acceptEdits">
    Auto-accept file edits.
  </Claude>
  ```
</ParamField>

### Structured Output

<ParamField path="schema" type="ZodSchema">
  Zod schema for structured output validation.

  ```tsx
  const ResultSchema = z.object({
    summary: z.string(),
    issues: z.array(z.string()),
  });

  <Claude schema={ResultSchema}>
    Return structured analysis.
  </Claude>
  ```
</ParamField>

<ParamField path="validate" type="(result: AgentResult) => boolean | Promise<boolean>">
  Custom validation function. Receives the full AgentResult including `output`, `structured`, `tokensUsed`, etc.

  ```tsx
  <Claude 
    schema={AnalysisSchema}
    validate={(result) => result.structured?.issues.length > 0}
  >
    Must find at least one issue.
  </Claude>
  ```
</ParamField>

<ParamField path="retryOnValidationFailure" type="boolean" default="false">
  Retry if validation fails.
</ParamField>

<ParamField path="maxRetries" type="number" default="3">
  Maximum retries for the outer error retry loop.
</ParamField>

<ParamField path="schemaRetries" type="number" default="2">
  Maximum retries for structured output schema validation. When Claude returns
  output that fails Zod schema validation, it will retry up to this many times.

  ```tsx
  <Claude schema={UserSchema} schemaRetries={3}>
    Return user data in the expected format.
  </Claude>
  ```
</ParamField>

### Callbacks

<ParamField path="onFinished" type="(result: AgentResult) => void">
  Called when execution completes.

  ```tsx
  <Claude onFinished={(result) => {
    console.log(result.output);
    console.log(result.structured);  // If schema provided
    console.log(result.tokensUsed);
  }}>
    Task
  </Claude>
  ```
</ParamField>

<ParamField path="onError" type="(error: Error) => void">
  Called on execution error.

  ```tsx
  <Claude onError={(err) => console.error(err)}>
    Risky task
  </Claude>
  ```
</ParamField>

<ParamField path="onProgress" type="(message: string) => void">
  Called with progress updates.
</ParamField>

<ParamField path="onStreamPart" type="(part: SmithersStreamPart) => void">
  Called with typed stream events when experimental streaming is enabled.
</ParamField>

<ParamField path="onToolCall" type="(tool: string, input: any) => void">
  Called when Claude uses a tool.
</ParamField>

### Stop Conditions

<ParamField path="stopConditions" type="StopCondition[]">
  Conditions that can stop execution early.

  ```tsx
  <Claude
    stopConditions={[
      { type: "token_limit", value: 10000 },
      { type: "pattern", value: /DONE/i },
    ]}
  >
    Task with stop conditions
  </Claude>
  ```
</ParamField>

### Session Management

<ParamField path="continueConversation" type="boolean">
  Continue from the previous conversation in the same execution context.
</ParamField>

<ParamField path="resumeSession" type="string">
  Resume a specific session by ID.
</ParamField>

### Output Configuration

<ParamField path="outputFormat" type="'text' | 'json' | 'stream-json'" default="text">
  Output format for Claude CLI responses.

  - `text`: Plain text output (default)
  - `json`: Structured JSON output
  - `stream-json`: Streaming JSON output (required for typed streaming)
</ParamField>

<ParamField path="mcpConfig" type="string">
  Path to MCP (Model Context Protocol) configuration file.

  ```tsx
  <Claude mcpConfig="./mcp-config.json">
    Use the configured MCP tools.
  </Claude>
  ```
</ParamField>

### Tail Log Display

<ParamField path="tailLogCount" type="number" default="10">
  Number of tail log entries to display during execution.
</ParamField>

<ParamField path="tailLogLines" type="number" default="10">
  Number of lines to show per tail log entry.
</ParamField>

### Streaming

<ParamField path="experimentalTypedStreaming" type="boolean" default="false">
  Enable typed V3 stream parts for Claude CLI output. When enabled and no
  explicit `outputFormat` is provided, `stream-json` is used automatically.
</ParamField>

<ParamField path="legacyLogFormat" type="boolean" default="false">
  Write legacy raw text logs alongside NDJSON stream logs.
</ParamField>

<ParamField path="recordStreamEvents" type="boolean" default="true">
  Record stream events to the database when reporting is enabled.
</ParamField>

### Reporting

<ParamField path="reportingEnabled" type="boolean" default="true">
  Enable database reporting for this agent. When enabled, agent execution
  is logged to the database for observability.
</ParamField>

## AgentResult Type

```tsx
interface AgentResult<T = any> {
  output: string;              // Raw text output
  structured?: T;              // Validated structured output
  tokensUsed: {
    input: number;
    output: number;
  };
  turnsUsed: number;
  stopReason: 'completed' | 'stop_condition' | 'error' | 'cancelled';
  durationMs: number;
  exitCode?: number;
  sessionId?: string;
}
```

## Structured Output with Zod

Get typed, validated responses:

```tsx
import { z } from 'zod';

const AnalysisSchema = z.object({
  summary: z.string(),
  issues: z.array(z.object({
    severity: z.enum(['low', 'medium', 'high', 'critical']),
    file: z.string(),
    description: z.string(),
  })),
  recommendations: z.array(z.string()),
});

<Claude
  model="sonnet"
  schema={AnalysisSchema}
  maxRetries={2}
  onFinished={(result) => {
    // result.structured is typed as z.infer<typeof AnalysisSchema>
    for (const issue of result.structured.issues) {
      console.log(`[${issue.severity}] ${issue.file}: ${issue.description}`);
    }
  }}
>
  Analyze this codebase for security issues.
  Return a structured analysis.
</Claude>
```

## Tool Restrictions

Control what Claude can do:

```tsx
// Research only - no modifications
<Claude allowedTools={["Read", "Glob", "Grep"]}>
  Find all files that import the auth module.
</Claude>

// Full edit access
<Claude
  allowedTools={["Read", "Edit", "Write", "Bash"]}
  permissionMode="acceptEdits"
>
  Implement the feature.
</Claude>

// No shell access
<Claude disallowedTools={["Bash"]}>
  Analyze the code (no commands).
</Claude>
```

## Conditional Rendering

Use state to control when Claude runs:

```tsx
function ConditionalClaudeBody() {
  const { db, reactiveDb } = useSmithers();

  const { data: phaseJson } = useQueryValue<string>(
    reactiveDb,
    "SELECT value FROM state WHERE key = 'phase'"
  );
  const phase = phaseJson ? JSON.parse(phaseJson) : "research";
  const setPhase = (p: string) => db.state.set('phase', p);

  return (
    <>
      <If condition={phase === "research"}>
        <Claude
          allowedTools={["Read", "Glob"]}
          onFinished={() => setPhase("implement")}
        >
          Research the codebase.
        </Claude>
      </If>

      <If condition={phase === "implement"}>
        <Claude
          allowedTools={["Edit", "Write"]}
          onFinished={() => setPhase("done")}
        >
          Implement the solution.
        </Claude>
      </If>
    </>
  );
}

function ConditionalClaude({ db, executionId }) {
  return (
    <SmithersProvider db={db} executionId={executionId} maxIterations={5}>
      <ConditionalClaudeBody />
    </SmithersProvider>
  );
}
```

## Nested Prompt Components

Compose prompts with child components:

```tsx
<Claude model="sonnet">
  <Sqlite path="./data.db">
    Database contains users and orders tables.
  </Sqlite>

  Find the top 10 customers by order value.
  Export results to a CSV file.
</Claude>
```

## Error Handling

```tsx
function ResilientClaudeBody() {
  const { db, reactiveDb } = useSmithers();

  const { data: attemptsJson } = useQueryValue<string>(
    reactiveDb,
    "SELECT value FROM state WHERE key = 'attempts'"
  );
  const attempts = attemptsJson ? JSON.parse(attemptsJson) : 0;

  const { data: errorJson } = useQueryValue<string>(
    reactiveDb,
    "SELECT value FROM state WHERE key = 'error'"
  );
  const error = errorJson ? JSON.parse(errorJson) : null;

  return (
    <>
      <If condition={error !== null && attempts < 3}>
        <Claude
          onFinished={() => db.state.set('error', null)}
          onError={(err) => {
            db.state.set('error', err.message);
            db.state.set('attempts', attempts + 1);
          }}
        >
          Previous attempt failed: {error}
          Try a different approach.
        </Claude>
      </If>

      <If condition={error === null}>
        <Claude
          onFinished={(r) => console.log("Success:", r.output)}
          onError={(err) => db.state.set('error', err.message)}
        >
          Complete the task.
        </Claude>
      </If>
    </>
  );
}

function ResilientClaude({ db, executionId }) {
  return (
    <SmithersProvider db={db} executionId={executionId} maxIterations={3}>
      <ResilientClaudeBody />
    </SmithersProvider>
  );
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always set maxTurns for agentic tasks">
    Prevent runaway iterations:
    ```tsx
    <Claude maxTurns={10}>...</Claude>
    ```
  </Accordion>

  <Accordion title="Use allowedTools to restrict access">
    Follow principle of least privilege:
    ```tsx
    // Research phase - read only
    <Claude allowedTools={["Read", "Glob", "Grep"]}>

    // Implementation phase - edit access
    <Claude allowedTools={["Read", "Edit", "Write"]}>
    ```
  </Accordion>

  <Accordion title="Use schemas for predictable output">
    Validate responses with Zod:
    ```tsx
    <Claude schema={MySchema} maxRetries={2}>
    ```
  </Accordion>
</AccordionGroup>

## Related

<CardGroup cols={3}>
  <Card title="useClaude Hook" icon="bolt" href="/api-reference/use-claude">
    Custom rendering with the same execution
  </Card>
  <Card title="Structured Output Guide" icon="code" href="/guides/structured-output">
    Deep dive into Zod schemas
  </Card>
  <Card title="MCP Integration" icon="plug" href="/guides/mcp-integration">
    Add external tools
  </Card>
</CardGroup>
