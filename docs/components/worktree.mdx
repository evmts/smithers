---
title: Worktree Component
description: Run agents in isolated git worktrees for parallel execution
---

# Worktree Component

The `<Worktree>` component enables parallel agent isolation by running agents in [git worktrees](https://git-scm.com/docs/git-worktree). Each worktree has an isolated filesystem, preventing conflicts when multiple agents modify the same files concurrently.

## Basic Usage

```tsx
import { Worktree, Claude } from 'smithers'

function ParallelFeatureAgent() {
  return (
    <>
      <Worktree path="./worktrees/feature-a" branch="feature-a">
        <Claude>Implement feature A in the auth module</Claude>
      </Worktree>

      <Worktree path="./worktrees/feature-b" branch="feature-b">
        <Claude>Implement feature B in the database module</Claude>
      </Worktree>
    </>
  )
}
```

This creates two isolated git worktrees where agents can work on different features simultaneously without conflicts.

## Props

<ParamField path="path" type="string" required>
  Path where the worktree will be created. Can be absolute or relative to the repository root.

  ```tsx
  <Worktree path="./worktrees/feature-x">
    <Claude>Work on feature X</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="branch" type="string">
  Optional branch name. If provided, creates a new branch for the worktree. If the branch already exists, it will be checked out.

  ```tsx
  <Worktree path="./worktrees/refactor" branch="refactor-auth">
    <Claude>Refactor authentication system</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="baseBranch" type="string">
  Optional base branch to create the new branch from. Defaults to the current branch. Only used when `branch` is specified.

  ```tsx
  <Worktree
    path="./worktrees/hotfix"
    branch="hotfix-123"
    baseBranch="production"
  >
    <Claude>Fix critical bug in production</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="cleanup" type="boolean" default={true}>
  Whether to remove the worktree after execution completes. Set to `false` to preserve the worktree for inspection.

  ```tsx
  <Worktree
    path="./worktrees/debug"
    branch="debug-session"
    cleanup={false}
  >
    <Claude>Debug the rendering issue</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="onCreated" type="(path: string, branch?: string) => void">
  Callback invoked when the worktree is successfully created.

  ```tsx
  <Worktree
    path="./worktrees/feature"
    branch="feature-x"
    onCreated={(path, branch) => {
      console.log(`Worktree created at ${path} on branch ${branch}`)
    }}
  >
    <Claude>Implement feature X</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="onError" type="(error: Error) => void">
  Callback invoked if worktree creation fails.

  ```tsx
  <Worktree
    path="./worktrees/feature"
    onError={(error) => {
      console.error('Worktree creation failed:', error.message)
      notifySlack('Worktree setup failed')
    }}
  >
    <Claude>Implement feature</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="onCleanup" type="(path: string) => void">
  Callback invoked when the worktree is removed (only called when `cleanup=true`).

  ```tsx
  <Worktree
    path="./worktrees/temp"
    onCleanup={(path) => {
      console.log(`Worktree at ${path} cleaned up`)
    }}
  >
    <Claude>Temporary work</Claude>
  </Worktree>
  ```
</ParamField>

<ParamField path="children" type="ReactNode">
  Child agents (typically `<Claude>` or `<ClaudeApi>` components) that will run inside the worktree with an isolated filesystem.
</ParamField>

## Use Cases

### Parallel Feature Development

Run multiple agents working on different features simultaneously:

```tsx
import { Worktree, Claude } from 'smithers'

function ParallelDevelopment() {
  const features = [
    { name: 'auth', description: 'Add OAuth2 support' },
    { name: 'api', description: 'Add REST endpoints' },
    { name: 'ui', description: 'Update dashboard design' }
  ]

  return (
    <>
      {features.map(feature => (
        <Worktree
          key={feature.name}
          path={`./worktrees/${feature.name}`}
          branch={`feature/${feature.name}`}
          onCreated={(path, branch) => {
            console.log(`✓ Started ${feature.name} on ${branch}`)
          }}
        >
          <Claude>
            {feature.description}
          </Claude>
        </Worktree>
      ))}
    </>
  )
}
```

### Code Review in Isolation

Review changes without affecting the main working directory:

```tsx
function ReviewAgent({ prNumber }) {
  const [approved, setApproved] = useState(false)
  const [issues, setIssues] = useState([])

  return (
    <Worktree
      path={`./worktrees/pr-${prNumber}`}
      branch={`pr/${prNumber}`}
      baseBranch="main"
      cleanup={!approved}
    >
      <Claude
        tools={['Read', 'Grep', 'Glob']}
        onFinished={(result) => {
          setIssues(result.issues)
          setApproved(result.issues.length === 0)
        }}
      >
        Review the code changes in this PR.
        Look for:
        - Security issues
        - Code quality problems
        - Test coverage gaps

        Return a JSON object with issues array.
      </Claude>
    </Worktree>
  )
}
```

### Experimental Refactoring

Test refactoring ideas without risk:

```tsx
function RefactorExperiment({ approaches }) {
  const [results, setResults] = useState([])

  return (
    <>
      {approaches.map((approach, i) => (
        <Worktree
          key={i}
          path={`./worktrees/refactor-${i}`}
          branch={`experiment/refactor-${approach.name}`}
          cleanup={false}
          onCreated={(path, branch) => {
            console.log(`Testing approach: ${approach.name}`)
          }}
        >
          <Claude
            tools={['Read', 'Edit', 'Bash']}
            onFinished={(result) => {
              setResults(prev => [...prev, {
                approach: approach.name,
                result,
                path
              }])
            }}
          >
            Refactor the authentication module using this approach:
            {approach.description}

            Then run the test suite and report results.
          </Claude>
        </Worktree>
      ))}

      {results.length === approaches.length && (
        <Claude>
          Compare these refactoring results and recommend the best approach:
          {JSON.stringify(results, null, 2)}
        </Claude>
      )}
    </>
  )
}
```

### Multi-Version Testing

Test changes across multiple git branches:

```tsx
function CrossVersionTest({ branches }) {
  const [testResults, setTestResults] = useState({})

  return (
    <>
      {branches.map(branch => (
        <Worktree
          key={branch}
          path={`./worktrees/test-${branch}`}
          branch={branch}
        >
          <Claude
            tools={['Bash']}
            onFinished={(result) => {
              setTestResults(prev => ({
                ...prev,
                [branch]: result
              }))
            }}
          >
            Run the full test suite on this branch and report:
            - Test pass/fail counts
            - Any breaking changes
            - Performance metrics
          </Claude>
        </Worktree>
      ))}
    </>
  )
}
```

## Behavior Details

### Worktree Creation

When a Worktree node is encountered:

1. **Check if path exists**: If the worktree already exists at the specified path, it's reused
2. **Validate branch**: If reusing, verifies the actual branch matches the expected branch
3. **Create worktree**: Uses `git worktree add` to create a new worktree
4. **Create branch**: If `branch` prop is provided, creates a new branch (or checks out existing)
5. **Set working directory**: All child Claude nodes automatically use the worktree path as `cwd`

### Automatic `cwd` Injection

Child Claude/ClaudeApi components automatically have their working directory set to the worktree path:

```tsx
<Worktree path="./worktrees/feature">
  <Claude tools={['Read', 'Edit']}>
    {/* This Claude runs with cwd="./worktrees/feature" */}
    Read the auth.ts file and add logging
  </Claude>
</Worktree>
```

You can override this by explicitly setting `cwd` on the Claude component:

```tsx
<Worktree path="./worktrees/feature">
  <Claude cwd="/tmp">
    {/* This Claude runs with cwd="/tmp" instead */}
    Create a temporary file
  </Claude>
</Worktree>
```

### Cleanup Behavior

When `cleanup=true` (default):

1. Worktree is removed after all child agents complete
2. The branch is preserved (only the worktree directory is removed)
3. `onCleanup` callback is called with the worktree path
4. Uncommitted changes in the worktree are lost

When `cleanup=false`:

1. Worktree directory is preserved for inspection
2. You must manually remove it with `git worktree remove <path>`
3. `onCleanup` callback is not called

### Error Handling

If worktree creation fails:

1. The `onError` callback is called with the error
2. The Worktree node's execution state is marked as `error`
3. Child Claude nodes will NOT execute (prevented by error state)
4. Execution continues with other nodes

```tsx
<Worktree
  path="./worktrees/feature"
  branch="main" // Error: branch already exists elsewhere
  onError={(error) => {
    console.error('Failed to create worktree:', error.message)
    // Handle error (e.g., use different path or branch name)
  }}
>
  <Claude>This won't execute if worktree creation fails</Claude>
</Worktree>
```

### Nested Worktrees

Worktrees cannot be nested. If you need multiple isolated environments, create sibling worktrees:

```tsx
// ✓ Correct: Sibling worktrees
<>
  <Worktree path="./worktrees/feature-a">
    <Claude>Work on feature A</Claude>
  </Worktree>

  <Worktree path="./worktrees/feature-b">
    <Claude>Work on feature B</Claude>
  </Worktree>
</>

// ✗ Incorrect: Nested worktrees
<Worktree path="./worktrees/parent">
  <Worktree path="./worktrees/parent/child">
    <Claude>This won't work</Claude>
  </Worktree>
</Worktree>
```

## Security Considerations

### Branch Name Validation

Branch names are validated to prevent command injection:

- Allowed characters: alphanumeric, dash, underscore, slash, dot
- Rejected patterns: names starting with dash, `..`, `@{`, `~`
- This prevents malicious branch names from executing arbitrary commands

### Safe Command Execution

All git commands use `execFileSync()` instead of `execSync()` to prevent shell interpretation and command injection.

## Git Requirements

The Worktree component requires:

- Git version 2.5 or later (worktree support)
- Working directory must be inside a git repository
- Sufficient permissions to create worktrees

## Mock Mode

In mock mode (`mockMode: true`), worktrees are not actually created:

- `onCreated` callback is still called (with mock path)
- `onCleanup` callback is NOT called (no real cleanup happened)
- Git commands are skipped
- Useful for testing without filesystem operations

```tsx
const result = await executePlan(<MyAgent />, {
  mockMode: true // Worktrees won't be created
})
```

## Performance Considerations

### Worktree Creation Cost

Creating a worktree is fast (~100ms) but involves disk I/O:

- First worktree: ~100-200ms (checkout files)
- Subsequent worktrees: ~50-100ms (shared objects)
- Cleanup: ~50ms (remove directory)

### Disk Space

Each worktree uses disk space for:

- Working directory files (~size of repository)
- Git metadata (minimal, shared with main repo)

Plan for adequate disk space when running many parallel worktrees.

### Parallel Execution

Worktrees enable true parallel execution:

```tsx
// These agents run simultaneously, each in isolated filesystem
<>
  <Worktree path="./worktrees/a">
    <Claude>Task A</Claude>
  </Worktree>

  <Worktree path="./worktrees/b">
    <Claude>Task B</Claude>
  </Worktree>
</>
```

Without worktrees, agents share the same filesystem and can conflict.

## Related

<CardGroup cols={2}>
  <Card title="Subagent Component" icon="network-wired" href="/components/subagent">
    Orchestrate multiple agents with parallel execution
  </Card>
  <Card title="Claude Component" icon="robot" href="/components/claude">
    Configure working directory with cwd prop
  </Card>
</CardGroup>
