---
title: Prompt Structure Components
description: Persona, Constraints, and OutputFormat for structured prompts
---

# Prompt Structure Components

Smithers provides semantic components for structuring prompts: `<Persona>`, `<Constraints>`, and `<OutputFormat>`. These help create consistent, well-organized prompts.

## Persona

Defines the agent's role and expertise.

### Props

<ParamField path="role" type="string" required>
  The persona's role or title.
</ParamField>

<ParamField path="children" type="ReactNode">
  Additional details about the persona's background, expertise, or approach.
</ParamField>

### Usage

```tsx
import { Claude, Persona } from 'smithers'

<Claude>
  <Persona role="Senior Security Engineer">
    You have 15 years of experience in application security.
    You've worked at major tech companies and consulted for Fortune 500s.
    You prioritize practical, actionable advice over theoretical perfection.
  </Persona>

  Review this authentication implementation...
</Claude>
```

Renders to:

```xml
<claude>
  <persona role="Senior Security Engineer">
    You have 15 years of experience in application security.
    You've worked at major tech companies and consulted for Fortune 500s.
    You prioritize practical, actionable advice over theoretical perfection.
  </persona>

  Review this authentication implementation...
</claude>
```

### Reusable Personas

Create a library of reusable personas:

```tsx
// personas.tsx
export function SecurityExpert({ children }) {
  return (
    <Persona role="Security Expert">
      Senior application security engineer with expertise in OWASP Top 10,
      secure coding practices, and threat modeling.
      {children}
    </Persona>
  )
}

export function DatabaseArchitect({ children }) {
  return (
    <Persona role="Database Architect">
      15 years of experience with PostgreSQL, MySQL, MongoDB, and Redis.
      Expert in query optimization, indexing strategies, and data modeling.
      {children}
    </Persona>
  )
}

export function TechLead({ children }) {
  return (
    <Persona role="Tech Lead">
      Experienced engineering leader focused on code quality, team velocity,
      and sustainable development practices.
      {children}
    </Persona>
  )
}

// Usage
import { SecurityExpert } from './personas'

<Claude tools={[filesystem]}>
  <SecurityExpert>
    Particularly focused on API security today.
  </SecurityExpert>
  Audit the API endpoints...
</Claude>
```

## Constraints

Defines rules and limitations for the agent's behavior.

### Props

<ParamField path="children" type="ReactNode" required>
  The constraint rules, typically as a bulleted list.
</ParamField>

### Usage

```tsx
<Claude>
  <Constraints>
    - Never modify production data directly
    - Always explain your reasoning before suggesting changes
    - Keep responses under 500 words unless asked for more detail
    - If requirements are ambiguous, ask clarifying questions
    - Prioritize security over convenience
  </Constraints>

  Help me refactor this database migration...
</Claude>
```

Renders to:

```xml
<claude>
  <constraints>
    - Never modify production data directly
    - Always explain your reasoning before suggesting changes
    - Keep responses under 500 words unless asked for more detail
    - If requirements are ambiguous, ask clarifying questions
    - Prioritize security over convenience
  </constraints>

  Help me refactor this database migration...
</claude>
```

### Reusable Constraint Sets

```tsx
// constraints.tsx
export function SafeCodeConstraints() {
  return (
    <Constraints>
      - No destructive operations without explicit confirmation
      - Always create backups before modifying files
      - Test changes in isolation before applying broadly
      - Log all significant actions for audit trails
    </Constraints>
  )
}

export function StyleConstraints({ style }) {
  return (
    <Constraints>
      - Follow {style} style guide
      - Use consistent naming conventions
      - Add comments for complex logic only
      - Prefer readability over cleverness
    </Constraints>
  )
}

export function ConciseConstraints() {
  return (
    <Constraints>
      - Be direct and concise
      - Skip unnecessary preamble
      - Use bullet points for lists
      - Only elaborate when asked
    </Constraints>
  )
}
```

## OutputFormat

Specifies the expected response structure.

### Props

<ParamField path="schema" type="object">
  JSON Schema or simple object describing the expected output structure.
</ParamField>

<ParamField path="children" type="ReactNode">
  Human-readable description of the expected format.
</ParamField>

### Usage

```tsx
<Claude>
  Analyze this code for issues.

  <OutputFormat schema={{
    type: 'object',
    properties: {
      summary: { type: 'string' },
      issues: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            severity: { enum: ['critical', 'high', 'medium', 'low'] },
            file: { type: 'string' },
            line: { type: 'number' },
            message: { type: 'string' },
            suggestion: { type: 'string' }
          }
        }
      },
      metrics: {
        type: 'object',
        properties: {
          totalIssues: { type: 'number' },
          criticalCount: { type: 'number' }
        }
      }
    }
  }}>
    Return valid JSON matching the schema.
    No markdown code blocks, just raw JSON.
  </OutputFormat>
</Claude>
```

### Simple Format Descriptions

For simpler cases, just describe the format:

```tsx
<OutputFormat>
  Return a markdown document with:
  - A summary section (2-3 sentences)
  - A bulleted list of key findings
  - A recommendations section with actionable items
</OutputFormat>
```

### Reusable Output Formats

```tsx
// output-formats.tsx
export function JSONOutput({ schema }) {
  return (
    <OutputFormat schema={schema}>
      Respond with valid JSON matching the schema.
      No markdown, no explanation, just the JSON object.
    </OutputFormat>
  )
}

export function MarkdownReport() {
  return (
    <OutputFormat>
      Return a well-structured markdown document with:
      - Clear headings (##, ###)
      - Bulleted lists for multiple items
      - Code blocks with language tags
      - A summary at the end
    </OutputFormat>
  )
}

export function CodeOnlyOutput({ language }) {
  return (
    <OutputFormat>
      Return only the {language} code.
      No explanations, no markdown blocks, just raw code.
      Include necessary imports.
    </OutputFormat>
  )
}
```

## Composing All Together

Combine all structural components for well-organized prompts:

```tsx
function SecurityAudit({ codebase }) {
  return (
    <Claude tools={[filesystem, grep]}>
      <Persona role="Security Auditor">
        CISSP-certified security professional with expertise in
        web application security and secure code review.
      </Persona>

      <Constraints>
        - Focus on OWASP Top 10 vulnerabilities
        - Prioritize issues by severity and exploitability
        - Provide actionable remediation steps
        - Don't flag theoretical issues without evidence
      </Constraints>

      <Phase name="audit">
        <Step>Scan {codebase} for security vulnerabilities</Step>
        <Step>Analyze authentication and authorization flows</Step>
        <Step>Check for injection vulnerabilities</Step>
        <Step>Review cryptographic implementations</Step>
      </Phase>

      <OutputFormat schema={{
        vulnerabilities: [{
          id: 'string',
          severity: 'critical | high | medium | low',
          category: 'string',
          location: 'string',
          description: 'string',
          remediation: 'string',
          references: 'string[]'
        }],
        summary: {
          total: 'number',
          critical: 'number',
          high: 'number',
          riskScore: 'number'
        }
      }}>
        Return valid JSON matching the schema.
      </OutputFormat>
    </Claude>
  )
}
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Be specific in personas" icon="user">
    Detailed personas produce more consistent, in-character responses
  </Card>
  <Card title="Keep constraints actionable" icon="list-check">
    Each constraint should be something Claude can actually follow
  </Card>
  <Card title="Match output format to use case" icon="code">
    Use JSON schemas when you need to parse output programmatically
  </Card>
  <Card title="Create reusable libraries" icon="puzzle-piece">
    Build a library of personas, constraints, and formats for your domain
  </Card>
</CardGroup>

## Related

<CardGroup cols={2}>
  <Card title="Claude Component" icon="cube" href="/components/claude">
    The container for prompt structure components
  </Card>
  <Card title="Phase & Step" icon="list" href="/components/phase-step">
    Organize multi-step prompts
  </Card>
</CardGroup>
