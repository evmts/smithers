---
title: SmithersProvider
description: Unified context provider for database, execution state, and task orchestration
---

# SmithersProvider

The `<SmithersProvider>` component provides unified context to all child components, including database access, execution state, and task orchestration (previously handled by Ralph). It's required at the root of every Smithers workflow.

<Note>
As of the latest version, SmithersProvider consolidates SmithersProvider, RalphContext, and DatabaseProvider into a single provider. You no longer need to wrap your components in `<Ralph>` - SmithersProvider handles iteration and task tracking automatically.
</Note>

## Basic Usage

```tsx
import { createSmithersDB } from "smithers-orchestrator/db";
import { SmithersProvider, Orchestration, Claude } from "smithers-orchestrator/components";

const db = await createSmithersDB({ path: ".smithers/my-workflow" });
const executionId = await db.execution.start("My Workflow", "workflow.tsx");

function Workflow() {
  return (
    <SmithersProvider db={db} executionId={executionId} maxIterations={10}>
      <Orchestration>
        <Claude model="sonnet">
          Do the work.
        </Claude>
      </Orchestration>
    </SmithersProvider>
  );
}
```

## Props

<ParamField path="db" type="SmithersDB" required>
  The database instance for state persistence.

  ```tsx
  const db = await createSmithersDB({ path: ".smithers/data" });
  <SmithersProvider db={db} executionId={executionId}>
  ```
</ParamField>

<ParamField path="executionId" type="string" required>
  Unique identifier for the current execution.

  ```tsx
  const executionId = await db.execution.start("Task", "task.tsx");
  <SmithersProvider db={db} executionId={executionId}>
  ```
</ParamField>

<ParamField path="config" type="SmithersConfig">
  Optional configuration for the workflow.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    config={{
      defaultModel: "sonnet",
      verbose: true,
    }}
  >
  ```
</ParamField>

<ParamField path="maxIterations" type="number" default="100">
  Maximum number of iteration loops before stopping. This replaces the `maxIterations` prop from Ralph.

  ```tsx
  <SmithersProvider db={db} executionId={executionId} maxIterations={10}>
    {/* Will stop after 10 iterations */}
  </SmithersProvider>
  ```
</ParamField>

<ParamField path="onIteration" type="(iteration: number) => void">
  Called at the start of each iteration. Useful for logging or progress tracking.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onIteration={(i) => console.log(`Starting iteration ${i}`)}
  >
  ```
</ParamField>

<ParamField path="onComplete" type="() => void">
  Called when orchestration completes (all tasks finished or max iterations reached).

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onComplete={() => console.log("Workflow finished")}
  >
  ```
</ParamField>

## Context Values

Child components can access the context using the `useSmithers` hook:

```tsx
import { useSmithers } from "smithers-orchestrator/components";

function MyComponent() {
  const {
    db,                // Database instance (SmithersDB)
    executionId,       // Current execution ID
    config,            // Configuration
    requestStop,       // Request workflow stop
    requestRebase,     // Request rebase operation
    isStopRequested,   // Check if stop was requested
    isRebaseRequested, // Check if rebase was requested
    ralphCount,        // Current iteration count
    reactiveDb,        // Raw ReactiveDatabase for useQuery
  } = useSmithers();

  return (
    <Claude onFinished={() => {
      if (someCondition) {
        requestStop("Condition met");
      }
    }}>
      Work with context access.
    </Claude>
  );
}
```

## Task Tracking

Components can register and complete tasks using the database-backed task system:

```tsx
import { useSmithers } from "smithers-orchestrator/components";
import { useRef } from "react";
import { useMount } from "smithers-orchestrator/reconciler/hooks";

function CustomAsyncStep() {
  const { db } = useSmithers();
  const taskIdRef = useRef<string | null>(null);

  useMount(() => {
    // Register a task with the database
    taskIdRef.current = db.tasks.start('custom-step', 'Processing data');

    fetchData().then((data) => {
      processData(data);
      // Mark task complete
      if (taskIdRef.current) {
        db.tasks.complete(taskIdRef.current);
      }
    });
  });

  return <step-node />;
}
```

The orchestration loop monitors the tasks table and automatically advances to the next iteration when all running tasks complete.

## Request Stop

Stop the workflow programmatically:

```tsx
function EmergencyStop() {
  const { requestStop, isStopRequested } = useSmithers();

  return (
    <Claude
      onFinished={(result) => {
        if (result.output.includes("CRITICAL")) {
          requestStop("Critical issue found");
        }
      }}
    >
      Check for critical issues.
    </Claude>
  );
}

function ConditionalWork() {
  const { isStopRequested } = useSmithers();

  // Don't render if stop was requested
  if (isStopRequested()) {
    return null;
  }

  return (
    <Claude>Continue working.</Claude>
  );
}
```

## Accessing the Database

Access the database directly from any child component:

```tsx
function DatabaseAccessExample() {
  const { db, executionId } = useSmithers();

  useMount(async () => {
    // Read state
    const phase = await db.state.get("phase");

    // Write state
    await db.state.set("lastAccess", Date.now());

    // Log an agent
    await db.agents.start("Custom agent", "sonnet");

    // Track a task
    const taskId = db.tasks.start("database-example", "Fetching data");
    // ... do work ...
    db.tasks.complete(taskId);
  });

  return <Claude>Work with database access.</Claude>;
}
```

## Reactive Queries

Use reactive database queries with the `useQuery` hook:

```tsx
import { useQuery } from "smithers-orchestrator/reactive-sqlite";

function TaskMonitor() {
  const { reactiveDb } = useSmithers();

  // Automatically re-renders when tasks table changes
  const { data: runningTasks } = useQuery(
    reactiveDb,
    "SELECT * FROM tasks WHERE status = 'running'"
  );

  return (
    <div>
      Running tasks: {runningTasks?.length ?? 0}
    </div>
  );
}
```

## Complete Example

```tsx
import { createSmithersRoot, createSmithersDB } from "smithers-orchestrator";
import { SmithersProvider, Orchestration, Claude, useSmithers } from "smithers-orchestrator/components";

async function main() {
  const db = await createSmithersDB({ path: ".smithers/example" });

  // Check for incomplete execution to resume
  let executionId: string;
  const incomplete = await db.execution.findIncomplete();

  if (incomplete) {
    executionId = incomplete.id;
    console.log("Resuming execution:", executionId);
  } else {
    executionId = await db.execution.start("Example", "example.tsx");
  }

  function Workflow() {
    return (
      <SmithersProvider
        db={db}
        executionId={executionId}
        maxIterations={10}
        onIteration={(i) => console.log(`Iteration ${i}`)}
        onComplete={() => console.log("Workflow complete")}
      >
        <Orchestration globalTimeout={3600000}>
          <WorkflowContent />
        </Orchestration>
      </SmithersProvider>
    );
  }

  const root = createSmithersRoot();
  await root.mount(Workflow);

  await db.execution.complete(executionId);
  await db.close();
}

function WorkflowContent() {
  const { db, requestStop, isStopRequested } = useSmithers();
  const [phase, setPhase] = useState("start");

  useMount(async () => {
    const savedPhase = await db.state.get("phase");
    if (savedPhase) setPhase(savedPhase);
  });

  const updatePhase = async (newPhase: string) => {
    setPhase(newPhase);
    await db.state.set("phase", newPhase);
  };

  if (isStopRequested()) {
    return <Stop reason="Stop requested" />;
  }

  return (
    <>
      {phase === "start" && (
        <Claude onFinished={() => updatePhase("done")}>
          Complete the task.
        </Claude>
      )}
    </>
  );
}

main();
```

## Migration from Ralph

If you're migrating from the old Ralph-based pattern:

<CodeGroup>
```tsx Before (with Ralph)
<SmithersProvider db={db} executionId={executionId}>
  <Orchestration>
    <Ralph maxIterations={10} onComplete={() => console.log("Done")}>
      <Claude>Do work</Claude>
    </Ralph>
  </Orchestration>
</SmithersProvider>
```

```tsx After (unified provider)
<SmithersProvider
  db={db}
  executionId={executionId}
  maxIterations={10}
  onComplete={() => console.log("Done")}
>
  <Orchestration>
    <Claude>Do work</Claude>
  </Orchestration>
</SmithersProvider>
```
</CodeGroup>

For task tracking in custom components:

<CodeGroup>
```tsx Before (Ralph context)
const ralph = useContext(RalphContext);
ralph?.registerTask();
// ... work ...
ralph?.completeTask();
```

```tsx After (db.tasks)
const { db } = useSmithers();
const taskId = db.tasks.start('component-type', 'description');
try {
  // ... work ...
} finally {
  db.tasks.complete(taskId);
}
```
</CodeGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Always wrap with SmithersProvider">
    All Smithers components require the provider:
    ```tsx
    // Correct
    <SmithersProvider db={db} executionId={executionId}>
      <Claude>...</Claude>
    </SmithersProvider>

    // Error - no context
    <Claude>...</Claude>
    ```
  </Accordion>

  <Accordion title="Set maxIterations to prevent runaway loops">
    Always set a reasonable iteration limit:
    ```tsx
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}  // Prevents infinite loops
    >
    ```
  </Accordion>

  <Accordion title="Use db.tasks for task tracking">
    Register async work with the database for proper orchestration:
    ```tsx
    const taskId = db.tasks.start('async-work');
    try {
      await doAsyncWork();
    } finally {
      db.tasks.complete(taskId);
    }
    ```
  </Accordion>

  <Accordion title="Close the database when done">
    Ensure writes are flushed:
    ```tsx
    const root = createSmithersRoot();
    await root.mount(Workflow);
    await db.close();  // Always close
    ```
  </Accordion>
</AccordionGroup>

## Related

<CardGroup cols={2}>
  <Card title="Database API" icon="database" href="/api-reference/database">
    Full database API reference
  </Card>
  <Card title="Orchestration" icon="sitemap" href="/components/orchestration">
    Top-level workflow control
  </Card>
  <Card title="Ralph (Legacy)" icon="rotate" href="/components/ralph">
    Legacy loop controller (deprecated)
  </Card>
</CardGroup>
