---
title: SmithersProvider
description: Root orchestration context provider. Provides database, execution context, and global controls.
---

# SmithersProvider

Root component. Required. Provides database, execution context, and global controls.

```tsx
const db = createSmithersDB({ path: ".smithers/data" });
const executionId = db.execution.start("Task", "task.tsx");

<SmithersProvider db={db} executionId={executionId}>
  <Claude>Do the work once.</Claude>
</SmithersProvider>
```

<Note>
**Phased workflows require Ralph/While** - Phase and Step components work by re-rendering on each iteration. Without a loop wrapper, they run once and stop.
</Note>

For iterative workflows, wrap with `<Ralph>` or `<While>` - see [Ralph](/components/ralph):

```tsx
<SmithersProvider db={db} executionId={executionId}>
  <Ralph id="workflow" condition={() => phase !== 'done'} maxIterations={10}>
    <Phase name="research">...</Phase>
    <Phase name="implement">...</Phase>
  </Ralph>
</SmithersProvider>
```

## Props

<ParamField path="db" type="SmithersDB" required>
  The database instance for state persistence.

  ```tsx
  const db = createSmithersDB({ path: ".smithers/data" });
  <SmithersProvider db={db} executionId={executionId}>
  ```
</ParamField>

<ParamField path="executionId" type="string" required>
  Unique identifier for the current execution.

  ```tsx
  const executionId = db.execution.start("Task", "task.tsx");
  <SmithersProvider db={db} executionId={executionId}>
  ```
</ParamField>

<ParamField path="config" type="SmithersConfig">
  Optional configuration for the workflow. Note: `maxIterations` must be set inside this `config` object, not as a top-level prop.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    config={{
      defaultModel: "sonnet",
      maxIterations: 20,  // Default for Ralph/While loops
      verbose: true,
    }}
  >
  ```

  **SmithersConfig properties:**
  - `defaultModel`: Default model for Claude agents
  - `maxIterations`: Default max iterations for Ralph/While loops (default: 10). Individual loops can override via `maxIterations` prop. **Must be in `config`, not a top-level prop.**
  - `globalTimeout`: Global timeout in milliseconds
  - `verbose`: Enable verbose logging
  - `extra`: Additional configuration for extensibility
</ParamField>

<ParamField path="globalTimeout" type="number">
  Maximum time in milliseconds for the entire workflow.

  ```tsx
  <SmithersProvider db={db} executionId={executionId} globalTimeout={3600000}>
    {/* Will stop after 1 hour */}
  </SmithersProvider>
  ```
</ParamField>

<ParamField path="stopConditions" type="GlobalStopCondition[]">
  Array of conditions that can stop the workflow early.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    stopConditions={[
      { type: "total_tokens", value: 100000 },
      { type: "total_agents", value: 50 },
    ]}
  >
  ```
</ParamField>

<ParamField path="snapshotBeforeStart" type="boolean">
  Create a VCS snapshot before starting (useful for rollback).

  ```tsx
  <SmithersProvider db={db} executionId={executionId} snapshotBeforeStart>
  ```
</ParamField>

<ParamField path="onError" type="(error: Error) => void">
  Called when workflow encounters an error.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onError={(err) => console.error("Workflow failed:", err)}
  >
  ```
</ParamField>

<ParamField path="onStopRequested" type="(reason: string) => void">
  Called when a stop is requested (via stop condition or manual request).

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onStopRequested={(reason) => console.log("Stop:", reason)}
  >
  ```
</ParamField>

<ParamField path="cleanupOnComplete" type="boolean">
  Close the database when workflow completes.

  ```tsx
  <SmithersProvider db={db} executionId={executionId} cleanupOnComplete>
  ```
</ParamField>

<ParamField path="middleware" type="SmithersMiddleware[]">
  Array of middleware functions for request/response processing.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    middleware={[loggingMiddleware, retryMiddleware]}
  >
  ```
</ParamField>

<ParamField path="onComplete" type="() => void">
  Called when orchestration completes.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onComplete={() => console.log("Workflow finished")}
  >
  ```
</ParamField>

## Context Values

Child components can access the context using the `useSmithers` hook:

```tsx
import { useSmithers } from "smithers-orchestrator";

function MyComponent() {
  const {
    db,                // Database instance (SmithersDB)
    executionId,       // Current execution ID
    config,            // Configuration
    requestStop,       // Request workflow stop
    requestRebase,     // Request rebase operation
    isStopRequested,   // Check if stop was requested
    isRebaseRequested, // Check if rebase was requested
    reactiveDb,        // Raw ReactiveDatabase for useQuery
  } = useSmithers();

  return (
    <Claude model={config?.defaultModel}>
      Work with context access.
    </Claude>
  );
}
```

## Task Tracking

Components can register and complete tasks using the database-backed task system:

```tsx
import { useSmithers, useMount } from "smithers-orchestrator";
import { useRef } from "react";

function CustomAsyncStep() {
  const { db } = useSmithers();
  const taskIdRef = useRef<string | null>(null);

  useMount(() => {
    // Register a task with the database
    taskIdRef.current = db.tasks.start('custom-step', 'Processing data');

    fetchData().then((data) => {
      processData(data);
      // Mark task complete
      if (taskIdRef.current) {
        db.tasks.complete(taskIdRef.current);
      }
    });
  });

  return null;
}
```

When using Ralph/While, the loop monitors the tasks table and automatically advances to the next iteration when all running tasks complete.

## Request Stop

Stop the workflow programmatically:

```tsx
function EmergencyStop() {
  const { requestStop, isStopRequested } = useSmithers();

  return (
    <Claude
      onFinished={(result) => {
        if (result.output.includes("CRITICAL")) {
          requestStop("Critical issue found");
        }
      }}
    >
      Check for critical issues.
    </Claude>
  );
}

function ConditionalWork() {
  const { isStopRequested } = useSmithers();

  // Don't render if stop was requested
  if (isStopRequested()) {
    return null;
  }

  return (
    <Claude>Continue working.</Claude>
  );
}
```

## Accessing the Database

Access the database directly from any child component:

```tsx
function DatabaseAccessExample() {
  const { db, executionId } = useSmithers();

  useMount(async () => {
    // Read state
    const phase = db.state.get("phase");

    // Write state
    db.state.set("lastAccess", Date.now());

    // Log an agent
    db.agents.start("Custom agent", "sonnet");

    // Track a task
    const taskId = db.tasks.start("database-example", "Fetching data");
    // ... do work ...
    db.tasks.complete(taskId);
  });

  return <Claude>Work with database access.</Claude>;
}
```

## Reactive Queries

Use reactive database queries with the `useQueryValue` hook:

```tsx
import { useQueryValue } from "smithers-orchestrator/db";

function TaskMonitor() {
  const { db } = useSmithers();

  // Automatically re-renders when tasks table changes
  const runningCount = useQueryValue<number>(
    db.db,
    "SELECT COUNT(*) as c FROM tasks WHERE status = 'running'"
  );

  return (
    <div>
      Running tasks: {runningCount ?? 0}
    </div>
  );
}
```

## Complete Example

```tsx
import { createSmithersRoot, createSmithersDB } from "smithers-orchestrator";
import { SmithersProvider, Claude, Ralph, Phase, useSmithers, If, Stop } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator/db";

async function main() {
  const db = createSmithersDB({ path: ".smithers/example" });

  // Check for incomplete execution to resume
  let executionId: string;
  const incomplete = db.execution.findIncomplete();

  if (incomplete) {
    executionId = incomplete.id;
    console.log("Resuming execution:", executionId);
  } else {
    executionId = db.execution.start("Example", "example.tsx");
  }

  function Workflow() {
    return (
      <SmithersProvider
        db={db}
        executionId={executionId}
        globalTimeout={3600000}
        stopConditions={[
          { type: "total_tokens", value: 100000 }
        ]}
      >
        <WorkflowContent />
      </SmithersProvider>
    );
  }

  const root = createSmithersRoot();
  await root.mount(Workflow);

  db.execution.complete(executionId);
  db.close();
}

function WorkflowContent() {
  const { db, reactiveDb, requestStop, isStopRequested } = useSmithers();
  
  const phase = useQueryValue<string>(
    reactiveDb,
    "SELECT value FROM state WHERE key = 'phase'"
  );
  const currentPhase = phase ? JSON.parse(phase) : "research";
  
  const setPhase = (p: string) => db.state.set('phase', p);

  if (isStopRequested()) {
    return <Stop reason="Stop requested" />;
  }

  return (
    <Ralph 
      id="workflow" 
      condition={() => currentPhase !== 'done'} 
      maxIterations={10}
    >
      <Phase name="research">
        <Claude onFinished={() => setPhase("implement")}>
          Research the problem space.
        </Claude>
      </Phase>

      <Phase name="implement">
        <Claude onFinished={() => setPhase("done")}>
          Implement the solution.
        </Claude>
      </Phase>
    </Ralph>
  );
}

main();
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always wrap with SmithersProvider">
    All Smithers components require the provider:
    ```tsx
    // Correct
    <SmithersProvider db={db} executionId={executionId}>
      <Claude>...</Claude>
    </SmithersProvider>

    // Error - no context
    <Claude>...</Claude>
    ```
  </Accordion>

  <Accordion title="Use Ralph/While for iterative workflows">
    SmithersProvider doesn't loop - wrap with Ralph for iterations:
    ```tsx
    <SmithersProvider db={db} executionId={executionId}>
      <Ralph id="main" maxIterations={10}>
        <Phase name="work">...</Phase>
      </Ralph>
    </SmithersProvider>
    ```
  </Accordion>

  <Accordion title="Use db.tasks for task tracking">
    Register async work with the database for proper orchestration:
    ```tsx
    const taskId = db.tasks.start('async-work');
    try {
      await doAsyncWork();
    } finally {
      db.tasks.complete(taskId);
    }
    ```
  </Accordion>

  <Accordion title="Close the database when done">
    Ensure writes are flushed:
    ```tsx
    const root = createSmithersRoot();
    await root.mount(Workflow);
    db.close();  // Always close
    ```
  </Accordion>
</AccordionGroup>

## Related

<CardGroup cols={2}>
  <Card title="Database API" icon="database" href="/api-reference/database">
    Full database API reference
  </Card>
  <Card title="Ralph" icon="rotate" href="/components/ralph">
    Loop controller component
  </Card>
  <Card title="Phase" icon="list" href="/components/phase">
    Workflow structure
  </Card>
</CardGroup>
