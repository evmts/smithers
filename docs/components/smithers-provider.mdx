---
title: SmithersProvider
description: Unified context provider for database, execution state, and task orchestration
---

# SmithersProvider

The `<SmithersProvider>` component provides unified context to all child components, including database access, execution state, task orchestration, global timeouts, and stop conditions. It's required at the root of every Smithers workflow.

SmithersProvider extends [Ralph](/components/ralph) with additional database and orchestration features. All Ralph props (`maxIterations`, `onIteration`, `onComplete`) are supported and documented below.

## Basic Usage

```tsx
import { createSmithersDB } from "smithers-orchestrator/db";
import { SmithersProvider, Claude } from "smithers-orchestrator/components";

const db = await createSmithersDB({ path: ".smithers/my-workflow" });
const executionId = await db.execution.start("My Workflow", "workflow.tsx");

function Workflow() {
  return (
    <SmithersProvider db={db} executionId={executionId} maxIterations={10}>
      <Claude model="sonnet">
        Do the work.
      </Claude>
    </SmithersProvider>
  );
}
```

## Props

<ParamField path="db" type="SmithersDB" required>
  The database instance for state persistence.

  ```tsx
  const db = await createSmithersDB({ path: ".smithers/data" });
  <SmithersProvider db={db} executionId={executionId}>
  ```
</ParamField>

<ParamField path="executionId" type="string" required>
  Unique identifier for the current execution.

  ```tsx
  const executionId = await db.execution.start("Task", "task.tsx");
  <SmithersProvider db={db} executionId={executionId}>
  ```
</ParamField>

<ParamField path="config" type="SmithersConfig">
  Optional configuration for the workflow.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    config={{
      defaultModel: "sonnet",
      verbose: true,
    }}
  >
  ```
</ParamField>

<ParamField path="maxIterations" type="number" default="100">
  Maximum number of iteration loops before stopping.

  ```tsx
  <SmithersProvider db={db} executionId={executionId} maxIterations={10}>
    {/* Will stop after 10 iterations */}
  </SmithersProvider>
  ```
</ParamField>

<ParamField path="onIteration" type="(iteration: number) => void">
  Called at the start of each iteration. Useful for logging or progress tracking.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onIteration={(i) => console.log(`Starting iteration ${i}`)}
  >
  ```
</ParamField>

<ParamField path="onComplete" type="() => void">
  Called when orchestration completes (all tasks finished or max iterations reached).

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onComplete={() => console.log("Workflow finished")}
  >
  ```
</ParamField>

<ParamField path="globalTimeout" type="number">
  Maximum time in milliseconds for the entire workflow.

  ```tsx
  <SmithersProvider db={db} executionId={executionId} globalTimeout={3600000}>
    {/* Will stop after 1 hour */}
  </SmithersProvider>
  ```
</ParamField>

<ParamField path="stopConditions" type="GlobalStopCondition[]">
  Array of conditions that can stop the workflow early.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    stopConditions={[
      { type: "total_tokens", value: 100000 },
      { type: "total_agents", value: 50 },
    ]}
  >
  ```
</ParamField>

<ParamField path="snapshotBeforeStart" type="boolean">
  Create a VCS snapshot before starting (useful for rollback).

  ```tsx
  <SmithersProvider db={db} executionId={executionId} snapshotBeforeStart>
  ```
</ParamField>

<ParamField path="onError" type="(error: Error) => void">
  Called when workflow encounters an error.

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onError={(err) => console.error("Workflow failed:", err)}
  >
  ```
</ParamField>

<ParamField path="onStopRequested" type="(reason: string) => void">
  Called when a stop is requested (via stop condition or manual request).

  ```tsx
  <SmithersProvider
    db={db}
    executionId={executionId}
    onStopRequested={(reason) => console.log("Stop:", reason)}
  >
  ```
</ParamField>

<ParamField path="cleanupOnComplete" type="boolean">
  Close the database when workflow completes.

  ```tsx
  <SmithersProvider db={db} executionId={executionId} cleanupOnComplete>
  ```
</ParamField>

## Context Values

Child components can access the context using the `useSmithers` hook:

```tsx
import { useSmithers } from "smithers-orchestrator/components";

function MyComponent() {
  const {
    db,                // Database instance (SmithersDB)
    executionId,       // Current execution ID
    config,            // Configuration
    requestStop,       // Request workflow stop
    requestRebase,     // Request rebase operation
    isStopRequested,   // Check if stop was requested
    isRebaseRequested, // Check if rebase was requested
    ralphCount,        // Current iteration count
    reactiveDb,        // Raw ReactiveDatabase for useQuery
  } = useSmithers();

  return (
    <Claude model={config?.defaultModel}>
      Current iteration: {ralphCount}. Work with context access.
    </Claude>
  );
}
```

## Task Tracking

Components can register and complete tasks using the database-backed task system:

```tsx
import { useSmithers } from "smithers-orchestrator/components";
import { useRef } from "react";
import { useMount } from "smithers-orchestrator/reconciler/hooks";

function CustomAsyncStep() {
  const { db } = useSmithers();
  const taskIdRef = useRef<string | null>(null);

  useMount(() => {
    // Register a task with the database
    taskIdRef.current = db.tasks.start('custom-step', 'Processing data');

    fetchData().then((data) => {
      processData(data);
      // Mark task complete
      if (taskIdRef.current) {
        db.tasks.complete(taskIdRef.current);
      }
    });
  });

  return <step-node />;
}
```

The orchestration loop monitors the tasks table and automatically advances to the next iteration when all running tasks complete.

## Request Stop

Stop the workflow programmatically:

```tsx
function EmergencyStop() {
  const { requestStop, isStopRequested } = useSmithers();

  return (
    <Claude
      onFinished={(result) => {
        if (result.output.includes("CRITICAL")) {
          requestStop("Critical issue found");
        }
      }}
    >
      Check for critical issues.
    </Claude>
  );
}

function ConditionalWork() {
  const { isStopRequested } = useSmithers();

  // Don't render if stop was requested
  if (isStopRequested()) {
    return null;
  }

  return (
    <Claude>Continue working.</Claude>
  );
}
```

## Accessing the Database

Access the database directly from any child component:

```tsx
function DatabaseAccessExample() {
  const { db, executionId } = useSmithers();

  useMount(async () => {
    // Read state
    const phase = await db.state.get("phase");

    // Write state
    await db.state.set("lastAccess", Date.now());

    // Log an agent
    await db.agents.start("Custom agent", "sonnet");

    // Track a task
    const taskId = db.tasks.start("database-example", "Fetching data");
    // ... do work ...
    db.tasks.complete(taskId);
  });

  return <Claude>Work with database access.</Claude>;
}
```

## Reactive Queries

Use reactive database queries with the `useQuery` hook:

```tsx
import { useQuery } from "smithers-orchestrator/reactive-sqlite";

function TaskMonitor() {
  const { reactiveDb } = useSmithers();

  // Automatically re-renders when tasks table changes
  const { data: runningTasks } = useQuery(
    reactiveDb,
    "SELECT * FROM tasks WHERE status = 'running'"
  );

  return (
    <div>
      Running tasks: {runningTasks?.length ?? 0}
    </div>
  );
}
```

## Complete Example

```tsx
import { createSmithersRoot, createSmithersDB } from "smithers-orchestrator";
import { SmithersProvider, Claude, useSmithers } from "smithers-orchestrator/components";

async function main() {
  const db = await createSmithersDB({ path: ".smithers/example" });

  // Check for incomplete execution to resume
  let executionId: string;
  const incomplete = await db.execution.findIncomplete();

  if (incomplete) {
    executionId = incomplete.id;
    console.log("Resuming execution:", executionId);
  } else {
    executionId = await db.execution.start("Example", "example.tsx");
  }

  function Workflow() {
    return (
      <SmithersProvider
        db={db}
        executionId={executionId}
        maxIterations={10}
        globalTimeout={3600000}
        stopConditions={[
          { type: "total_tokens", value: 100000 }
        ]}
        onIteration={(i) => console.log(`Iteration ${i}`)}
        onComplete={() => console.log("Workflow complete")}
      >
        <WorkflowContent />
      </SmithersProvider>
    );
  }

  const root = createSmithersRoot();
  await root.mount(Workflow);

  await db.execution.complete(executionId);
  await db.close();
}

function WorkflowContent() {
  const { db, requestStop, isStopRequested } = useSmithers();
  
  const phase = useQueryValue<string>(
    db.db,
    "SELECT value FROM state WHERE key = 'phase'"
  ) ?? "start";
  
  const setPhase = (p: string) => db.state.set('phase', p);

  if (isStopRequested()) {
    return <Stop reason="Stop requested" />;
  }

  return (
    <>
      {phase === "start" && (
        <Claude onFinished={() => setPhase("done")}>
          Complete the task.
        </Claude>
      )}
    </>
  );
}

main();
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always wrap with SmithersProvider">
    All Smithers components require the provider:
    ```tsx
    // Correct
    <SmithersProvider db={db} executionId={executionId}>
      <Claude>...</Claude>
    </SmithersProvider>

    // Error - no context
    <Claude>...</Claude>
    ```
  </Accordion>

  <Accordion title="Set maxIterations to prevent runaway loops">
    Always set a reasonable iteration limit:
    ```tsx
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}  // Prevents infinite loops
    >
    ```
  </Accordion>

  <Accordion title="Use db.tasks for task tracking">
    Register async work with the database for proper orchestration:
    ```tsx
    const taskId = db.tasks.start('async-work');
    try {
      await doAsyncWork();
    } finally {
      db.tasks.complete(taskId);
    }
    ```
  </Accordion>

  <Accordion title="Close the database when done">
    Ensure writes are flushed:
    ```tsx
    const root = createSmithersRoot();
    await root.mount(Workflow);
    await db.close();  // Always close
    ```
  </Accordion>
</AccordionGroup>

## Related

<CardGroup cols={2}>
  <Card title="Database API" icon="database" href="/api-reference/database">
    Full database API reference
  </Card>
  <Card title="Ralph" icon="rotate" href="/components/ralph">
    Loop controller component
  </Card>
  <Card title="Phase" icon="list" href="/components/phase">
    Workflow structure
  </Card>
</CardGroup>
