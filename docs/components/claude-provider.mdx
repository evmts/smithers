---
title: ClaudeProvider Component
description: Configure defaults, rate limits, and usage tracking for Claude agents
---

# ClaudeProvider Component

The `<ClaudeProvider>` component configures shared defaults, rate limiting, and usage tracking for all Claude and ClaudeApi components in its subtree. This enables centralized control over API usage, cost management, and default configuration.

## Basic Usage

```tsx
import { ClaudeProvider, Claude } from '@evmts/smithers'

function App() {
  return (
    <ClaudeProvider
      defaults={{
        model: 'claude-sonnet-4-5',
        maxTurns: 10,
      }}
      rateLimit={{
        rpm: 50,
        itpm: 80000,
        otpm: 16000,
      }}
    >
      <Claude>First agent using defaults</Claude>
      <Claude model="claude-opus-4-5">Override model</Claude>
    </ClaudeProvider>
  )
}
```

## Props

### Configuration

<ParamField path="defaults" type="ClaudeDefaultProps">
  Default props for all nested Claude/ClaudeApi components. Component-level props override these defaults.

  ```tsx
  <ClaudeProvider
    defaults={{
      model: 'claude-sonnet-4-5',
      maxTurns: 10,
      permissionMode: 'acceptEdits',
      systemPrompt: 'You are a helpful coding assistant'
    }}
  >
    {/* All Claude components inherit these defaults */}
  </ClaudeProvider>
  ```

  See [ClaudeDefaultProps](#claudedefaultprops) for full list of available defaults.
</ParamField>

<ParamField path="apiKey" type="string">
  Anthropic API key to use. Overrides the `ANTHROPIC_API_KEY` environment variable.

  ```tsx
  <ClaudeProvider apiKey={process.env.MY_CLAUDE_API_KEY}>
    <Claude>Agent with custom API key</Claude>
  </ClaudeProvider>
  ```

  <Warning>
    Never hardcode API keys in your source code. Use environment variables or secrets management.
  </Warning>
</ParamField>

### Rate Limiting

<ParamField path="rateLimit" type="RateLimitConfig">
  Configure rate limiting to comply with Anthropic's API limits and prevent overuse.

  ```tsx
  <ClaudeProvider
    rateLimit={{
      rpm: 50,           // Requests per minute
      itpm: 80000,       // Input tokens per minute
      otpm: 16000,       // Output tokens per minute
      queueWhenLimited: true,  // Queue vs reject
      maxQueueSize: 100,
      queueTimeoutMs: 60000,
    }}
  >
    <Claude>Rate-limited agent</Claude>
  </ClaudeProvider>
  ```

  See [RateLimitConfig](#ratelimitconfig) for details.
</ParamField>

### Usage Tracking

<ParamField path="usageLimit" type="UsageLimitConfig">
  Set hard limits on token consumption and cost to prevent unexpected charges.

  ```tsx
  <ClaudeProvider
    usageLimit={{
      maxCostUsd: 10.00,        // Stop at $10
      maxInputTokens: 100000,   // Limit input tokens
      maxOutputTokens: 20000,   // Limit output tokens
      window: 'day',            // Per-day limits
    }}
  >
    <Claude>Budget-limited agent</Claude>
  </ClaudeProvider>
  ```

  See [UsageLimitConfig](#usagelimitconfig) for details.
</ParamField>

### Events

<ParamField path="events" type="ClaudeProviderEvents">
  Callbacks for monitoring rate limits, usage, and budget.

  ```tsx
  <ClaudeProvider
    events={{
      onRateLimited: ({ type, waitMs }) => {
        console.log(`Rate limited (${type}), waiting ${waitMs}ms`)
      },
      onUsageUpdate: (stats) => {
        console.log(`Used ${stats.totalTokens} tokens, $${stats.costUsd}`)
      },
      onBudgetWarning: ({ metric, percentUsed }) => {
        console.log(`Warning: ${percentUsed}% of ${metric} budget used`)
      },
      onBudgetPaused: ({ reason, resume }) => {
        console.log(`Paused: ${reason}`)
        // Optionally call resume() to continue
      },
    }}
  >
    <Claude>Monitored agent</Claude>
  </ClaudeProvider>
  ```

  See [ClaudeProviderEvents](#claudeproviderevents) for all events.
</ParamField>

### Persistence

<ParamField path="persistence" type="PersistenceConfig">
  Persist usage stats across restarts to maintain accurate cost tracking.

  ```tsx
  <ClaudeProvider
    persistence={{
      enabled: true,
      keyPrefix: 'my_app_usage',
      storage: myStorageAdapter, // Custom adapter (required)
    }}
  >
    <Claude>Usage stats persist across restarts</Claude>
  </ClaudeProvider>
  ```

  See [Persistence](#persistence-configuration) for details.
</ParamField>

### Other Props

<ParamField path="estimateTokens" type="(prompt: string) => TokenEstimate">
  Custom token estimation function for rate limiting. Default uses ~4 chars per token heuristic.

  ```tsx
  <ClaudeProvider
    estimateTokens={(prompt) => ({
      inputTokens: Math.ceil(prompt.length / 3.5),
      outputTokens: 2000,
    })}
  >
    <Claude>Custom estimation</Claude>
  </ClaudeProvider>
  ```
</ParamField>

<ParamField path="debug" type="boolean">
  Enable debug logging for rate limiting and usage tracking.

  ```tsx
  <ClaudeProvider debug={true}>
    <Claude>Logs rate limit and usage events</Claude>
  </ClaudeProvider>
  ```
</ParamField>

## Type Definitions

### ClaudeDefaultProps

Default properties that apply to all nested Claude/ClaudeApi components:

```tsx
interface ClaudeDefaultProps {
  // Common to both Claude and ClaudeApi
  model?: string                           // Claude model name
  mcpServers?: Record<string, MCPServerConfig> | MCPServerConfig[]
  schema?: ZodType                         // For structured output

  // Claude (Agent SDK) specific
  allowedTools?: string[]                  // Auto-allowed tools
  disallowedTools?: string[]              // Disallowed tools
  tools?: string[] | { type: 'preset'; preset: 'claude_code' }
  maxTurns?: number                        // Conversation turns
  maxBudgetUsd?: number                    // Per-query budget
  maxThinkingTokens?: number              // Reasoning token limit
  systemPrompt?: string | { type: 'preset'; preset: 'claude_code'; append?: string }
  permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions'
  cwd?: string                             // Working directory
  agents?: Record<string, AgentDefinition> // Subagent definitions
  additionalDirectories?: string[]        // Additional accessible directories

  // ClaudeApi (API SDK) specific
  system?: string                          // System prompt
  maxToolIterations?: number              // Tool loop limit
  stream?: boolean                         // Enable streaming
  retries?: number                         // Retry count
  toolRetry?: ToolRetryOptions            // Tool retry config
}
```

### RateLimitConfig

Rate limiting configuration using token bucket algorithm:

```tsx
interface RateLimitConfig {
  rpm?: number              // Requests per minute (default: 60)
  itpm?: number             // Input tokens per minute (default: 100000)
  otpm?: number             // Output tokens per minute (default: 20000)
  queueWhenLimited?: boolean   // Queue vs reject (default: true)
  maxQueueSize?: number        // Max queue length (default: 100)
  queueTimeoutMs?: number      // Queue timeout (default: 60000)
}
```

**Token Bucket Algorithm:**

- Each limit (RPM, ITPM, OTPM) has a bucket that continuously refills
- Buckets start full and drain with each request
- If bucket is empty, requests either queue or reject
- Buckets refill continuously at a rate matching the configured limit

### UsageLimitConfig

Hard limits on token consumption and cost:

```tsx
interface UsageLimitConfig {
  maxInputTokens?: number   // Max input tokens in window
  maxOutputTokens?: number  // Max output tokens in window
  maxTotalTokens?: number   // Max total tokens in window
  maxCostUsd?: number       // Max cost in USD in window
  window?: 'hour' | 'day' | 'week' | 'month' | 'all-time'  // Default: 'all-time'
}
```

### ClaudeProviderEvents

Event callbacks for monitoring:

```tsx
interface ClaudeProviderEvents {
  /** Called when a request is rate limited */
  onRateLimited?: (info: {
    type: 'rpm' | 'itpm' | 'otpm'
    waitMs: number
    queuePosition?: number
  }) => void

  /** Called when usage stats are updated */
  onUsageUpdate?: (stats: UsageStats) => void

  /** Called when usage approaches limit (80% threshold) */
  onBudgetWarning?: (info: {
    metric: 'inputTokens' | 'outputTokens' | 'totalTokens' | 'cost'
    current: number
    limit: number
    percentUsed: number
  }) => void

  /** Called when budget limit is exceeded */
  onBudgetPaused?: (info: {
    reason: string
    resume: () => void  // Call to continue despite limit
  }) => void

  /** Called when a request is queued */
  onRequestQueued?: (info: {
    position: number
    estimatedWaitMs: number
  }) => void

  /** Called when a request is dequeued */
  onRequestDequeued?: (info: {
    waitedMs: number
  }) => void
}
```

### UsageStats

Current usage statistics:

```tsx
interface UsageStats {
  inputTokens: number         // Total input tokens consumed
  outputTokens: number        // Total output tokens consumed
  totalTokens: number         // Total tokens (input + output)
  cacheReadTokens: number     // Tokens read from cache
  cacheCreationTokens: number // Tokens used to create cache
  costUsd: number             // Total cost in USD
  requestCount: number        // Number of API requests
  windowStart: Date           // Start of tracking window
  windowEnd: Date             // End of tracking window
}
```

## Use Cases

### Cost Control

Set hard budget limits to prevent unexpected charges:

```tsx
import { createSignal } from 'solid-js'

function BudgetControlledApp() {
  const [paused, setPaused] = createSignal(false)

  return (
    <ClaudeProvider
      usageLimit={{
        maxCostUsd: 5.00,
        window: 'day',
      }}
      events={{
        onBudgetWarning: ({ percentUsed }) => {
          if (percentUsed > 80) {
            alert(`Warning: ${percentUsed}% of daily budget used!`)
          }
        },
        onBudgetPaused: ({ reason, resume }) => {
          setPaused(true)
          console.error(`Budget exceeded: ${reason}`)
          // Do NOT call resume() - respect the budget
        },
      }}
    >
      {paused() ? (
        <div>Daily budget exceeded. Try again tomorrow.</div>
      ) : (
        <Claude>Your agent here</Claude>
      )}
    </ClaudeProvider>
  )
}
```

### Rate Limit Compliance

Ensure compliance with Anthropic's API rate limits:

```tsx
function RateLimitedBatchJob({ items }) {
  return (
    <ClaudeProvider
      rateLimit={{
        rpm: 50,      // Stay under API limit
        itpm: 80000,  // Leave 20% margin
        otpm: 16000,
        queueWhenLimited: true,  // Queue excess requests
      }}
      events={{
        onRateLimited: ({ type, waitMs }) => {
          console.log(`Rate limited (${type}), waiting ${waitMs}ms`)
        },
        onRequestQueued: ({ position, estimatedWaitMs }) => {
          console.log(`Queued at position ${position}, ~${estimatedWaitMs}ms wait`)
        },
      }}
    >
      {items.map((item, i) => (
        <Claude key={i}>Process {item}</Claude>
      ))}
    </ClaudeProvider>
  )
}
```

### Usage Monitoring

Track and log usage statistics:

```tsx
import { createSignal } from 'solid-js'

function MonitoredApp() {
  const [usage, setUsage] = createSignal<UsageStats | null>(null)

  return (
    <ClaudeProvider
      events={{
        onUsageUpdate: (stats) => {
          setUsage(stats)
          console.log(`Total cost: $${stats.costUsd.toFixed(4)}`)
          console.log(`Tokens: ${stats.totalTokens}`)
        },
      }}
    >
      <div>
        <UsageDashboard usage={usage()} />
        <Claude>Your agent here</Claude>
      </div>
    </ClaudeProvider>
  )
}

function UsageDashboard({ usage }: { usage: UsageStats | null }) {
  if (!usage) return null

  return (
    <div>
      <h3>API Usage</h3>
      <p>Cost: ${usage.costUsd.toFixed(4)}</p>
      <p>Input tokens: {usage.inputTokens}</p>
      <p>Output tokens: {usage.outputTokens}</p>
      <p>Requests: {usage.requestCount}</p>
    </div>
  )
}
```

### Shared Configuration

Apply common configuration to all agents:

```tsx
function MultiAgentApp() {
  return (
    <ClaudeProvider
      defaults={{
        model: 'claude-sonnet-4-5',
        maxTurns: 10,
        permissionMode: 'acceptEdits',
        systemPrompt: 'You are a senior software engineer.',
        mcpServers: {
          github: {
            type: 'stdio',
            command: 'mcp-server-github',
          },
        },
      }}
    >
      {/* All agents inherit these defaults */}
      <Claude>Implement feature A</Claude>
      <Claude>Review code for feature B</Claude>
      <Claude model="claude-opus-4-5">
        Complex task needing more capable model
      </Claude>
    </ClaudeProvider>
  )
}
```

### Environment-Specific Limits

Adjust limits based on environment:

```tsx
function App() {
  const isDevelopment = process.env.NODE_ENV === 'development'

  return (
    <ClaudeProvider
      rateLimit={{
        rpm: isDevelopment ? 10 : 50,       // Lower in dev
        itpm: isDevelopment ? 10000 : 80000,
      }}
      usageLimit={{
        maxCostUsd: isDevelopment ? 0.10 : 10.00,  // Strict dev budget
        window: 'day',
      }}
    >
      <Claude>Your agent here</Claude>
    </ClaudeProvider>
  )
}
```

## Behavior Details

### Default Prop Inheritance

Component props always override provider defaults:

```tsx
<ClaudeProvider defaults={{ model: 'claude-sonnet-4-5', maxTurns: 10 }}>
  {/* Uses defaults: sonnet-4-5, maxTurns=10 */}
  <Claude>Agent 1</Claude>

  {/* Override model, keep maxTurns=10 */}
  <Claude model="claude-opus-4-5">Agent 2</Claude>

  {/* Override maxTurns, keep model=sonnet-4-5 */}
  <Claude maxTurns={20}>Agent 3</Claude>

  {/* Override both */}
  <Claude model="claude-opus-4-5" maxTurns={20}>Agent 4</Claude>
</ClaudeProvider>
```

### Rate Limiting Flow

1. **Before Request**: Provider estimates token usage with `estimateTokens()`
2. **Check Buckets**: Verify RPM, ITPM, OTPM buckets have capacity
3. **Queue or Reject**: If capacity insufficient:
   - `queueWhenLimited=true`: Add to queue (up to `maxQueueSize`)
   - `queueWhenLimited=false`: Reject immediately with `RateLimitError`
4. **Wait**: If queued, wait for buckets to refill (up to `queueTimeoutMs`)
5. **Proceed**: Once capacity available, proceed with request
6. **Refill**: Buckets continuously refill at configured rate

### Usage Tracking Flow

1. **Before Request**: Check if within budget limits (`checkBudget()`)
2. **Budget Check**: If limit exceeded:
   - Call `onBudgetPaused` with `resume()` callback
   - Wait for `resume()` call or exit
3. **Make Request**: Proceed with API call
4. **After Response**: Report actual usage (`reportUsage()`)
5. **Update Stats**: Update `UsageStats` with actual token counts
6. **Check Warnings**: If approaching limit (80%), call `onBudgetWarning`
7. **Persist**: If persistence enabled, save stats to storage

### Budget Warnings

The provider emits warnings at 80% of any configured limit:

```tsx
<ClaudeProvider
  usageLimit={{ maxCostUsd: 10.00 }}
  events={{
    onBudgetWarning: ({ metric, percentUsed, current, limit }) => {
      // Called when cost reaches $8.00 (80% of $10.00)
      console.warn(`${metric}: ${percentUsed}% used (${current}/${limit})`)
    },
  }}
>
  <Claude>Agent</Claude>
</ClaudeProvider>
```

## Persistence Configuration

Persist usage stats across restarts to maintain accurate cost tracking:

```tsx
import { ClaudeProvider } from '@evmts/smithers'

// Custom storage adapter (example with localStorage)
const storageAdapter = {
  async get(key: string) {
    return localStorage.getItem(key)
  },
  async set(key: string, value: string) {
    localStorage.setItem(key, value)
  },
  async delete(key: string) {
    localStorage.removeItem(key)
  },
}

function App() {
  return (
    <ClaudeProvider
      persistence={{
        enabled: true,
        keyPrefix: 'my_app_usage',  // Storage key: my_app_usage_stats
        storage: storageAdapter,
      }}
      usageLimit={{
        maxCostUsd: 10.00,
        window: 'day',
      }}
    >
      {/* Usage stats persist across restarts */}
      <Claude>Your agent</Claude>
    </ClaudeProvider>
  )
}
```

**Storage Adapter Interface:**

```tsx
interface StorageAdapter {
  get(key: string): Promise<string | null>
  set(key: string, value: string): Promise<void>
  delete(key: string): Promise<void>
}
```

**Built-in Adapters:**

- None (you must provide a custom adapter)

**Example Adapters:**

- `localStorage` (browser)
- File system (Node.js)
- Redis (distributed systems)
- Database (PostgreSQL, MongoDB, etc.)

## Programmatic Access

Use the `useClaudeContext` hook to access provider functionality:

```tsx
import { useClaudeContext } from '@evmts/smithers'

function UsageDisplay() {
  const context = useClaudeContext()

  if (!context) {
    throw new Error('Must be inside ClaudeProvider')
  }

  const stats = context.getUsageStats()
  const budget = context.checkBudget()

  return (
    <div>
      <h3>Usage Stats</h3>
      <p>Cost: ${stats.costUsd.toFixed(4)}</p>
      <p>Tokens: {stats.totalTokens}</p>
      <p>Budget OK: {budget.allowed ? 'Yes' : `No - ${budget.reason}`}</p>

      <button onClick={() => context.resetUsage()}>
        Reset Usage
      </button>
    </div>
  )
}
```

**Context API:**

```tsx
interface ClaudeContextValue {
  getClaudeProps<T>(props: ClaudeProps<T>): ClaudeProps<T>
  getClaudeApiProps<T>(props: ClaudeApiProps<T>): ClaudeApiProps<T>
  acquireRateLimit(estimate: TokenEstimate): Promise<void>
  reportUsage(usage: UsageReport): void
  checkBudget(): { allowed: boolean; reason?: string }
  waitForBudget(): Promise<void>
  getUsageStats(): UsageStats
  resetUsage(): void
  apiKey?: string
  estimateTokens?: (prompt: string) => TokenEstimate
  rateLimitEnabled: boolean
  usageTrackingEnabled: boolean
}
```

## Cost Estimation

The provider estimates costs using model-specific pricing:

| Model | Input (per 1M tokens) | Output (per 1M tokens) |
|-------|----------------------|------------------------|
| Claude Opus 4.5 | $15.00 | $75.00 |
| Claude Sonnet 4.5 | $3.00 | $15.00 |
| Claude Haiku 4.0 | $1.00 | $5.00 |

**Cache pricing:**

- Cache reads: 10% of input price
- Cache creation: 25% additional to input price

**Custom estimation:**

```tsx
<ClaudeProvider
  estimateTokens={(prompt) => {
    // Your custom estimation logic
    const inputTokens = myTokenCounter(prompt)
    const outputTokens = estimateOutput(prompt)
    return { inputTokens, outputTokens }
  }}
>
  <Claude>Agent</Claude>
</ClaudeProvider>
```

## Error Handling

### Rate Limit Errors

When `queueWhenLimited=false`, rate limit errors are thrown:

```tsx
try {
  await executePlan(
    <ClaudeProvider rateLimit={{ rpm: 10, queueWhenLimited: false }}>
      <Claude>Your agent</Claude>
    </ClaudeProvider>
  )
} catch (error) {
  if (error instanceof RateLimitError) {
    console.error('Rate limit exceeded:', error.message)
    // Wait and retry
  }
}
```

### Budget Exceeded

When budget is exceeded, execution pauses:

```tsx
<ClaudeProvider
  usageLimit={{ maxCostUsd: 1.00 }}
  events={{
    onBudgetPaused: ({ reason, resume }) => {
      console.error(`Budget exceeded: ${reason}`)
      // Decide whether to call resume()
      const userApproves = confirm('Continue despite budget?')
      if (userApproves) {
        resume()
      }
    },
  }}
>
  <Claude>Agent</Claude>
</ClaudeProvider>
```

## Performance Considerations

### Rate Limiter Overhead

- Token bucket updates: ~0.1ms per request
- Queue operations: ~0.5ms per request
- Minimal impact on overall request time

### Usage Tracking Overhead

- Stats update: ~0.1ms per request
- Persistence write: ~1-10ms (depends on adapter)
- Consider async persistence for high-throughput scenarios

### Memory Usage

- Rate limiter state: ~1KB
- Usage tracker: ~1KB + O(number of requests) for detailed history
- Queue: O(queue size) - defaults to 100 requests max

## Related

<CardGroup cols={2}>
  <Card title="Claude Component" icon="robot" href="/components/claude">
    Configure individual Claude agents
  </Card>
  <Card title="ClaudeApi Component" icon="code" href="/components/claude-api">
    Direct API access for custom tools
  </Card>
</CardGroup>
