---
title: OutputFormat Component
description: Specify the expected response structure
---

# OutputFormat Component

The `<OutputFormat>` component specifies the expected structure for the agent's response. Use it when you need to parse the output programmatically or want consistent formatting.

## Basic Usage

```tsx
import { Claude, OutputFormat } from 'smithers'

<Claude>
  Analyze this code for issues.

  <OutputFormat schema={{
    type: 'object',
    properties: {
      summary: { type: 'string' },
      issues: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            severity: { enum: ['critical', 'high', 'medium', 'low'] },
            file: { type: 'string' },
            line: { type: 'number' },
            message: { type: 'string' },
            suggestion: { type: 'string' }
          }
        }
      },
      metrics: {
        type: 'object',
        properties: {
          totalIssues: { type: 'number' },
          criticalCount: { type: 'number' }
        }
      }
    }
  }}>
    Return valid JSON matching the schema.
    No markdown code blocks, just raw JSON.
  </OutputFormat>
</Claude>
```

## Props

<ParamField path="schema" type="object">
  JSON Schema or simple object describing the expected output structure.
</ParamField>

<ParamField path="children" type="ReactNode">
  Human-readable description of the expected format.
</ParamField>

## Simple Format Descriptions

For simpler cases, just describe the format without a schema:

```tsx
<OutputFormat>
  Return a markdown document with:
  - A summary section (2-3 sentences)
  - A bulleted list of key findings
  - A recommendations section with actionable items
</OutputFormat>
```

## Reusable Output Formats

Create reusable format components:

```tsx
// output-formats.tsx
import { OutputFormat } from 'smithers'

export function JSONOutput({ schema }) {
  return (
    <OutputFormat schema={schema}>
      Respond with valid JSON matching the schema.
      No markdown, no explanation, just the JSON object.
    </OutputFormat>
  )
}

export function MarkdownReport() {
  return (
    <OutputFormat>
      Return a well-structured markdown document with:
      - Clear headings (##, ###)
      - Bulleted lists for multiple items
      - Code blocks with language tags
      - A summary at the end
    </OutputFormat>
  )
}

export function CodeOnlyOutput({ language }) {
  return (
    <OutputFormat>
      Return only the {language} code.
      No explanations, no markdown blocks, just raw code.
      Include necessary imports.
    </OutputFormat>
  )
}
```

### Using Reusable Formats

```tsx
import { JSONOutput } from './output-formats'

<Claude>
  Analyze user feedback and categorize it.

  <JSONOutput schema={{
    categories: [{
      name: 'string',
      count: 'number',
      sentiment: 'positive | negative | neutral'
    }]
  }} />
</Claude>
```

## Common Format Patterns

### JSON Response

```tsx
<OutputFormat schema={{
  success: { type: 'boolean' },
  data: { type: 'object' },
  errors: { type: 'array', items: { type: 'string' } }
}}>
  Return valid JSON. No markdown code blocks.
</OutputFormat>
```

### Structured Report

```tsx
<OutputFormat>
  Return a report with these sections:

  ## Executive Summary
  2-3 sentence overview

  ## Key Findings
  Bulleted list of main points

  ## Recommendations
  Numbered list of action items

  ## Appendix
  Supporting details and data
</OutputFormat>
```

### Code Generation

```tsx
<OutputFormat>
  Return only the TypeScript code.
  - Include all necessary imports
  - Add JSDoc comments for public functions
  - No explanations or markdown
</OutputFormat>
```

## Combining with Other Components

```tsx
function SecurityAudit({ codebase }) {
  return (
    <Claude tools={[filesystem, grep]}>
      <Persona role="Security Auditor">
        CISSP-certified security professional with expertise in
        web application security and secure code review.
      </Persona>

      <Constraints>
        - Focus on OWASP Top 10 vulnerabilities
        - Prioritize issues by severity and exploitability
        - Provide actionable remediation steps
        - Don't flag theoretical issues without evidence
      </Constraints>

      <Phase name="audit">
        <Step>Scan {codebase} for security vulnerabilities</Step>
        <Step>Analyze authentication and authorization flows</Step>
        <Step>Check for injection vulnerabilities</Step>
        <Step>Review cryptographic implementations</Step>
      </Phase>

      <OutputFormat schema={{
        vulnerabilities: [{
          id: 'string',
          severity: 'critical | high | medium | low',
          category: 'string',
          location: 'string',
          description: 'string',
          remediation: 'string',
          references: 'string[]'
        }],
        summary: {
          total: 'number',
          critical: 'number',
          high: 'number',
          riskScore: 'number'
        }
      }}>
        Return valid JSON matching the schema.
      </OutputFormat>
    </Claude>
  )
}
```

## Parsing Output

When using `onFinished`, the output is automatically parsed:

```tsx
interface AnalysisResult {
  summary: string
  issues: Array<{
    severity: 'critical' | 'high' | 'medium' | 'low'
    message: string
  }>
}

<Claude<AnalysisResult>
  onFinished={(result) => {
    console.log(result.summary)
    result.issues.forEach(issue => {
      console.log(`[${issue.severity}] ${issue.message}`)
    })
  }}
>
  Analyze this code.

  <OutputFormat schema={{
    summary: { type: 'string' },
    issues: {
      type: 'array',
      items: {
        severity: { enum: ['critical', 'high', 'medium', 'low'] },
        message: { type: 'string' }
      }
    }
  }}>
    Return valid JSON.
  </OutputFormat>
</Claude>
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Match format to use case" icon="code">
    Use JSON schemas when you need to parse output programmatically
  </Card>
  <Card title="Be explicit about formatting" icon="text">
    Specify "no markdown" or "raw JSON" to avoid formatting issues
  </Card>
  <Card title="Provide examples" icon="lightbulb">
    Include an example of the expected output for complex schemas
  </Card>
  <Card title="Keep schemas simple" icon="minimize">
    Simpler schemas are more reliably followed
  </Card>
</CardGroup>

## Related

<CardGroup cols={2}>
  <Card title="Persona" icon="user" href="/components/persona">
    Define the agent's role and expertise
  </Card>
  <Card title="Constraints" icon="list-check" href="/components/constraints">
    Define behavioral rules for the agent
  </Card>
  <Card title="Claude" icon="cube" href="/components/claude">
    The container for output format components
  </Card>
</CardGroup>
