---
title: Step Component
description: Define an individual step within a phase or workflow
---

# Step Component

The `<Step>` component defines an individual step within a phase or directly inside a Claude component. It provides semantic structure for multi-step workflows.

## Basic Usage

```tsx
import { Claude, Phase, Step } from 'smithers'

<Phase name="implementation">
  <Step>Read existing tests to understand expected behavior</Step>
  <Step>Implement the new feature following project conventions</Step>
  <Step>Write unit tests for the implementation</Step>
  <Step>Update documentation if needed</Step>
</Phase>
```

Renders to:

```xml
<phase name="implementation">
  <step>Read existing tests to understand expected behavior</step>
  <step>Implement the new feature following project conventions</step>
  <step>Write unit tests for the implementation</step>
  <step>Update documentation if needed</step>
</phase>
```

## Props

<ParamField path="completed" type="boolean" default="false">
  Mark the step as already completed. Completed steps are skipped by the Ralph loop.

  ```tsx
  <Step completed>Already done this step</Step>
  ```
</ParamField>

<ParamField path="children" type="ReactNode" required>
  The step description.
</ParamField>

## Steps Without Phases

Steps can be used directly inside Claude components:

```tsx
<Claude tools={[filesystem]}>
  <Step>Read the configuration file</Step>
  <Step>Validate the settings</Step>
  <Step>Apply the configuration</Step>
</Claude>
```

## Dynamic Steps

Generate steps dynamically from data:

```tsx
function FileProcessor({ files }) {
  return (
    <Claude tools={[filesystem]}>
      <Phase name="process">
        {files.map((file, i) => (
          <Step key={file}>
            {i + 1}. Process {file} and extract metadata
          </Step>
        ))}
      </Phase>

      <Phase name="aggregate">
        <Step>Combine all extracted metadata</Step>
        <Step>Generate summary report</Step>
      </Phase>
    </Claude>
  )
}
```

## Conditional Steps

Include or exclude steps based on conditions:

```tsx
function ReviewAgent({ strict, files }) {
  return (
    <Claude tools={[filesystem]}>
      <Phase name="review">
        <Step>Read and understand the code</Step>
        <Step>Check for bugs and logic errors</Step>

        {strict && (
          <>
            <Step>Verify code style compliance</Step>
            <Step>Check test coverage</Step>
            <Step>Review documentation completeness</Step>
          </>
        )}

        <Step>Summarize findings</Step>
      </Phase>
    </Claude>
  )
}
```

## Completed Steps

Mark steps as completed to track progress:

```tsx
function MultiStepAgent({ completedSteps }) {
  return (
    <Claude tools={[filesystem]}>
      <Phase name="setup">
        <Step completed={completedSteps.includes('install')}>
          Install dependencies
        </Step>
        <Step completed={completedSteps.includes('config')}>
          Configure environment
        </Step>
        <Step completed={completedSteps.includes('validate')}>
          Validate setup
        </Step>
      </Phase>
    </Claude>
  )
}
```

## Numbered Steps

Add explicit numbering for ordered workflows:

```tsx
<Phase name="deployment">
  <Step>1. Build the application</Step>
  <Step>2. Run all tests</Step>
  <Step>3. Create deployment package</Step>
  <Step>4. Deploy to staging</Step>
  <Step>5. Run smoke tests</Step>
  <Step>6. Deploy to production</Step>
</Phase>
```

## Steps with Context

Provide additional context within steps:

```tsx
<Phase name="migration">
  <Step>
    Backup the database
    (Use pg_dump with --format=custom for efficient restore)
  </Step>
  <Step>
    Apply schema migrations
    (Run in a transaction to allow rollback)
  </Step>
  <Step>
    Verify data integrity
    (Check foreign key constraints and indexes)
  </Step>
</Phase>
```

## Reusable Step Patterns

Create reusable step components:

```tsx
function GitCommitSteps({ message }) {
  return (
    <>
      <Step>Stage all modified files</Step>
      <Step>Review the diff</Step>
      <Step>Commit with message: "{message}"</Step>
    </>
  )
}

function TestingSteps({ coverage }) {
  return (
    <>
      <Step>Run unit tests</Step>
      <Step>Check coverage is at least {coverage}%</Step>
      <Step>Run integration tests</Step>
    </>
  )
}

// Usage
<Phase name="complete-task">
  <Step>Implement the feature</Step>
  <TestingSteps coverage={80} />
  <GitCommitSteps message="Add new feature" />
</Phase>
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Be specific" icon="bullseye">
    Clear, actionable steps are easier for Claude to follow
  </Card>
  <Card title="Keep steps atomic" icon="atom">
    Each step should represent a single action
  </Card>
  <Card title="Order matters" icon="sort">
    Steps should be in logical execution order
  </Card>
  <Card title="Use phases for grouping" icon="layer-group">
    Group related steps into phases for better organization
  </Card>
</CardGroup>

## Related

<CardGroup cols={2}>
  <Card title="Phase" icon="layer-group" href="/components/phase">
    Group steps into named phases
  </Card>
  <Card title="Task" icon="check-square" href="/components/task">
    Trackable tasks with completion state
  </Card>
  <Card title="Claude" icon="cube" href="/components/claude">
    The container for steps
  </Card>
</CardGroup>
