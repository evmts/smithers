---
title: Workflows
description: Type-safe reactive input/output system for agent communication
---

# Workflows

Workflows provide a type-safe reactive system for agents (Claude) and humans to communicate through typed channels. When values change, dependent agents automatically re-execute.

## Overview

The workflow system enables:
- **Type-safe communication** between agents using Zod schemas
- **Reactive re-execution** when upstream values change
- **Human-in-the-loop** input through typed forms
- **Automatic tool generation** for agents to set workflow values

## Creating a Workflow

Use `createWorkflow` to define a typed workflow schema:

```tsx
import { z } from 'zod'
import { createWorkflow } from '@evmts/smithers'

const workflow = createWorkflow({
  schema: z.object({
    findings: z.string(),
    feedback: z.string(),
    analysis: z.object({
      summary: z.string(),
      confidence: z.number(),
    }),
  }),
})
```

## Workflow API

`createWorkflow` returns an object with:

| Property | Type | Description |
|----------|------|-------------|
| `Provider` | `React.FC` | Context provider for the workflow |
| `useInput` | `(name) => T \| undefined` | Hook to subscribe to a workflow value |
| `useStore` | `() => WorkflowStore` | Hook to access the full store |
| `Output` | `React.FC` | Component to define agent outputs |
| `schema` | `ZodObject` | The original Zod schema |

## Basic Usage

### Agent-to-Agent Communication

```tsx
import { z } from 'zod'
import { createWorkflow, Claude, executePlan } from '@evmts/smithers'

const workflow = createWorkflow({
  schema: z.object({
    research: z.string(),
    summary: z.string(),
  }),
})

function Researcher() {
  return (
    <Claude>
      Research AI safety best practices.
      <workflow.Output name="research" description="Your research findings" />
    </Claude>
  )
}

function Writer() {
  const research = workflow.useInput('research')
  if (!research) return null

  return (
    <Claude>
      Summarize the following research: {research}
      <workflow.Output name="summary" />
    </Claude>
  )
}

function App() {
  return (
    <workflow.Provider>
      <Researcher />
      <Writer />
    </workflow.Provider>
  )
}

await executePlan(<App />)
```

### How It Works

1. `<Researcher />` executes first (no dependencies)
2. Claude receives a `set_research` tool and calls it with findings
3. The workflow store updates, triggering a re-render
4. `<Writer />` now has `research` value, so it renders
5. Claude summarizes the research and sets `summary`

### Human-in-the-Loop Input

```tsx
const workflow = createWorkflow({
  schema: z.object({
    userFeedback: z.string(),
    refinedOutput: z.string(),
  }),
})

function FeedbackLoop() {
  const feedback = workflow.useInput('userFeedback')

  return (
    <>
      <Human message="Provide feedback on the draft">
        <workflow.Output name="userFeedback" description="Your feedback" />
      </Human>

      {feedback && (
        <Claude>
          Refine the output based on: {feedback}
          <workflow.Output name="refinedOutput" />
        </Claude>
      )}
    </>
  )
}
```

## The `Output` Component

`<workflow.Output>` tells Claude to set a workflow value. It generates a tool automatically.

```tsx
<workflow.Output
  name="findings"           // Required: key in the schema
  description="Your findings" // Optional: tool description for Claude
/>
```

### Generated Tool

For a workflow output named `findings` with a `z.string()` schema, Claude receives:

```json
{
  "name": "set_findings",
  "description": "Your findings",
  "input_schema": {
    "type": "object",
    "properties": {
      "value": { "type": "string" }
    },
    "required": ["value"]
  }
}
```

## Reactive Re-execution

Values from `useInput()` are rendered directly into JSX:

```tsx
function Analyst() {
  const findings = workflow.useInput('findings')

  return (
    <Claude>
      Analyze: {findings}
    </Claude>
  )
}
```

When `findings` changes:
1. React re-renders the component (`useSyncExternalStore` triggers)
2. The Claude node's children contain different text
3. Content hash differs from previous execution
4. Ralph loop marks the node for re-execution

## Structured Outputs

Use nested Zod schemas for complex structured data:

```tsx
const workflow = createWorkflow({
  schema: z.object({
    analysis: z.object({
      issues: z.array(z.object({
        severity: z.enum(['low', 'medium', 'high']),
        description: z.string(),
        file: z.string(),
      })),
      summary: z.string(),
      score: z.number().min(0).max(100),
    }),
  }),
})

function Reviewer() {
  return (
    <Claude>
      Review the codebase for security issues.
      <workflow.Output name="analysis" />
    </Claude>
  )
}

function Reporter() {
  const analysis = workflow.useInput('analysis')
  if (!analysis) return null

  return (
    <Output format="json" label="Security Report">
      {JSON.stringify(analysis, null, 2)}
    </Output>
  )
}
```

## Default Values

Provide initial values when creating the workflow:

```tsx
const workflow = createWorkflow({
  schema: z.object({
    iterations: z.number(),
    findings: z.array(z.string()),
  }),
  defaultValues: {
    iterations: 0,
    findings: [],
  },
})
```

## Direct Store Access

Use `useStore()` for programmatic control:

```tsx
function ManualControl() {
  const store = workflow.useStore()

  const handleReset = () => {
    store.setValue('findings', '')
    store.setValue('analysis', undefined)
  }

  return (
    <button onClick={handleReset}>Reset Workflow</button>
  )
}
```

## Type Safety

All workflow operations are fully typed:

```tsx
const workflow = createWorkflow({
  schema: z.object({
    count: z.number(),
    name: z.string(),
  }),
})

// Type-safe input access
const count = workflow.useInput('count') // number | undefined
const name = workflow.useInput('name')   // string | undefined

// TypeScript error: 'invalid' doesn't exist
const invalid = workflow.useInput('invalid')

// Type-safe output
<workflow.Output name="count" />  // Valid
<workflow.Output name="invalid" /> // TypeScript error
```

## Multiple Workflows

Use multiple workflows for complex systems:

```tsx
const researchWorkflow = createWorkflow({
  schema: z.object({ findings: z.string() }),
})

const reviewWorkflow = createWorkflow({
  schema: z.object({ feedback: z.string() }),
})

function App() {
  return (
    <researchWorkflow.Provider>
      <reviewWorkflow.Provider>
        <ResearchPhase />
        <ReviewPhase />
      </reviewWorkflow.Provider>
    </researchWorkflow.Provider>
  )
}
```

## Best Practices

1. **Define schemas upfront** - Plan your workflow data flow before implementing
2. **Use descriptive names** - Help Claude understand what to output
3. **Provide descriptions** - The `description` prop improves Claude's tool usage
4. **Handle undefined** - Always check if `useInput()` returns undefined before rendering
5. **Keep schemas simple** - Complex nested schemas are harder for Claude to fill correctly

## Comparison with State Management

| Feature | Zustand/useState | Workflows |
|---------|------------------|-----------|
| Type safety | Manual | Automatic from Zod |
| Agent outputs | Manual tool + callback | `<workflow.Output>` |
| Human inputs | Manual prompts | Built-in support |
| Re-execution | Content hash detection | Same |
| Multi-agent | Shared store | Per-workflow isolation |

Use workflows when you want:
- Automatic tool generation for agent outputs
- Built-in human input collection
- Strong typing from Zod schemas

Use Zustand/useState when you want:
- More control over state shape
- Custom tool implementations
- Complex state transitions
