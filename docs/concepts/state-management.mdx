---
title: State Management
description: Using React state and database persistence for workflow state
---

# State Management

Smithers uses two complementary state systems:

1. **React state** - Reactive in-memory state that drives re-renders
2. **Database Persistence** - SQLite storage that survives restarts

## React state

State is the reactive primitive that powers the Ralph Wiggum Loop:

```tsx
import { useState } from "react";

function WorkflowWithState() {
  const [count, setCount] = useState(0);
  const [phase, setPhase] = useState("start");

  return (
    <Ralph maxIterations={10}>
      {phase === "start" && (
        <Claude onFinished={() => {
          setCount(c => c + 1);
          setPhase("process");
        }}>
          Initialize the workflow.
        </Claude>
      )}

      {phase === "process" && (
        <Claude onFinished={() => setPhase("done")}>
          Process iteration {count}.
        </Claude>
      )}
    </Ralph>
  );
}
```

### State Basics

```tsx
// Create state with initial value
const [value, setValue] = useState("initial");

// Read the current value
console.log(value); // "initial"

// Update the value
setValue("new value");

// Update based on previous value
setValue(prev => prev + " updated");
```

### State in JSX

State automatically triggers re-renders when updated in JSX:

```tsx
function ReactiveComponent() {
  const [status, setStatus] = useState("pending");

  return (
    <>
      {/* This re-renders when status changes */}
      {status === "pending" && <Claude>Do the work</Claude>}
      {status === "done" && <Stop reason="Complete" />}
    </>
  );
}
```

## React Stores

For complex nested state, use stores:

```tsx
import { createStore } from "smithers-orchestrator/store";

function WorkflowWithStore() {
  const [state, setState] = createStore({
    phase: "research",
    findings: [] as string[],
    errors: [] as string[],
    metadata: {
      startedAt: Date.now(),
      iterations: 0,
    },
  });

  return (
    <Ralph maxIterations={10}>
      {state.phase === "research" && (
        <Claude onFinished={(result) => {
          setState("findings", [...state.findings, result.output]);
          setState("phase", "analyze");
        }}>
          Research the topic.
        </Claude>
      )}

      {state.phase === "analyze" && (
        <Claude onFinished={() => {
          setState("metadata", "iterations", i => i + 1);
          setState("phase", "done");
        }}>
          Analyze findings: {JSON.stringify(state.findings)}
        </Claude>
      )}
    </Ralph>
  );
}
```

### Store Updates

```tsx
// Update a property
setState("phase", "next");

// Update nested property
setState("metadata", "iterations", 5);

// Update with function
setState("metadata", "iterations", i => i + 1);

// Update array
setState("findings", findings => [...findings, "new finding"]);

// Batch updates
batch(() => {
  setState("phase", "done");
  setState("metadata", "completedAt", Date.now());
});
```

## Database Persistence

State is in-memory only. For persistence across restarts, use the database:

```tsx
async function PersistentWorkflow() {
  // Load persisted state
  const savedPhase = await db.state.get("phase");
  const [phase, setPhase] = useState(savedPhase ?? "start");

  // Sync state to database
  const updatePhase = async (newPhase: string) => {
    setPhase(newPhase);
    await db.state.set("phase", newPhase);
  };

  return (
    <SmithersProvider db={db} executionId={executionId}>
      <Ralph maxIterations={10}>
        {phase === "start" && (
          <Claude onFinished={() => updatePhase("process")}>
            Start the workflow.
          </Claude>
        )}

        {phase === "process" && (
          <Claude onFinished={() => updatePhase("done")}>
            Continue processing.
          </Claude>
        )}
      </Ralph>
    </SmithersProvider>
  );
}
```

### Database State API

```tsx
// Set a value
await db.state.set("key", value);

// Set with trigger (for tracking)
await db.state.set("phase", "review", "agent_completed");

// Get a value
const value = await db.state.get("key");

// Set multiple values
await db.state.setMany({
  phase: "done",
  completedAt: Date.now(),
});

// Get all state
const all = await db.state.getAll();

// View history
const history = await db.state.history("phase");

// Time-travel: replay to a previous transition
await db.state.replayTo(transitionId);
```

## Combining State and Database

A common pattern is to initialize state from the database:

```tsx
async function ResumeableWorkflow() {
  // Load persisted state on startup
  const persisted = await db.state.getAll();

  const [state, setState] = createStore({
    phase: persisted.phase ?? "start",
    data: persisted.data ?? null,
    attempts: persisted.attempts ?? 0,
  });

  // Helper to update both state and database
  const persistState = async (updates: Partial<typeof state>) => {
    setState(updates);
    await db.state.setMany(updates);
  };

  return (
    <SmithersProvider db={db} executionId={executionId}>
      <Ralph maxIterations={10}>
        {state.phase === "start" && (
          <Claude onFinished={(result) => {
            persistState({
              phase: "process",
              data: result.output
            });
          }}>
            Initialize.
          </Claude>
        )}
      </Ralph>
    </SmithersProvider>
  );
}
```

## Snapshots and Restore

Save and restore complete state snapshots:

```tsx
// Take a snapshot
const snapshot = await db.state.snapshot();
console.log(snapshot); // { phase: "review", data: {...} }

// Restore a snapshot
await db.state.restore(snapshot, "manual_restore");
```

## Effects and Derived State

Use `useEffect` for side effects when state changes:

```tsx
import { useEffect, useMemo } from "react";

function EffectExample() {
  const [phase, setPhase] = useState("start");
  const [attempts, setAttempts] = useState(0);

  // Derived state (computed from other state)
  const isComplete = useMemo(() => phase === "done", [phase]);
  const hasRetried = useMemo(() => attempts > 1, [attempts]);

  // Side effect when phase changes
  useEffect(() => {
    console.log(`Phase changed to: ${phase}`);
    db.state.set("phase", phase);
  }, [phase]);

  return (
    <Ralph maxIterations={10}>
      {!isComplete && (
        <Claude onFinished={() => {
          setAttempts(a => a + 1);
          setPhase("done");
        }}>
          Attempt {attempts + 1}
        </Claude>
      )}
    </Ralph>
  );
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always use state values directly">
    State values are read directly in React:
    ```tsx
    // Correct - reactive
    {phase === "done" && <Stop />}

    // Wrong - don't call state as function
    {phase() === "done" && <Stop />}
    ```
  </Accordion>

  <Accordion title="Persist critical state to database">
    Anything that should survive a restart needs database persistence:
    ```tsx
    // In-memory only - lost on restart
    const [phase, setPhase] = useState("start");

    // Persisted - survives restart
    const savedPhase = await db.state.get("phase");
    const [phase, setPhase] = useState(savedPhase ?? "start");
    ```
  </Accordion>

  <Accordion title="Use stores for complex state">
    Stores handle nested updates better than multiple state variables:
    ```tsx
    // Prefer store for complex state
    const [state, setState] = createStore({
      phase: "start",
      data: { items: [], metadata: {} },
    });

    // Multiple state variables get unwieldy
    const [phase, setPhase] = useState("start");
    const [items, setItems] = useState([]);
    const [metadata, setMetadata] = useState({});
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Database Persistence" icon="hard-drive" href="/concepts/database-persistence">
    Deep dive into the SQLite database
  </Card>
  <Card title="Ralph Component" icon="rotate" href="/components/ralph">
    Control iteration with Ralph
  </Card>
</CardGroup>
