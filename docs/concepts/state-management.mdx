---
title: State Management
description: Using SolidJS signals and stores for robust agent state management
---

# State Management

Smithers uses SolidJS's fine-grained reactivity system. You can use signals and stores to manage agent state with precision and performance.

## Why SolidJS?

<AccordionGroup>
  <Accordion title="Fine-grained updates">
    Only the parts of the plan that depend on changed state are re-evaluated. No full-tree re-renders.
  </Accordion>
  <Accordion title="No stale closures">
    Solid's signals always return the current value when called. You don't need dependency arrays or `useCallback`.
  </Accordion>
  <Accordion title="Simple mental model">
    State is just values that change over time. Access them with `value()` and update them with `setValue(newValue)`.
  </Accordion>
  <Accordion title="Mutable-like API with Stores">
    Solid's `createStore` lets you update deeply nested state easily, while maintaining immutability under the hood.
  </Accordion>
</AccordionGroup>

## Basic Signals

For simple state like strings, numbers, or booleans, use `createSignal`:

```tsx
import { createSignal } from 'solid-js'
import { Claude, Phase, Step } from '@evmts/smithers'

function ResearchAgent(props) {
  // Define signals
  const [phase, setPhase] = createSignal('research')
  const [findings, setFindings] = createSignal(null)

  // Use a closure to create a reactive effect (standard Smithers pattern)
  return () => {
    const p = phase()

    if (p === 'research') {
      return (
        <Claude tools={[webSearch]} onFinished={(result) => {
          setFindings(result)
          setPhase('write')
        }}>
          Research {props.topic}.
        </Claude>
      )
    }

    return (
      <Claude tools={[filesystem]}>
        Write report based on: {JSON.stringify(findings())}
      </Claude>
    )
  }
}
```

## Complex State with Stores

For objects and arrays, use `createStore`. It provides a powerful path-syntax for updates:

```tsx
import { createStore } from 'solid-js/store'

function ComplexAgent(props) {
  const [state, setState] = createStore({
    phase: 'research',
    data: {
      sources: [],
      analysis: {},
      metrics: { confidence: 0 }
    }
  })

  const addSource = (source) => {
    // Append to array without cloning the whole state
    setState('data', 'sources', (prev) => [...prev, source])
  }

  const updateMetric = (key, value) => {
    // Deep update
    setState('data', 'metrics', key, value)
  }

  return () => {
    // ... logic using state.data.sources etc.
  }
}
```

## The "Stale Closure" Problem (Solved)

In React, you often struggle with closures capturing old state values. In Solid, this isn't an issue because you access state via function calls (`signal()`) or property access on a live proxy (`store.prop`).

```tsx
// React (Problematic)
/*
const [count, setCount] = useState(0)
useEffect(() => {
  const timer = setInterval(() => {
    console.log(count) // Always 0! captured in closure
  }, 1000)
}, [])
*/

// SolidJS (Correct)
const [count, setCount] = createSignal(0)
// This just works
setInterval(() => {
  console.log(count()) // Always prints current value
}, 1000)
```

## Complex State Machines

For agents with complex flows, model explicit state machines:

```tsx
import { createStore } from 'solid-js/store'

function WorkflowAgent() {
  const [state, setState] = createStore({
    status: 'idle', // idle | planning | executing | reviewing | complete
    plan: null,
    results: [],
    error: null
  })

  // Actions
  const actions = {
    start: () => setState('status', 'planning'),
    
    setPlan: (plan) => setState({ plan, status: 'executing' }),
    
    addResult: (result) => {
      setState('results', (prev) => [...prev, result])
      
      const allDone = state.results.length === state.plan.tasks.length
      if (allDone) setState('status', 'reviewing')
    },
    
    fail: (error) => setState({ error, status: 'error' })
  }

  return () => {
    switch (state.status) {
      case 'idle':
        return <Claude onFinished={actions.start}>Ready?</Claude>
      
      case 'planning':
        return <Claude onFinished={actions.setPlan}>Create plan...</Claude>
        
      // ... cases
    }
  }
}
```

## Derived State (Computed Values)

Use memos (`createMemo`) or simple functions for derived state. Solid tracks dependencies automatically.

```tsx
import { createMemo } from 'solid-js'

function TaskAgent(props) {
  const [tasks, setTasks] = createSignal([])
  
  // Computed value - updates only when tasks() changes
  const completedCount = createMemo(() => 
    tasks().filter(t => t.done).length
  )
  
  const progress = createMemo(() => 
    tasks().length > 0 ? completedCount() / tasks().length : 0
  )

  return () => (
    <Claude>
      Status: {Math.round(progress() * 100)}% complete
      ({completedCount()} / {tasks().length} tasks)
    </Claude>
  )
}
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Use Stores for Objects" icon="layer-group">
    `createStore` makes handling nested data and arrays much easier than `createSignal`.
  </Card>
  <Card title="Return a Closure" icon="code">
    Return `() => JSX` from your main component to ensure reactivity works as expected in the Smithers loop.
  </Card>
  <Card title="Colocate Actions" icon="bolt">
    Define state helper functions (actions) inside your component or extract them to a custom hook.
  </Card>
  <Card title="Use Memos" icon="calculator">
    Use `createMemo` for expensive calculations derived from state.
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Claude Component" icon="cube" href="/components/claude">
    Learn how to use onFinished callbacks effectively
  </Card>
  <Card title="Multi-Agent Example" icon="users" href="/examples/multi-agent">
    See state management in a real multi-agent workflow
  </Card>
</CardGroup>
