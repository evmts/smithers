---
title: The Ralph Wiggum Loop
description: How the plan evolves over time
---

# The Ralph Wiggum Loop

[Ralph](https://ghuntley.com/ralph/) is the autonomous agent loop pattern. Each iteration:

1. **Render** - React components render the execution plan
2. **Execute** - Runnable agents execute
3. **Update** - Agent output updates state
4. **Re-render** - State change triggers re-render
5. **Loop** - Repeat until done

> The Ralph Wiggum loop is Smithers' render–execute–persist cycle: render the React plan, execute runnable agents, persist a frame to SQLite, then re-render until completion.

```
Iteration 1: <Phase name="research">...</Phase>
Iteration 2: <Phase name="implement">...</Phase>  ← state changed
Iteration 3: <Phase name="implement">...</Phase>  ← agent still working
Iteration 4: <Phase name="test">...</Phase>       ← structured output
Iteration 5: <Phase name="done" />                ← loop complete
```

React handles diffing. Ralph handles iteration. SQLite handles persistence.

## The Execution Model

Smithers uses a reactive render loop powered by React state:

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌──────────┐    ┌─────────┐    ┌──────────────────┐   │
│  │  Render  │───▶│ Execute │───▶│ Update Signals   │   │
│  │  React   │    │ Agents  │    │ (onFinished)     │   │
│  └──────────┘    └─────────┘    └──────────────────┘   │
│       ▲                                   │             │
│       │                                   │             │
│       └───────────────────────────────────┘             │
│                  (re-render on signal change)           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

1. **Render**: Your React components render using React's state management
2. **Execute**: `<Claude>` nodes execute via the Claude CLI
3. **Update**: `onFinished` callbacks update React state
4. **Re-render**: State changes trigger reactive updates
5. **Loop**: Process repeats until no pending agents remain

## Why Smithers for Ralphing

You're not programming what agents *do*. You're programming the *plan*, and how it evolves.

| Other Frameworks | Smithers |
|------------------|----------|
| Program the agents (imperative) | Program the plan (declarative) |
| `agent.do_step_1()` | `<Phase name="implement">` |
| Plans live in prompts | Plans are reviewable code |
| Manual orchestration | Claude generates it for you |
| Static execution | Plan evolves based on agent output |

**Smithers is Terraform for agents.** You declare the desired workflow. The reconciler figures out how to get there.

## Controlling the Ralph Loop

You control iteration using the `<Ralph>` component inside `<SmithersProvider>`. The `condition` prop determines when to stop:

```tsx
import { SmithersProvider, Ralph, useSmithers, Claude, If } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator";

function IterativeWorkflowBody({ attempts, testsPassing }) {
  const { db } = useSmithers();

  return (
    <If condition={!testsPassing}>
      <Claude
        model="sonnet"
        onFinished={(result) => {
          db.db.run(
            "INSERT OR REPLACE INTO state (key, value) VALUES ('attempts', ?)",
            [attempts + 1]
          );
          if (result.output.includes("All tests pass")) {
            db.db.run(
              "INSERT OR REPLACE INTO state (key, value) VALUES ('tests_passing', 1)"
            );
          }
        }}
      >
        Fix the failing tests. Current attempt: {attempts}
      </Claude>
    </If>
  );
}

function IterativeWorkflowInner() {
  const { db } = useSmithers();
  
  // State in SQLite, not useState (see State Management docs)
  const { data: attemptsVal } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'attempts'",
    []
  );
  const attempts = attemptsVal ?? 0;

  const { data: testsPassingVal } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'tests_passing'",
    []
  );
  const testsPassing = Boolean(testsPassingVal);

  return (
    <Ralph
      id="main"
      condition={() => !testsPassing}
      maxIterations={5}
      onIteration={(i) => console.log(`Iteration ${i}`)}
      onComplete={() => console.log("Workflow complete")}
    >
      <IterativeWorkflowBody attempts={attempts} testsPassing={testsPassing} />
    </Ralph>
  );
}

export function IterativeWorkflow({ db, executionId }) {
  return (
    <SmithersProvider db={db} executionId={executionId}>
      <IterativeWorkflowInner />
    </SmithersProvider>
  );
}
```

### Implicit Stopping

Ralph also stops implicitly when nothing renders for an iteration. If no components mount and register tasks, the loop assumes the workflow is complete.

**What this means:**
- Your agents can run for hours; this only applies to detecting when there's nothing left to do
- If any component calls `db.tasks.start()`, the loop waits for that task to complete

Using the `condition` prop is more explicit and recommended.

## State: db.state vs db.tasks

Smithers has two state systems. Use the right one (note: [`<Task>`](/components/task) is presentational only—see below for runtime tracking):

| API | Purpose | Example |
|-----|---------|---------|
| `db.state` | Workflow state that drives rendering | Current phase, attempt count, flags |
| `db.tasks` | Track in-flight async work | API calls, file operations, agent execution |

```tsx
// db.state: Controls WHAT renders
db.state.set("phase", "implement");  // Triggers re-render, shows different UI
const phase = db.state.get("phase");

// db.tasks: Controls WHEN the loop advances
const taskId = db.tasks.start("fetch-api");
await fetch("/api/data");
db.tasks.complete(taskId);  // Loop can now advance
```

**Rule of thumb:** `db.state` answers "what phase are we in?" `db.tasks` answers "is work still running?"

## useQueryValue: Reactive SQLite State

`useQueryValue` makes SQLite state reactive: when the database changes, your component re-renders:

```tsx
import { useQueryValue } from "smithers-orchestrator";

function MyComponent() {
  const { db } = useSmithers();
  
  // Reactive: re-renders when 'phase' changes in DB
  const { data: phase } = useQueryValue<string>(
    db.db,
    "SELECT value FROM state WHERE key = 'phase'",
    []
  );
  
  // Update triggers re-render automatically
  const setPhase = (p: string) => db.state.set("phase", p);
  
  return <Text>{phase ?? "loading..."}</Text>;
}
```

**vs useState:** `useState` is lost on restart and doesn't persist. `useQueryValue` reads from SQLite, survives restarts, and syncs across components.

## Reactive Updates

The power of the Ralph Loop comes from React reactivity:

```tsx
import { SmithersProvider, Ralph, Claude, If } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator";

function PhaseWorkflowBody({ phase, setPhase }) {
  return (
    <>
      <If condition={phase === "research"}>
        <Claude onFinished={() => setPhase("implement")}>
          Research the problem space.
        </Claude>
      </If>

      <If condition={phase === "implement"}>
        <Claude onFinished={() => setPhase("test")}>
          Implement the solution.
        </Claude>
      </If>

      <If condition={phase === "test"}>
        <Claude onFinished={(r) => {
          if (r.output.includes("PASS")) {
            setPhase("done");
          } else {
            setPhase("implement");
          }
        }}>
          Run and verify tests.
        </Claude>
      </If>
    </>
  );
}

function PhaseWorkflowInner() {
  const { db } = useSmithers();
  
  // State in SQLite, not useState
  const { data: phaseVal } = useQueryValue<string>(
    db.db,
    "SELECT value FROM state WHERE key = 'phase'",
    []
  );
  const phase = phaseVal ?? "research";

  const setPhase = (newPhase: string) => db.state.set('phase', newPhase);

  return (
    <Ralph id="main" condition={() => phase !== "done"} maxIterations={10}>
      {/* This block re-renders when phase changes */}
      <PhaseWorkflowBody phase={phase} setPhase={setPhase} />
    </Ralph>
  );
}

export function PhaseWorkflow({ db, executionId }) {
  return (
    <SmithersProvider db={db} executionId={executionId}>
      <PhaseWorkflowInner />
    </SmithersProvider>
  );
}
```

When `setPhase("implement")` is called:
1. The database state updates
2. `useQueryValue` detects the change and triggers a re-render
3. Only the affected branch re-renders
4. The new `<Claude>` component mounts and executes

## Fire-and-Forget Pattern

Components use `useMount` to execute when they mount:

```tsx
import { useMount } from "smithers-orchestrator";

function Claude(props) {
  useMount(() => {
    // Fire-and-forget async execution
    (async () => {
      const result = await executeClaudeAgent(props);
      props.onFinished?.(result);
    })();
  });

  return <claude-node {...props} />;
}
```

This means:
- Components execute when they mount
- Results trigger callbacks that update state
- State updates cause re-renders
- New components mount and execute

## React Workflow Rules

Smithers uses React as a workflow DSL. Understanding these rules prevents common mistakes.

### What persists vs what doesn't

```
┌─────────────────────────────────────────────────────────────────┐
│ PERSISTS (survives restarts)          DOES NOT PERSIST          │
│ ─────────────────────────             ─────────────────────     │
│ SQLite state (db.state)               useState / useRef         │
│ db.tasks entries                      Local variables           │
│ db.phases / db.steps                  Closures                  │
│ Execution records                     In-memory caches          │
└─────────────────────────────────────────────────────────────────┘
```

### Dos and Don'ts

<AccordionGroup>
  <Accordion title="✅ DO: Store state in SQLite">
    ```tsx
    // Good - durable
    const { reactiveDb } = useSmithers();
    const { data: phaseVal } = useQueryValue<string>(
      reactiveDb, "SELECT value FROM state WHERE key = 'phase'"
    );
    const phase = phaseVal ?? "start";
    const setPhase = (p: string) => db.state.set('phase', p);
    ```
  </Accordion>

  <Accordion title="❌ DON'T: Use useState for workflow state">
    ```tsx
    // Bad - lost on restart, causes hydration issues
    const [phase, setPhase] = useState("start");
    ```
  </Accordion>

  <Accordion title="✅ DO: Register async work with db.tasks">
    ```tsx
    // Good - orchestrator waits for this to complete
    const taskId = db.tasks.start('fetch-data');
    await fetchData();
    db.tasks.complete(taskId);
    ```
  </Accordion>

  <Accordion title="❌ DON'T: Run untracked async work">
    ```tsx
    // Bad - orchestrator may advance before this completes
    useMount(() => {
      fetchData(); // No tracking!
    });
    ```
  </Accordion>

  <Accordion title="✅ DO: Use onFinished callbacks to drive state">
    ```tsx
    // Good - state change triggers re-render
    <Claude onFinished={() => db.state.set('phase', 'next')}>
      Do work
    </Claude>
    ```
  </Accordion>

  <Accordion title="❌ DON'T: Expect re-renders without state changes">
    ```tsx
    // Bad - nothing triggers advancement
    <Claude onFinished={() => console.log('done')}>
      Do work
    </Claude>
    // Workflow stalls because state didn't change
    ```
  </Accordion>
</AccordionGroup>

### What triggers re-renders

1. **SQLite state changes** via `useQueryValue` or `useQuery`
2. **Task completion** detected by orchestration loop
3. **Phase/Step advancement** managed by PhaseRegistryProvider
4. **Stop conditions** met (token limit, pattern match, timeout)

### Common anti-patterns

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| `useState` for phase | Lost on restart | Use `db.state` + `useQueryValue` |
| Untracked promises | Orchestrator advances early | Use `db.tasks.start/complete` |
| No `onFinished` callback | Workflow stalls | Always update state in `onFinished` |
| Infinite `maxIterations` | Runaway loops | Set reasonable limits (10-100) |

## Orchestration Context

SmithersProvider exposes orchestration context via `useSmithers()`:

```tsx
import { useSmithers, useMount } from "smithers-orchestrator";
import { useRef } from "react";

function CustomStep() {
  const { db } = useSmithers();
  const taskIdRef = useRef<string | null>(null);

  useMount(() => {
    taskIdRef.current = db.tasks.start("custom-step");

    doSomeWork().finally(() => {
      if (taskIdRef.current) {
        db.tasks.complete(taskIdRef.current);
      }
    });
  });

  return <step-node />;
}
```

The orchestration context tracks:
- Active tasks (`db.tasks`)
- Completed tasks
- Iteration count
- Stop/timeout state

## Best Practices for Durable Ralphing

<AccordionGroup>
  <Accordion title="Always set maxIterations on Ralph/While">
    Without a limit, a bug in your state logic could cause infinite loops:
    ```tsx
    // Good - explicit limit on Ralph
    <SmithersProvider db={db} executionId={executionId}>
      <Ralph id="main" condition={() => !done} maxIterations={50}>
        ...
      </Ralph>
    </SmithersProvider>

    // Risky - could run forever
    <Ralph id="main" condition={() => !done} maxIterations={Infinity}>
      ...
    </Ralph>
    ```
  </Accordion>

  <Accordion title="Use SQLite state for durability">
    State in SQLite survives restarts. State in memory doesn't:
    ```tsx
    // Good - durable, survives restarts
    const phase = db.state.get('phase') ?? "start";
    const setPhase = (p: string) => db.state.set('phase', p);

    // Bad - lost on restart
    const [phase, setPhase] = useState("start");
    ```
  </Accordion>

  <Accordion title="Handle iteration limits gracefully">
    Know when you've hit the limit:
    ```tsx
    <Ralph
      id="main"
      condition={() => !done}
      maxIterations={50}
      onMaxIterations={() => {
        console.error("Workflow did not complete in 50 iterations");
        db.state.set("status", "needs_attention");
      }}
    >
    ```
  </Accordion>

  <Accordion title="Add verification gates">
    Explicit verification makes loops trustworthy:
    ```tsx
    <Claude
      onFinished={(result) => {
        if (result.output.includes("All tests pass")) {
          db.state.set("verified", "true");
        }
        // Iteration continues until verified
      }}
    >
      Run tests. If any fail, fix them.
    </Claude>
    ```
  </Accordion>
</AccordionGroup>

## Nested Loops (Subralphs)

Smithers supports multiple patterns for nested execution within a Ralph loop:

### While: Condition-Based Subloops

`<While>` creates a subloop that iterates until a condition is false:

```tsx
import { While, Claude, useWhileIteration } from "smithers-orchestrator";

function FixTests() {
  const ctx = useWhileIteration();
  return (
    <Claude
      onFinished={(r) => {
        if (r.output.includes("All tests pass")) {
          ctx?.signalComplete(); // Exits the While loop
        }
      }}
    >
      Run tests. If any fail, fix them. Attempt {ctx?.iteration ?? 0}.
    </Claude>
  );
}

<While id="test-loop" condition={() => true} maxIterations={10}>
  <FixTests />
</While>
```

`While` state persists in SQLite (`while.{id}.iteration`, `while.{id}.status`), so loops survive restarts.

### Smithers: Autonomous Subagents

`<Smithers>` spawns a completely independent subagent that plans and executes a complex task:

```tsx
import { Smithers } from "smithers-orchestrator";

<Smithers
  plannerModel="opus"      // Plans the work
  executionModel="sonnet"  // Executes each step
  timeout={3600000}        // 1 hour limit
  keepScript               // Save generated script for debugging
  onFinished={(result) => {
    console.log(`Completed in ${result.durationMs}ms`);
    db.state.set("phase", "next");
  }}
>
  Implement the notification system: database schema, REST API, WebSocket updates, React components, and tests.
</Smithers>
```

The `<Smithers>` component:
1. Uses Claude to generate a complete Smithers script for the task
2. Executes that script as a subprocess with its own Ralph loop
3. Reports results back to the parent workflow

Subagents can spawn their own subagents for arbitrarily deep nesting.

### Subagent: Named Execution Boundaries

`<Subagent>` groups related agents for debugging and optional parallel execution:

```tsx
import { Subagent, Claude } from "smithers-orchestrator";

<Subagent name="research" parallel>
  <Claude>Research topic A</Claude>
  <Claude>Research topic B</Claude>
</Subagent>
```

### When to Use Each

| Pattern | Use Case |
|---------|----------|
| `While` | Retry loops, polling, iterating until condition |
| `Smithers` | Complex autonomous subtasks needing their own planning |
| `Subagent` | Grouping agents, parallel execution, named scopes |
| `Phase/Step` | Sequential workflow stages |

---

## Ralph/While: The Iteration Loop

`<SmithersProvider>` provides context (database, execution ID) but does **not** run the Ralph loop itself. Use `<Ralph>` or `<While>` inside to provide iteration:

```
┌──────────────────────────────────────────────────────────┐
│ SmithersProvider           │ Context only (db, execution)│
│   └─ Ralph / While         │ Provides the iteration loop │
│        └─ Your components  │ Execute within the loop     │
└──────────────────────────────────────────────────────────┘
```

**Basic Pattern:**

```tsx
import { SmithersProvider, Ralph } from "smithers-orchestrator";

<SmithersProvider db={db} executionId={executionId}>
  <Ralph
    id="main"
    condition={() => !done}
    maxIterations={100}
    onIteration={(i) => console.log(`Iteration ${i}`)}
  >
    <Claude>
      Monitor the repository and respond to changes
    </Claude>
  </Ralph>
</SmithersProvider>
```

**Custom Iteration Limits:**

```tsx
// Quick task - only needs a few iterations
<SmithersProvider db={db} executionId={executionId}>
  <Ralph id="main" condition={() => !done} maxIterations={5}>
    <Claude>Fix the linting errors</Claude>
  </Ralph>
</SmithersProvider>

// Complex multi-phase workflow
<SmithersProvider db={db} executionId={executionId}>
  <Ralph id="main" condition={() => phase !== "complete"} maxIterations={50}>
    <MultiPhaseOrchestration />
  </Ralph>
</SmithersProvider>

// Long-running agent
<SmithersProvider db={db} executionId={executionId}>
  <Ralph id="main" condition={() => true} maxIterations={Infinity}>
    <AutonomousAgent />
  </Ralph>
</SmithersProvider>
```

## Complete Example: Retry Until Tests Pass

This example shows all the pieces working together:

```tsx
#!/usr/bin/env smithers
import {
  createSmithersRoot,
  createSmithersDB,
  SmithersProvider,
  Ralph,
  Claude,
  If,
  useSmithers,
} from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator";

const db = createSmithersDB({ path: ".smithers/retry-tests.db" });
const executionId = db.execution.start("Retry Tests", "retry.tsx");

function RetryWorkflow() {
  const { db } = useSmithers();

  // Reactive state from SQLite
  const { data: attemptsRaw } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) FROM state WHERE key = 'attempts'",
    []
  );
  const attempts = attemptsRaw ?? 0;

  const { data: doneRaw } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) FROM state WHERE key = 'done'",
    []
  );
  const done = Boolean(doneRaw);

  return (
    <If condition={!done}>
      <Claude
        model="sonnet"
        onFinished={(result) => {
          db.state.set("attempts", attempts + 1);
          if (result.output.includes("All tests pass")) {
            db.state.set("done", 1);  // Stops the loop
          }
        }}
      >
        Run the tests. If any fail, fix them. Attempt #{attempts + 1}.
      </Claude>
    </If>
  );
}

function AppInner() {
  const { db } = useSmithers();
  const { data: doneRaw } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) FROM state WHERE key = 'done'",
    []
  );
  const done = Boolean(doneRaw);

  return (
    <Ralph id="main" condition={() => !done} maxIterations={10}>
      <RetryWorkflow />
    </Ralph>
  );
}

function App() {
  return (
    <SmithersProvider db={db} executionId={executionId}>
      <AppInner />
    </SmithersProvider>
  );
}

const root = createSmithersRoot();
await root.mount(App);
db.close();
```

**What happens:**
1. Loop starts, `done=false`, `attempts=0`
2. Claude runs tests, fails, calls `onFinished`
3. `db.state.set("attempts", 1)` triggers re-render
4. Loop iterates, Claude runs again
5. Tests pass → `db.state.set("done", 1)`
6. `condition={() => !done}` returns `false`, loop exits

## Next Steps

<CardGroup cols={2}>
  <Card title="Database Persistence" icon="hard-drive" href="/concepts/database-persistence">
    Persist state across restarts
  </Card>
  <Card title="Examples" icon="code" href="/examples/coverage-loop">
    See more working examples
  </Card>
</CardGroup>
