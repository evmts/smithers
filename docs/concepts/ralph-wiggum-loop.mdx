---
title: Ralph Wiggum Loop
description: The core execution model that powers Smithers orchestration
---

# Ralph Wiggum Loop

The Ralph Wiggum Loop is the core execution model of Smithers. Named after Ralph Wiggum's famous "I'm in danger" catchphrase, it controls iterative loops that could potentially run away.

## The Execution Model

Smithers uses a reactive render loop powered by React state:

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌──────────┐    ┌─────────┐    ┌──────────────────┐   │
│  │  Render  │───▶│ Execute │───▶│ Update Signals   │   │
│  │   JSX    │    │ Claude  │    │ (onFinished)     │   │
│  └──────────┘    └─────────┘    └──────────────────┘   │
│       ▲                                   │             │
│       │                                   │             │
│       └───────────────────────────────────┘             │
│                  (re-render on signal change)           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

1. **Render**: Your JSX components render using React's state management
2. **Execute**: `<Claude>` nodes execute via the Claude Code CLI
3. **Update**: `onFinished` callbacks update React state
4. **Re-render**: State changes trigger reactive updates
5. **Loop**: Process repeats until no pending agents remain

## How It Differs from Other Frameworks

| Traditional Agent Loops | Smithers Ralph Loop |
|------------------------|---------------------|
| Bespoke abstractions LLMs are often not tuned to writing | Familiar reactive declarative framework (React) |
| Imperative while loops | Declarative reactive rendering |
| Manual state tracking | Automatic state propagation |
| Hard to visualize flow | Components describe the flow |
| State scattered in closures | Centralized in React state |

## Controlling the Ralph Loop

You can control the Ralph loop using the `stopped` prop. This is the idiomatic way to stop iteration:

```tsx
import { useSmithers, useQueryValue } from "smithers";

function IterativeWorkflow() {
  const { db } = useSmithers();

  // State in SQLite, not useState (see State Management docs)
  const attempts = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'attempts'"
  ) ?? 0;

  const testsPassing = useQueryValue<boolean>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'tests_passing'"
  ) ?? false;

  return (
    <SmithersProvider
      db={db}
      executionId={db.execution.current()?.id ?? ''}
      maxIterations={5}
      stopped={testsPassing}
      onIteration={(i) => console.log(`Iteration ${i}`)}
      onComplete={() => console.log("Workflow complete")}
    >
      {!testsPassing && (
        <Claude
          model="sonnet"
          onFinished={(result) => {
            db.db.run(
              "INSERT OR REPLACE INTO state (key, value) VALUES ('attempts', ?)",
              [attempts + 1]
            );
            if (result.output.includes("All tests pass")) {
              db.db.run(
                "INSERT OR REPLACE INTO state (key, value) VALUES ('tests_passing', 1)"
              );
            }
          }}
        >
          Fix the failing tests. Current attempt: {attempts}
        </Claude>
      )}
    </SmithersProvider>
  );
}
```

### Implicit Stopping

Ralph also stops implicitly when nothing renders for an iteration. If no components mount and register tasks, the loop completes after 500ms. However, using the `stopped` prop is more explicit and recommended.

## Reactive Updates

The power of the Ralph Loop comes from React reactivity:

```tsx
import { useSmithers, useQueryValue } from "smithers";

function PhaseWorkflow() {
  const { db } = useSmithers();

  // State in SQLite, not useState
  const phase = useQueryValue<string>(
    db.db,
    "SELECT value FROM state WHERE key = 'phase'"
  ) ?? "research";

  const setPhase = (newPhase: string) => {
    db.db.run(
      "INSERT OR REPLACE INTO state (key, value) VALUES ('phase', ?)",
      [newPhase]
    );
  };

  return (
    <SmithersProvider
      db={db}
      executionId={db.execution.current()?.id ?? ''}
      maxIterations={10}
      stopped={phase === "done"}
    >
      {/* This block re-renders when phase changes */}

      {phase === "research" && (
        <Claude onFinished={() => setPhase("implement")}>
          Research the problem space.
        </Claude>
      )}

      {phase === "implement" && (
        <Claude onFinished={() => setPhase("test")}>
          Implement the solution.
        </Claude>
      )}

      {phase === "test" && (
        <Claude onFinished={(r) => {
          if (r.output.includes("PASS")) {
            setPhase("done");
          } else {
            setPhase("implement");
          }
        }}>
          Run and verify tests.
        </Claude>
      )}
    </SmithersProvider>
  );
}
```

When `setPhase("implement")` is called:
1. The database state updates
2. `useQueryValue` detects the change and triggers a re-render
3. Only the affected branch re-renders
4. The new `<Claude>` component mounts and executes

## Fire-and-Forget Pattern

Components use `useMount` to execute when they mount:

```tsx
import { useMount } from "smithers";

function Claude(props) {
  useMount(() => {
    // Fire-and-forget async execution
    (async () => {
      const result = await executeClaudeAgent(props);
      props.onFinished?.(result);
    })();
  });

  return <claude-node {...props} />;
}
```

This means:
- Components execute when they mount
- Results trigger callbacks that update state
- State updates cause re-renders
- New components mount and execute

## Orchestration Context

The `<Ralph>` component provides context for task coordination:

```tsx
import { useRalph, useMount } from "smithers";

function CustomStep() {
  const ralph = useRalph();

  useMount(() => {
    const taskId = ralph.registerTask();

    doSomeWork().then(() => {
      ralph.completeTask(taskId);
    });
  });

  return <step-node />;
}
```

The Ralph context tracks:
- Active tasks
- Completed tasks
- Iteration count
- Orchestration state

## Best Practices

<AccordionGroup>
  <Accordion title="Always set maxIterations">
    Without a limit, a bug in your state logic could cause infinite loops:
    ```tsx
    // Good
    <Ralph maxIterations={10}>...</Ralph>

    // Risky
    <Ralph>...</Ralph>
    ```
  </Accordion>

  <Accordion title="Use SQLite state for phase transitions">
    Let reactivity drive the flow instead of imperative logic. Store state in SQLite, not useState:
    ```tsx
    // Good - reactive with SQLite
    const phase = useQueryValue<string>(db.db,
      "SELECT value FROM state WHERE key = 'phase'") ?? "start";
    const setPhase = (p: string) =>
      db.db.run("INSERT OR REPLACE INTO state (key, value) VALUES ('phase', ?)", [p]);
    {phase === "start" && <Claude onFinished={() => setPhase("next")} />}

    // Avoid - imperative
    let phase = "start";
    while (phase !== "done") { ... }
    ```
  </Accordion>

  <Accordion title="Handle the maxIterations callback">
    Know when you've hit the limit:
    ```tsx
    <Ralph
      maxIterations={10}
      onMaxIterations={() => {
        console.error("Workflow did not complete in 10 iterations");
        db.state.set("status", "failed");
      }}
    >
    ```
  </Accordion>
</AccordionGroup>

## SmithersProvider: The Root Ralph Loop

`<SmithersProvider>` is a special Ralph Wiggum Loop that serves as the root orchestration wrapper. Unlike `<Ralph>` which is used for specific workflows within your component tree, `<SmithersProvider>` wraps your entire orchestration and manages the global Ralph loop.

**Default Behavior:**
By default, `<SmithersProvider>` runs the Ralph loop for up to **100 iterations**. This is sufficient for most workflows.

**Infinite Loops:**
For long-running orchestrations that need to continue indefinitely (like CI/CD monitors, autonomous agents, or server processes), you can configure it to run forever:

```tsx
import { SmithersProvider } from "smithers";

<SmithersProvider
  db={db}
  executionId={executionId}
  maxIterations={Infinity}
  onIteration={(i) => console.log(`Iteration ${i}`)}
>
  <Claude>
    Monitor the repository and respond to changes
  </Claude>
</SmithersProvider>
```

**Custom Iteration Limits:**
You can also set custom limits based on your workflow needs:

```tsx
// Quick task - only needs a few iterations
<SmithersProvider maxIterations={5}>
  <Claude>Fix the linting errors</Claude>
</SmithersProvider>

// Complex multi-phase workflow
<SmithersProvider maxIterations={50}>
  <MultiPhaseOrchestration />
</SmithersProvider>

// Long-running agent
<SmithersProvider maxIterations={Infinity}>
  <AutonomousAgent />
</SmithersProvider>
```

## Next Steps

<CardGroup cols={2}>
  <Card title="React State Management" icon="database" href="https://react.dev/learn/managing-state">
    Learn about React state from official docs
  </Card>
  <Card title="Database Persistence" icon="hard-drive" href="/concepts/database-persistence">
    Persist state across restarts
  </Card>
</CardGroup>
