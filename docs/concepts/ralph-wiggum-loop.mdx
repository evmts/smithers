---
title: Ralph Wiggum Loop
description: The core execution model that powers Smithers orchestration
---

# Ralph Wiggum Loop

The Ralph Wiggum Loop is the core execution model of Smithers. Named after Ralph Wiggum's famous "I'm in danger" catchphrase, it controls iterative loops that could potentially run away.

## The Execution Model

Smithers uses a reactive render loop powered by React state:

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌──────────┐    ┌─────────┐    ┌──────────────────┐   │
│  │  Render  │───▶│ Execute │───▶│ Update Signals   │   │
│  │   JSX    │    │ Claude  │    │ (onFinished)     │   │
│  └──────────┘    └─────────┘    └──────────────────┘   │
│       ▲                                   │             │
│       │                                   │             │
│       └───────────────────────────────────┘             │
│                  (re-render on signal change)           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

1. **Render**: Your JSX components render using React's state management
2. **Execute**: `<Claude>` nodes execute via the Claude Code CLI
3. **Update**: `onFinished` callbacks update React state
4. **Re-render**: State changes trigger reactive updates
5. **Loop**: Process repeats until no pending agents remain

## How It Differs from Other Frameworks

| Traditional Agent Loops | Smithers Ralph Loop |
|------------------------|---------------------|
| Bespoke abstractions LLMs are often not tuned to writing | Familiar reactive declarative framework (React) |
| Imperative while loops | Declarative reactive rendering |
| Manual state tracking | Automatic state propagation |
| Hard to visualize flow | Components describe the flow |
| State scattered in closures | Centralized in React state |

## The Ralph Component

The `<Ralph>` component wraps iterative workflows:

```tsx
import { useState } from "react";

function IterativeWorkflow() {
  const [attempts, setAttempts] = useState(0);
  const [testsPassing, setTestsPassing] = useState(false);

  return (
    <Ralph
      maxIterations={5}
      onIteration={(i) => console.log(`Iteration ${i}`)}
      onComplete={() => console.log("Workflow complete")}
    >
      {!testsPassing && (
        <Claude
          model="sonnet"
          onFinished={(result) => {
            setAttempts(a => a + 1);
            if (result.output.includes("All tests pass")) {
              setTestsPassing(true);
            }
          }}
        >
          Fix the failing tests. Current attempt: {attempts}
        </Claude>
      )}
    </Ralph>
  );
}
```

## Reactive Updates

The power of the Ralph Loop comes from React reactivity:

```tsx
function PhaseWorkflow() {
  const [phase, setPhase] = useState("research");

  return (
    <Ralph maxIterations={10}>
      {/* This block re-renders when phase changes */}

      {phase === "research" && (
        <Claude onFinished={() => setPhase("implement")}>
          Research the problem space.
        </Claude>
      )}

      {phase === "implement" && (
        <Claude onFinished={() => setPhase("test")}>
          Implement the solution.
        </Claude>
      )}

      {phase === "test" && (
        <Claude onFinished={(r) => {
          if (r.output.includes("PASS")) {
            setPhase("done");
          } else {
            setPhase("implement");
          }
        }}>
          Run and verify tests.
        </Claude>
      )}
    </Ralph>
  );
}
```

When `setPhase("implement")` is called:
1. The state updates
2. React detects the change
3. Only the affected branch re-renders
4. The new `<Claude>` component mounts and executes

## Fire-and-Forget Pattern

Components use `useMount` to execute when they mount:

```tsx
import { useMount } from "smithers";

function Claude(props) {
  useMount(() => {
    // Fire-and-forget async execution
    (async () => {
      const result = await executeClaudeAgent(props);
      props.onFinished?.(result);
    })();
  });

  return <claude-node {...props} />;
}
```

This means:
- Components execute when they mount
- Results trigger callbacks that update state
- State updates cause re-renders
- New components mount and execute

## Orchestration Context

The `<Ralph>` component provides context for task coordination:

```tsx
import { useRalph, useMount } from "smithers";

function CustomStep() {
  const ralph = useRalph();

  useMount(() => {
    const taskId = ralph.registerTask();

    doSomeWork().then(() => {
      ralph.completeTask(taskId);
    });
  });

  return <step-node />;
}
```

The Ralph context tracks:
- Active tasks
- Completed tasks
- Iteration count
- Orchestration state

## Best Practices

<AccordionGroup>
  <Accordion title="Always set maxIterations">
    Without a limit, a bug in your state logic could cause infinite loops:
    ```tsx
    // Good
    <Ralph maxIterations={10}>...</Ralph>

    // Risky
    <Ralph>...</Ralph>
    ```
  </Accordion>

  <Accordion title="Use state for phase transitions">
    Let reactivity drive the flow instead of imperative logic:
    ```tsx
    // Good - reactive
    const [phase, setPhase] = useState("start");
    {phase === "start" && <Claude onFinished={() => setPhase("next")} />}

    // Avoid - imperative
    let phase = "start";
    while (phase !== "done") { ... }
    ```
  </Accordion>

  <Accordion title="Handle the maxIterations callback">
    Know when you've hit the limit:
    ```tsx
    <Ralph
      maxIterations={10}
      onMaxIterations={() => {
        console.error("Workflow did not complete in 10 iterations");
        db.state.set("status", "failed");
      }}
    >
    ```
  </Accordion>
</AccordionGroup>

## SmithersProvider: The Root Ralph Loop

`<SmithersProvider>` is a special Ralph Wiggum Loop that serves as the root orchestration wrapper. Unlike `<Ralph>` which is used for specific workflows within your component tree, `<SmithersProvider>` wraps your entire orchestration and manages the global Ralph loop.

**Default Behavior:**
By default, `<SmithersProvider>` runs the Ralph loop for up to **100 iterations**. This is sufficient for most workflows.

**Infinite Loops:**
For long-running orchestrations that need to continue indefinitely (like CI/CD monitors, autonomous agents, or server processes), you can configure it to run forever:

```tsx
import { SmithersProvider } from "smithers";

<SmithersProvider
  db={db}
  executionId={executionId}
  maxIterations={Infinity}
  onIteration={(i) => console.log(`Iteration ${i}`)}
>
  <Claude>
    Monitor the repository and respond to changes
  </Claude>
</SmithersProvider>
```

**Custom Iteration Limits:**
You can also set custom limits based on your workflow needs:

```tsx
// Quick task - only needs a few iterations
<SmithersProvider maxIterations={5}>
  <Claude>Fix the linting errors</Claude>
</SmithersProvider>

// Complex multi-phase workflow
<SmithersProvider maxIterations={50}>
  <MultiPhaseOrchestration />
</SmithersProvider>

// Long-running agent
<SmithersProvider maxIterations={Infinity}>
  <AutonomousAgent />
</SmithersProvider>
```

## Next Steps

<CardGroup cols={2}>
  <Card title="React State Management" icon="database" href="https://react.dev/learn/managing-state">
    Learn about React state from official docs
  </Card>
  <Card title="Database Persistence" icon="hard-drive" href="/concepts/database-persistence">
    Persist state across restarts
  </Card>
</CardGroup>
