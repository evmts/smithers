---
title: The Ralph Wiggum Loop
description: Understanding Smithers' iterative execution model
---

# The Ralph Wiggum Loop

Smithers executes agents using what we call the "Ralph Wiggum" technique - named after the simple, iterative approach: run the agent, get the result, repeat until done.

## The Basic Loop

Each iteration of the loop is called a "frame". Here's what happens in each frame:

```
┌─────────────────────────────────────────────────────────────┐
│  1. RENDER                                                  │
│     JSX Components → SmithersNode Tree → XML Plan                │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  2. DISPLAY (optional)                                      │
│     Show plan to user, get approval                         │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  3. EXECUTE                                                 │
│     Run pending <Claude> and <Subagent> nodes               │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  4. UPDATE                                                  │
│     onFinished callbacks update React state                 │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  5. RE-RENDER                                               │
│     State change triggers new render → Loop back to 1       │
└─────────────────────────────────────────────────────────────┘
```

The loop continues until there are no more pending `<Claude>` nodes to execute.

## Why This Approach?

<AccordionGroup>
  <Accordion title="Simple mental model">
    You don't need to think about complex orchestration. Write React components with conditional rendering, and the loop handles execution.
  </Accordion>
  <Accordion title="Emergent behavior">
    Complex multi-step workflows emerge naturally from simple state transitions. Each render produces a new plan based on current state.
  </Accordion>
  <Accordion title="Debuggable">
    Each frame produces a visible XML plan. You can inspect exactly what the agent will do at each step.
  </Accordion>
  <Accordion title="Composable">
    Components don't need to know about the loop. They just render based on props and state.
  </Accordion>
</AccordionGroup>

## Frame-by-Frame Example

Let's trace through a simple multi-phase agent:

```tsx
function ResearchAgent({ topic }) {
  const [phase, setPhase] = useState('research')
  const [findings, setFindings] = useState(null)

  if (phase === 'research') {
    return (
      <Claude onFinished={(data) => {
        setFindings(data)
        setPhase('write')
      }}>
        Research {topic}. Find key facts.
      </Claude>
    )
  }

  return (
    <Claude>
      Write a report based on: {JSON.stringify(findings)}
    </Claude>
  )
}
```

### Frame 1: Research Phase

**State**: `{ phase: 'research', findings: null }`

**Rendered XML**:
```xml
<claude>
  Research quantum computing. Find key facts.
</claude>
```

**Execution**: Claude researches the topic

**Update**: `onFinished` sets `findings` and changes `phase` to 'write'

### Frame 2: Write Phase

**State**: `{ phase: 'write', findings: {...} }`

**Rendered XML**:
```xml
<claude>
  Write a report based on: {"key_facts": [...]}
</claude>
```

**Execution**: Claude writes the report

**Update**: No more state changes

### Frame 3: Complete

No pending `<Claude>` nodes remain. The loop exits and returns the final result.

## Parallel Execution

When multiple `<Subagent>` components render, they execute in parallel within the same frame:

```tsx
function ParallelResearch({ topics }) {
  const [results, setResults] = useState({})

  const pending = topics.filter(t => !results[t])

  if (pending.length > 0) {
    return (
      <>
        {pending.map(topic => (
          <Subagent key={topic} name={`researcher-${topic}`}>
            <Claude onFinished={(data) => {
              setResults(prev => ({ ...prev, [topic]: data }))
            }}>
              Research: {topic}
            </Claude>
          </Subagent>
        ))}
      </>
    )
  }

  return (
    <Claude>
      Synthesize results: {JSON.stringify(results)}
    </Claude>
  )
}
```

### Frame 1: Parallel Research

All `<Subagent>` components execute concurrently:

```xml
<subagent name="researcher-AI">
  <claude>Research: AI</claude>
</subagent>
<subagent name="researcher-ML">
  <claude>Research: ML</claude>
</subagent>
<subagent name="researcher-DL">
  <claude>Research: DL</claude>
</subagent>
```

As each completes, `onFinished` updates state. The loop waits for all parallel executions before the next frame.

### Frame 2: Synthesis

Once all results are in, the conditional renders the synthesis phase:

```xml
<claude>
  Synthesize results: {"AI": {...}, "ML": {...}, "DL": {...}}
</claude>
```

## Execution Order

Within a single frame:

1. **Sequential `<Claude>` nodes**: Execute one at a time, in render order
2. **`<Subagent>` nodes**: Execute in parallel with each other after sequential nodes finish
3. **Mixed**: If a sequential node triggers a state change, subagents wait until the next frame

```tsx
// Frame execution order:
<>
  <Claude>Task 1</Claude>           {/* Runs first */}
  <Claude>Task 2</Claude>           {/* Runs second (after Task 1) */}
  <Subagent name="a">
    <Claude>Parallel A</Claude>     {/* Runs after sequential nodes */}
  </Subagent>
  <Subagent name="b">
    <Claude>Parallel B</Claude>     {/* Runs after sequential nodes */}
  </Subagent>
</>
```

## Safety Limits

To prevent infinite loops, Smithers includes safety mechanisms:

<ParamField path="maxFrames" type="number" default="100">
  Maximum number of frames before the loop terminates. Override with `--max-frames`.
</ParamField>

<ParamField path="timeout" type="number">
  Total execution timeout in milliseconds. Override with `--timeout`.
</ParamField>

```bash
# Run with custom limits
smithers run agent.tsx --max-frames 50 --timeout 300000
```

## Programmatic Control

Access frame-level information in code:

```tsx
import { executePlan } from 'smithers'

const result = await executePlan(<MyAgent />, {
  maxFrames: 50,
  onPlan: (xml, frame) => {
    console.log(`Frame ${frame}:`)
    console.log(xml)
  },
  onFrame: (frameResult) => {
    console.log('Completed nodes:', frameResult.executedNodes)
  },
})

console.log('Total frames:', result.frames)
console.log('Final output:', result.output)
```

## Next Steps

<CardGroup cols={2}>
  <Card title="State Management" icon="database" href="/concepts/state-management">
    Learn Zustand patterns for managing agent state
  </Card>
  <Card title="Subagent Component" icon="layer-group" href="/components/subagent">
    Deep dive into parallel execution
  </Card>
</CardGroup>
