---
title: The Ralph Loop
description: How the plan evolves over time
---

# The Ralph Loop

[Ralph](https://ghuntley.com/ralph/) is the autonomous agent loop pattern. Each iteration:

1. Render React → execution plan
2. Execute runnable agents
3. Agent output updates state
4. State change triggers re-render
5. Loop until done

```
Iteration 1: <Phase name="research">...</Phase>
Iteration 2: <Phase name="implement">...</Phase>  ← state changed
Iteration 3: <Phase name="implement">...</Phase>  ← agent still working
Iteration 4: <Phase name="test">...</Phase>       ← structured output
Iteration 5: <Phase name="done" />                ← loop complete
```

React handles diffing. Ralph handles iteration. SQLite handles persistence.

## The Execution Model

Smithers uses a reactive render loop powered by React state:

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌──────────┐    ┌─────────┐    ┌──────────────────┐   │
│  │  Render  │───▶│ Execute │───▶│ Update Signals   │   │
│  │  React   │    │ Agents  │    │ (onFinished)     │   │
│  └──────────┘    └─────────┘    └──────────────────┘   │
│       ▲                                   │             │
│       │                                   │             │
│       └───────────────────────────────────┘             │
│                  (re-render on signal change)           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

1. **Render**: Your React components render using React's state management
2. **Execute**: `<Claude>` nodes execute via the Claude CLI
3. **Update**: `onFinished` callbacks update React state
4. **Re-render**: State changes trigger reactive updates
5. **Loop**: Process repeats until no pending agents remain

## Why Smithers for Ralphing

You're not programming what agents *do*. You're programming the *plan*—and how it evolves.

| Other Frameworks | Smithers |
|------------------|----------|
| Program the agents (imperative) | Program the plan (declarative) |
| `agent.do_step_1()` | `<Phase name="implement">` |
| Plans live in prompts | Plans are reviewable code |
| Manual orchestration | Claude generates it for you |
| Static execution | Plan evolves based on agent output |

**Smithers is Terraform for agents.** You declare the desired workflow. The reconciler figures out how to get there.

## Controlling the Ralph Loop

You can control the Ralph loop using the `stopped` prop. This is the idiomatic way to stop iteration:

```tsx
import { SmithersProvider, useSmithers, Claude, If } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator/reactive-sqlite";

function IterativeWorkflowBody({ attempts, testsPassing }) {
  const { db } = useSmithers();

  return (
    <If condition={!testsPassing}>
      <Claude
        model="sonnet"
        onFinished={(result) => {
          db.db.run(
            "INSERT OR REPLACE INTO state (key, value) VALUES ('attempts', ?)",
            [attempts + 1]
          );
          if (result.output.includes("All tests pass")) {
            db.db.run(
              "INSERT OR REPLACE INTO state (key, value) VALUES ('tests_passing', 1)"
            );
          }
        }}
      >
        Fix the failing tests. Current attempt: {attempts}
      </Claude>
    </If>
  );
}

export function IterativeWorkflow({ db, executionId }) {
  // State in SQLite, not useState (see State Management docs)
  const { data: attemptsVal } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'attempts'"
  );
  const attempts = attemptsVal ?? 0;

  const { data: testsPassingVal } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'tests_passing'"
  );
  const testsPassing = Boolean(testsPassingVal);

  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={5}
      stopped={testsPassing}
      onIteration={(i) => console.log(`Iteration ${i}`)}
      onComplete={() => console.log("Workflow complete")}
    >
      <IterativeWorkflowBody attempts={attempts} testsPassing={testsPassing} />
    </SmithersProvider>
  );
}
```

### Implicit Stopping

Ralph also stops implicitly when nothing renders for an iteration. If no components mount and register tasks, the loop completes after 500ms. However, using the `stopped` prop is more explicit and recommended.

## Reactive Updates

The power of the Ralph Loop comes from React reactivity:

```tsx
import { SmithersProvider, Claude, If } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator/reactive-sqlite";

function PhaseWorkflowBody({ phase, setPhase }) {
  return (
    <>
      <If condition={phase === "research"}>
        <Claude onFinished={() => setPhase("implement")}>
          Research the problem space.
        </Claude>
      </If>

      <If condition={phase === "implement"}>
        <Claude onFinished={() => setPhase("test")}>
          Implement the solution.
        </Claude>
      </If>

      <If condition={phase === "test"}>
        <Claude onFinished={(r) => {
          if (r.output.includes("PASS")) {
            setPhase("done");
          } else {
            setPhase("implement");
          }
        }}>
          Run and verify tests.
        </Claude>
      </If>
    </>
  );
}

export function PhaseWorkflow({ db, executionId }) {
  // State in SQLite, not useState
  const { data: phaseVal } = useQueryValue<string>(
    db.db,
    "SELECT value FROM state WHERE key = 'phase'"
  );
  const phase = phaseVal ?? "research";

  const setPhase = (newPhase: string) => db.state.set('phase', newPhase);

  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}
      stopped={phase === "done"}
    >
      {/* This block re-renders when phase changes */}
      <PhaseWorkflowBody phase={phase} setPhase={setPhase} />
    </SmithersProvider>
  );
}
```

When `setPhase("implement")` is called:
1. The database state updates
2. `useQueryValue` detects the change and triggers a re-render
3. Only the affected branch re-renders
4. The new `<Claude>` component mounts and executes

## Fire-and-Forget Pattern

Components use `useMount` to execute when they mount:

```tsx
import { useMount } from "smithers-orchestrator";

function Claude(props) {
  useMount(() => {
    // Fire-and-forget async execution
    (async () => {
      const result = await executeClaudeAgent(props);
      props.onFinished?.(result);
    })();
  });

  return <claude-node {...props} />;
}
```

This means:
- Components execute when they mount
- Results trigger callbacks that update state
- State updates cause re-renders
- New components mount and execute

## React Workflow Rules

Smithers uses React as a workflow DSL. Understanding these rules prevents common mistakes.

### What persists vs what doesn't

```
┌─────────────────────────────────────────────────────────────────┐
│ PERSISTS (survives restarts)          DOES NOT PERSIST          │
│ ─────────────────────────             ─────────────────────     │
│ SQLite state (db.state)               useState / useRef         │
│ db.tasks entries                      Local variables           │
│ db.phases / db.steps                  Closures                  │
│ Execution records                     In-memory caches          │
└─────────────────────────────────────────────────────────────────┘
```

### Dos and Don'ts

<AccordionGroup>
  <Accordion title="✅ DO: Store state in SQLite">
    ```tsx
    // Good - durable
    const { data: phaseVal } = useQueryValue<string>(db.db,
      "SELECT value FROM state WHERE key = 'phase'");
    const phase = phaseVal ?? "start";
    const setPhase = (p: string) => db.state.set('phase', p);
    ```
  </Accordion>

  <Accordion title="❌ DON'T: Use useState for workflow state">
    ```tsx
    // Bad - lost on restart, causes hydration issues
    const [phase, setPhase] = useState("start");
    ```
  </Accordion>

  <Accordion title="✅ DO: Register async work with db.tasks">
    ```tsx
    // Good - orchestrator waits for this to complete
    const taskId = db.tasks.start('fetch-data');
    await fetchData();
    db.tasks.complete(taskId);
    ```
  </Accordion>

  <Accordion title="❌ DON'T: Run untracked async work">
    ```tsx
    // Bad - orchestrator may advance before this completes
    useMount(() => {
      fetchData(); // No tracking!
    });
    ```
  </Accordion>

  <Accordion title="✅ DO: Use onFinished callbacks to drive state">
    ```tsx
    // Good - state change triggers re-render
    <Claude onFinished={() => db.state.set('phase', 'next')}>
      Do work
    </Claude>
    ```
  </Accordion>

  <Accordion title="❌ DON'T: Expect re-renders without state changes">
    ```tsx
    // Bad - nothing triggers advancement
    <Claude onFinished={() => console.log('done')}>
      Do work
    </Claude>
    // Workflow stalls because state didn't change
    ```
  </Accordion>
</AccordionGroup>

### What triggers re-renders

1. **SQLite state changes** via `useQueryValue` or `useQuery`
2. **Task completion** detected by orchestration loop
3. **Phase/Step advancement** managed by PhaseRegistryProvider
4. **Stop conditions** met (token limit, pattern match, timeout)

### Common anti-patterns

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| `useState` for phase | Lost on restart | Use `db.state` + `useQueryValue` |
| Untracked promises | Orchestrator advances early | Use `db.tasks.start/complete` |
| No `onFinished` callback | Workflow stalls | Always update state in `onFinished` |
| Infinite `maxIterations` | Runaway loops | Set reasonable limits (10-100) |

## Orchestration Context

SmithersProvider exposes orchestration context via `useSmithers()`:

```tsx
import { useSmithers, useMount } from "smithers-orchestrator";
import { useRef } from "react";

function CustomStep() {
  const { db } = useSmithers();
  const taskIdRef = useRef<string | null>(null);

  useMount(() => {
    taskIdRef.current = db.tasks.start("custom-step");

    doSomeWork().finally(() => {
      if (taskIdRef.current) {
        db.tasks.complete(taskIdRef.current);
      }
    });
  });

  return <step-node />;
}
```

The orchestration context tracks:
- Active tasks (`db.tasks`)
- Completed tasks
- Iteration count
- Stop/timeout state

## Best Practices for Durable Ralphing

<AccordionGroup>
  <Accordion title="Always set maxIterations">
    Without a limit, a bug in your state logic could cause infinite loops:
    ```tsx
    // Good - explicit limit
    <SmithersProvider maxIterations={50}>...</SmithersProvider>

    // Risky - could run forever
    <SmithersProvider maxIterations={Infinity}>...</SmithersProvider>
    ```
  </Accordion>

  <Accordion title="Use SQLite state for durability">
    State in SQLite survives restarts. State in memory doesn't:
    ```tsx
    // Good - durable, survives restarts
    const phase = db.state.get('phase') ?? "start";
    const setPhase = (p: string) => db.state.set('phase', p);

    // Bad - lost on restart
    const [phase, setPhase] = useState("start");
    ```
  </Accordion>

  <Accordion title="Handle iteration limits gracefully">
    Know when you've hit the limit:
    ```tsx
    <SmithersProvider
      maxIterations={50}
      onMaxIterations={() => {
        console.error("Workflow did not complete in 50 iterations");
        db.state.set("status", "needs_attention");
      }}
    >
    ```
  </Accordion>

  <Accordion title="Add verification gates">
    Explicit verification makes loops trustworthy:
    ```tsx
    <Claude
      onFinished={(result) => {
        if (result.output.includes("All tests pass")) {
          db.state.set("verified", "true");
        }
        // Iteration continues until verified
      }}
    >
      Run tests. If any fail, fix them.
    </Claude>
    ```
  </Accordion>
</AccordionGroup>

## SmithersProvider: The Root Ralph Loop

`<SmithersProvider>` is the root orchestration wrapper that manages the Ralph loop for your entire workflow.

**Default Behavior:**
By default, `<SmithersProvider>` runs the Ralph loop for up to **100 iterations**. This is sufficient for most workflows.

**Infinite Loops:**
For long-running orchestrations that need to continue indefinitely (like CI/CD monitors, autonomous agents, or server processes), you can configure it to run forever:

```tsx
import { SmithersProvider } from "smithers-orchestrator";

<SmithersProvider
  db={db}
  executionId={executionId}
  maxIterations={Infinity}
  onIteration={(i) => console.log(`Iteration ${i}`)}
>
  <Claude>
    Monitor the repository and respond to changes
  </Claude>
</SmithersProvider>
```

**Custom Iteration Limits:**
You can also set custom limits based on your workflow needs:

```tsx
// Quick task - only needs a few iterations
<SmithersProvider maxIterations={5}>
  <Claude>Fix the linting errors</Claude>
</SmithersProvider>

// Complex multi-phase workflow
<SmithersProvider maxIterations={50}>
  <MultiPhaseOrchestration />
</SmithersProvider>

// Long-running agent
<SmithersProvider maxIterations={Infinity}>
  <AutonomousAgent />
</SmithersProvider>
```

## Next Steps

<CardGroup cols={2}>
  <Card title="React State Management" icon="database" href="https://react.dev/learn/managing-state">
    Learn about React state from official docs
  </Card>
  <Card title="Database Persistence" icon="hard-drive" href="/concepts/database-persistence">
    Persist state across restarts
  </Card>
</CardGroup>
