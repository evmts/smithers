---
title: The Ralph Loop
description: How the plan evolves over time
---

# The Ralph Loop

[Ralph](https://ghuntley.com/ralph/) is the autonomous agent loop pattern. Each iteration:

1. ğŸ¨ Render React â†’ execution plan
2. â–¶ï¸ Execute runnable agents
3. ğŸ“ Agent output updates state
4. ğŸ”„ State change triggers re-render
5. âœ… Loop until done

```
Iteration 1: <Phase name="research">...</Phase>
Iteration 2: <Phase name="implement">...</Phase>  â† state changed
Iteration 3: <Phase name="implement">...</Phase>  â† agent still working
Iteration 4: <Phase name="test">...</Phase>       â† structured output
Iteration 5: <Phase name="done" />                â† loop complete
```

React handles diffing. Ralph handles iteration. SQLite handles persistence.

## The Execution Model

Smithers uses a reactive render loop powered by React state:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Render  â”‚â”€â”€â”€â–¶â”‚ Execute â”‚â”€â”€â”€â–¶â”‚ Update Signals   â”‚   â”‚
â”‚  â”‚  React   â”‚    â”‚ Agents  â”‚    â”‚ (onFinished)     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â–²                                   â”‚             â”‚
â”‚       â”‚                                   â”‚             â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                  (re-render on signal change)           â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

1. ğŸ¨ **Render**: Your React components render using React's state management
2. â–¶ï¸ **Execute**: `<Claude>` nodes execute via the Claude CLI
3. ğŸ“ **Update**: `onFinished` callbacks update React state
4. ğŸ”„ **Re-render**: State changes trigger reactive updates
5. âœ… **Loop**: Process repeats until no pending agents remain

## Why Smithers for Ralphing

You're not programming what agents *do*. You're programming the *plan*, and how it evolves.

| Other Frameworks | Smithers |
|------------------|----------|
| Program the agents (imperative) | Program the plan (declarative) |
| `agent.do_step_1()` | `<Phase name="implement">` |
| Plans live in prompts | Plans are reviewable code |
| Manual orchestration | Claude generates it for you |
| Static execution | Plan evolves based on agent output |

**Smithers is Terraform for agents.** You declare the desired workflow. The reconciler figures out how to get there.

## Controlling the Ralph Loop

You can control the Ralph loop using the `stopped` prop. This is the idiomatic way to stop iteration:

```tsx
import { SmithersProvider, useSmithers, Claude, If } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator/reactive-sqlite";

function IterativeWorkflowBody({ attempts, testsPassing }) {
  const { db } = useSmithers();

  return (
    <If condition={!testsPassing}>
      <Claude
        model="sonnet"
        onFinished={(result) => {
          db.db.run(
            "INSERT OR REPLACE INTO state (key, value) VALUES ('attempts', ?)",
            [attempts + 1]
          );
          if (result.output.includes("All tests pass")) {
            db.db.run(
              "INSERT OR REPLACE INTO state (key, value) VALUES ('tests_passing', 1)"
            );
          }
        }}
      >
        Fix the failing tests. Current attempt: {attempts}
      </Claude>
    </If>
  );
}

export function IterativeWorkflow({ db, executionId }) {
  // State in SQLite, not useState (see State Management docs)
  const { data: attemptsVal } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'attempts'"
  );
  const attempts = attemptsVal ?? 0;

  const { data: testsPassingVal } = useQueryValue<number>(
    db.db,
    "SELECT CAST(value AS INTEGER) as v FROM state WHERE key = 'tests_passing'"
  );
  const testsPassing = Boolean(testsPassingVal);

  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={5}
      stopped={testsPassing}
      onIteration={(i) => console.log(`Iteration ${i}`)}
      onComplete={() => console.log("Workflow complete")}
    >
      <IterativeWorkflowBody attempts={attempts} testsPassing={testsPassing} />
    </SmithersProvider>
  );
}
```

### Implicit Stopping

Ralph also stops implicitly when nothing renders for an iteration. If no components mount and register tasks within 500ms, the loop assumes the workflow is complete.

**What this means:**
- The 500ms is a *detection timeout*, not an execution limit
- Your agents can run for hours; this only applies to detecting when there's nothing left to do
- If any component calls `db.tasks.start()`, the loop waits for that task to complete

Using the `stopped` prop is more explicit and recommended.

## State: db.state vs db.tasks

Smithers has two state systems. Use the right one:

| API | Purpose | Example |
|-----|---------|---------|
| `db.state` | Workflow state that drives rendering | Current phase, attempt count, flags |
| `db.tasks` | Track in-flight async work | API calls, file operations, agent execution |

```tsx
// db.state: Controls WHAT renders
db.state.set("phase", "implement");  // Triggers re-render, shows different UI
const phase = db.state.get("phase");

// db.tasks: Controls WHEN the loop advances
const taskId = db.tasks.start("fetch-api");
await fetch("/api/data");
db.tasks.complete(taskId);  // Loop can now advance
```

**Rule of thumb:** `db.state` answers "what phase are we in?" `db.tasks` answers "is work still running?"

## useQueryValue: Reactive SQLite State

`useQueryValue` makes SQLite state reactive: when the database changes, your component re-renders:

```tsx
import { useQueryValue } from "smithers-orchestrator/reactive-sqlite";

function MyComponent() {
  const { db, reactiveDb } = useSmithers();
  
  // Reactive: re-renders when 'phase' changes in DB
  const { data: phase } = useQueryValue<string>(
    reactiveDb,
    "SELECT value FROM state WHERE key = 'phase'"
  );
  
  // Update triggers re-render automatically
  const setPhase = (p: string) => db.state.set("phase", p);
  
  return <Text>{phase ?? "loading..."}</Text>;
}
```

**vs useState:** `useState` is lost on restart and doesn't persist. `useQueryValue` reads from SQLite, survives restarts, and syncs across components.

## Reactive Updates

The power of the Ralph Loop comes from React reactivity:

```tsx
import { SmithersProvider, Claude, If } from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator/reactive-sqlite";

function PhaseWorkflowBody({ phase, setPhase }) {
  return (
    <>
      <If condition={phase === "research"}>
        <Claude onFinished={() => setPhase("implement")}>
          Research the problem space.
        </Claude>
      </If>

      <If condition={phase === "implement"}>
        <Claude onFinished={() => setPhase("test")}>
          Implement the solution.
        </Claude>
      </If>

      <If condition={phase === "test"}>
        <Claude onFinished={(r) => {
          if (r.output.includes("PASS")) {
            setPhase("done");
          } else {
            setPhase("implement");
          }
        }}>
          Run and verify tests.
        </Claude>
      </If>
    </>
  );
}

export function PhaseWorkflow({ db, executionId }) {
  // State in SQLite, not useState
  const { data: phaseVal } = useQueryValue<string>(
    db.db,
    "SELECT value FROM state WHERE key = 'phase'"
  );
  const phase = phaseVal ?? "research";

  const setPhase = (newPhase: string) => db.state.set('phase', newPhase);

  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}
      stopped={phase === "done"}
    >
      {/* This block re-renders when phase changes */}
      <PhaseWorkflowBody phase={phase} setPhase={setPhase} />
    </SmithersProvider>
  );
}
```

When `setPhase("implement")` is called:
1. The database state updates
2. `useQueryValue` detects the change and triggers a re-render
3. Only the affected branch re-renders
4. The new `<Claude>` component mounts and executes

## Fire-and-Forget Pattern

Components use `useMount` to execute when they mount:

```tsx
import { useMount } from "smithers-orchestrator";

function Claude(props) {
  useMount(() => {
    // Fire-and-forget async execution
    (async () => {
      const result = await executeClaudeAgent(props);
      props.onFinished?.(result);
    })();
  });

  return <claude-node {...props} />;
}
```

This means:
- Components execute when they mount
- Results trigger callbacks that update state
- State updates cause re-renders
- New components mount and execute

## React Workflow Rules

Smithers uses React as a workflow DSL. Understanding these rules prevents common mistakes.

### What persists vs what doesn't

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PERSISTS (survives restarts)          DOES NOT PERSIST          â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚ SQLite state (db.state)               useState / useRef         â”‚
â”‚ db.tasks entries                      Local variables           â”‚
â”‚ db.phases / db.steps                  Closures                  â”‚
â”‚ Execution records                     In-memory caches          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Dos and Don'ts

<AccordionGroup>
  <Accordion title="âœ… DO: Store state in SQLite">
    ```tsx
    // Good - durable
    const { data: phaseVal } = useQueryValue<string>(db.db,
      "SELECT value FROM state WHERE key = 'phase'");
    const phase = phaseVal ?? "start";
    const setPhase = (p: string) => db.state.set('phase', p);
    ```
  </Accordion>

  <Accordion title="âŒ DON'T: Use useState for workflow state">
    ```tsx
    // Bad - lost on restart, causes hydration issues
    const [phase, setPhase] = useState("start");
    ```
  </Accordion>

  <Accordion title="âœ… DO: Register async work with db.tasks">
    ```tsx
    // Good - orchestrator waits for this to complete
    const taskId = db.tasks.start('fetch-data');
    await fetchData();
    db.tasks.complete(taskId);
    ```
  </Accordion>

  <Accordion title="âŒ DON'T: Run untracked async work">
    ```tsx
    // Bad - orchestrator may advance before this completes
    useMount(() => {
      fetchData(); // No tracking!
    });
    ```
  </Accordion>

  <Accordion title="âœ… DO: Use onFinished callbacks to drive state">
    ```tsx
    // Good - state change triggers re-render
    <Claude onFinished={() => db.state.set('phase', 'next')}>
      Do work
    </Claude>
    ```
  </Accordion>

  <Accordion title="âŒ DON'T: Expect re-renders without state changes">
    ```tsx
    // Bad - nothing triggers advancement
    <Claude onFinished={() => console.log('done')}>
      Do work
    </Claude>
    // Workflow stalls because state didn't change
    ```
  </Accordion>
</AccordionGroup>

### What triggers re-renders

1. **SQLite state changes** via `useQueryValue` or `useQuery`
2. **Task completion** detected by orchestration loop
3. **Phase/Step advancement** managed by PhaseRegistryProvider
4. **Stop conditions** met (token limit, pattern match, timeout)

### Common anti-patterns

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| `useState` for phase | Lost on restart | Use `db.state` + `useQueryValue` |
| Untracked promises | Orchestrator advances early | Use `db.tasks.start/complete` |
| No `onFinished` callback | Workflow stalls | Always update state in `onFinished` |
| Infinite `maxIterations` | Runaway loops | Set reasonable limits (10-100) |

## Orchestration Context

SmithersProvider exposes orchestration context via `useSmithers()`:

```tsx
import { useSmithers, useMount } from "smithers-orchestrator";
import { useRef } from "react";

function CustomStep() {
  const { db } = useSmithers();
  const taskIdRef = useRef<string | null>(null);

  useMount(() => {
    taskIdRef.current = db.tasks.start("custom-step");

    doSomeWork().finally(() => {
      if (taskIdRef.current) {
        db.tasks.complete(taskIdRef.current);
      }
    });
  });

  return <step-node />;
}
```

The orchestration context tracks:
- Active tasks (`db.tasks`)
- Completed tasks
- Iteration count
- Stop/timeout state

## Best Practices for Durable Ralphing

<AccordionGroup>
  <Accordion title="Always set maxIterations">
    Without a limit, a bug in your state logic could cause infinite loops:
    ```tsx
    // Good - explicit limit
    <SmithersProvider maxIterations={50}>...</SmithersProvider>

    // Risky - could run forever
    <SmithersProvider maxIterations={Infinity}>...</SmithersProvider>
    ```
  </Accordion>

  <Accordion title="Use SQLite state for durability">
    State in SQLite survives restarts. State in memory doesn't:
    ```tsx
    // Good - durable, survives restarts
    const phase = db.state.get('phase') ?? "start";
    const setPhase = (p: string) => db.state.set('phase', p);

    // Bad - lost on restart
    const [phase, setPhase] = useState("start");
    ```
  </Accordion>

  <Accordion title="Handle iteration limits gracefully">
    Know when you've hit the limit:
    ```tsx
    <SmithersProvider
      maxIterations={50}
      onMaxIterations={() => {
        console.error("Workflow did not complete in 50 iterations");
        db.state.set("status", "needs_attention");
      }}
    >
    ```
  </Accordion>

  <Accordion title="Add verification gates">
    Explicit verification makes loops trustworthy:
    ```tsx
    <Claude
      onFinished={(result) => {
        if (result.output.includes("All tests pass")) {
          db.state.set("verified", "true");
        }
        // Iteration continues until verified
      }}
    >
      Run tests. If any fail, fix them.
    </Claude>
    ```
  </Accordion>
</AccordionGroup>

## Nested Loops (Subralphs)

Smithers supports multiple patterns for nested execution within a Ralph loop:

### While: Condition-Based Subloops

`<While>` creates a subloop that iterates until a condition is false:

```tsx
import { While, Claude, useWhileIteration } from "smithers-orchestrator";

function FixTests() {
  const ctx = useWhileIteration();
  return (
    <Claude
      onFinished={(r) => {
        if (r.output.includes("All tests pass")) {
          ctx?.signalComplete(); // Exits the While loop
        }
      }}
    >
      Run tests. If any fail, fix them. Attempt {ctx?.iteration ?? 0}.
    </Claude>
  );
}

<While id="test-loop" condition={() => true} maxIterations={10}>
  <FixTests />
</While>
```

`While` state persists in SQLite (`while.{id}.iteration`, `while.{id}.status`), so loops survive restarts.

### Smithers: Autonomous Subagents

`<Smithers>` spawns a completely independent subagent that plans and executes a complex task:

```tsx
import { Smithers } from "smithers-orchestrator";

<Smithers
  plannerModel="opus"      // Plans the work
  executionModel="sonnet"  // Executes each step
  timeout={3600000}        // 1 hour limit
  keepScript               // Save generated script for debugging
  onFinished={(result) => {
    console.log(`Completed in ${result.durationMs}ms`);
    db.state.set("phase", "next");
  }}
>
  Implement the notification system: database schema, REST API, WebSocket updates, React components, and tests.
</Smithers>
```

The `<Smithers>` component:
1. Uses Claude to generate a complete Smithers script for the task
2. Executes that script as a subprocess with its own Ralph loop
3. Reports results back to the parent workflow

Subagents can spawn their own subagents for arbitrarily deep nesting.

### Subagent: Named Execution Boundaries

`<Subagent>` groups related agents for debugging and optional parallel execution:

```tsx
import { Subagent, Claude } from "smithers-orchestrator";

<Subagent name="research" parallel>
  <Claude>Research topic A</Claude>
  <Claude>Research topic B</Claude>
</Subagent>
```

### When to Use Each

| Pattern | Use Case |
|---------|----------|
| `While` | Retry loops, polling, iterating until condition |
| `Smithers` | Complex autonomous subtasks needing their own planning |
| `Subagent` | Grouping agents, parallel execution, named scopes |
| `Phase/Step` | Sequential workflow stages |

---

## SmithersProvider: The Root Ralph Loop

`<SmithersProvider>` is the root orchestration wrapper that manages the Ralph loop for your entire workflow.

**Default Behavior:**
By default, `<SmithersProvider>` runs the Ralph loop for up to **100 iterations**. This is sufficient for most workflows.

**Infinite Loops:**
For long-running orchestrations that need to continue indefinitely (like CI/CD monitors, autonomous agents, or server processes), you can configure it to run forever:

```tsx
import { SmithersProvider } from "smithers-orchestrator";

<SmithersProvider
  db={db}
  executionId={executionId}
  maxIterations={Infinity}
  onIteration={(i) => console.log(`Iteration ${i}`)}
>
  <Claude>
    Monitor the repository and respond to changes
  </Claude>
</SmithersProvider>
```

**Custom Iteration Limits:**
You can also set custom limits based on your workflow needs:

```tsx
// Quick task - only needs a few iterations
<SmithersProvider maxIterations={5}>
  <Claude>Fix the linting errors</Claude>
</SmithersProvider>

// Complex multi-phase workflow
<SmithersProvider maxIterations={50}>
  <MultiPhaseOrchestration />
</SmithersProvider>

// Long-running agent
<SmithersProvider maxIterations={Infinity}>
  <AutonomousAgent />
</SmithersProvider>
```

## Complete Example: Retry Until Tests Pass

This example shows all the pieces working together:

```tsx
#!/usr/bin/env bun
import {
  createSmithersRoot,
  createSmithersDB,
  SmithersProvider,
  Claude,
  If,
  useSmithers,
} from "smithers-orchestrator";
import { useQueryValue } from "smithers-orchestrator/reactive-sqlite";

const db = createSmithersDB({ path: ".smithers/retry-tests.db" });
const executionId = db.execution.start("Retry Tests", "retry.tsx");

function RetryWorkflow() {
  const { db, reactiveDb } = useSmithers();

  // Reactive state from SQLite
  const { data: attemptsRaw } = useQueryValue<number>(
    reactiveDb,
    "SELECT CAST(value AS INTEGER) FROM state WHERE key = 'attempts'"
  );
  const attempts = attemptsRaw ?? 0;

  const { data: doneRaw } = useQueryValue<number>(
    reactiveDb,
    "SELECT CAST(value AS INTEGER) FROM state WHERE key = 'done'"
  );
  const done = Boolean(doneRaw);

  return (
    <If condition={!done}>
      <Claude
        model="sonnet"
        onFinished={(result) => {
          db.state.set("attempts", attempts + 1);
          if (result.output.includes("All tests pass")) {
            db.state.set("done", 1);  // Stops the loop
          }
        }}
      >
        Run the tests. If any fail, fix them. Attempt #{attempts + 1}.
      </Claude>
    </If>
  );
}

function App() {
  const { data: doneRaw } = useQueryValue<number>(
    db.reactive,
    "SELECT CAST(value AS INTEGER) FROM state WHERE key = 'done'"
  );
  const done = Boolean(doneRaw);

  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}
      stopped={done}  // Explicit stop condition
    >
      <RetryWorkflow />
    </SmithersProvider>
  );
}

const root = createSmithersRoot();
await root.mount(App);
await db.close();
```

**What happens:**
1. Loop starts, `done=false`, `attempts=0`
2. Claude runs tests, fails, calls `onFinished`
3. `db.state.set("attempts", 1)` triggers re-render
4. Loop iterates, Claude runs again
5. Tests pass â†’ `db.state.set("done", 1)`
6. `stopped={done}` becomes `true`, loop exits

## Next Steps

<CardGroup cols={2}>
  <Card title="Database Persistence" icon="hard-drive" href="/concepts/database-persistence">
    Persist state across restarts
  </Card>
  <Card title="Examples" icon="code" href="/examples/coverage-loop">
    See more working examples
  </Card>
</CardGroup>
