#!/usr/bin/env bun
import { createSmithersRoot } from 'smithers-orchestrator'
import { createSmithersDB } from 'smithers-orchestrator/db'
import {
  Ralph,
  SmithersProvider,
  Claude,
  Phase,
  Step,
  Review,
} from 'smithers-orchestrator/components'
import { Commit, Snapshot, Describe, Status } from 'smithers-orchestrator/components/JJ'
import { PostCommit, OnCIFailure } from 'smithers-orchestrator/components/Hooks'

/**
 * Smithers Orchestration Template
 *
 * Declarative AI agent workflow using the Smithers framework.
 * ALL STATE LIVES IN SQLITE - fully auditable, recoverable, and predictable.
 *
 * Run with:
 *   bunx smithers-orchestrator monitor
 */

// ============================================================================
// DATABASE SETUP - ALL DURABLE STATE LIVES HERE (SQLite)
// ============================================================================

const db = await createSmithersDB({
  path: '.smithers/data',
})

const executionId = await db.execution.start(
  'My Orchestration',
  '.smithers/main.tsx',
  {
    maxIterations: 10,
    model: 'sonnet',
  }
)

// ============================================================================
// ORCHESTRATION DEFINITION
// ============================================================================

async function App() {
  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}
      globalTimeout={1800000}
      snapshotOnStart
      stopConditions={[
        { type: 'total_tokens', value: 500000, message: 'Token budget exceeded' }
      ]}
      onComplete={() => console.log('Orchestration complete')}
      onError={(err) => console.error('Orchestration error:', err)}
    >
      <Ralph>
        {/* ============================================================ */}
        {/* PHASE 1: IMPLEMENTATION                                      */}
        {/* Phases execute sequentially. Next starts when previous ends. */}
        {/* ============================================================ */}
        <Phase
          name="Implementation"
          onStart={() => console.log('Starting implementation phase')}
          onComplete={() => console.log('Implementation phase complete')}
        >
          <Snapshot description="Before implementation" />

          <Status
            onDirty={(status) => console.log('Working copy has changes:', status)}
            onClean={() => console.log('Working copy is clean')}
          />

          <Step name="implement-feature" snapshotBefore commitAfter>
            <Claude
              model="sonnet"
              reportingEnabled
              allowedTools={['Read', 'Edit', 'Write', 'Bash', 'Glob', 'Grep']}
              stopConditions={[
                { type: 'turn_limit', value: 50 },
                { type: 'token_limit', value: 100000 },
              ]}
              onError={(error) => console.error('Implementation failed:', error)}
            >
              Implement the requested feature. Use the Report tool to log progress.
            </Claude>
          </Step>

          <Describe useAgent="claude" />
          <Commit autoDescribe notes="implementation-phase" />
        </Phase>

        {/* ============================================================ */}
        {/* PHASE 2: CODE REVIEW                                         */}
        {/* ============================================================ */}
        <Phase
          name="Review"
          onStart={() => console.log('Starting review phase')}
          onComplete={() => console.log('Review phase complete')}
        >
          <Review
            target={{ type: 'diff', ref: 'main' }}
            agent="claude"
            model="sonnet"
            blocking
            criteria={[
              'No security vulnerabilities',
              'Code follows project conventions',
              'Tests are included for new functionality',
              'No performance regressions',
            ]}
            postToGitNotes
            onFinished={(review) => {
              if (review.approved) {
                console.log('Review approved!')
              } else {
                console.log('Review found issues:', review.issues.length)
              }
            }}
          />
        </Phase>

        {/* ============================================================ */}
        {/* PHASE 3: TESTING                                             */}
        {/* ============================================================ */}
        <Phase
          name="Testing"
          onStart={() => console.log('Starting testing phase')}
          onComplete={() => console.log('Testing phase complete')}
        >
          <Step name="run-tests">
            <Claude
              model="haiku"
              allowedTools={['Bash']}
              stopConditions={[{ type: 'turn_limit', value: 10 }]}
              onFinished={(result) => {
                const passed = result.output.includes('PASS') ||
                               result.output.includes('All tests passed')
                console.log(passed ? 'Tests passed!' : 'Tests failed')
              }}
            >
              Run the test suite with `bun test`. Report the results.
            </Claude>
          </Step>
        </Phase>

        {/* ============================================================ */}
        {/* PHASE 4: FINALIZE                                            */}
        {/* ============================================================ */}
        <Phase
          name="Finalize"
          onStart={() => console.log('Starting finalize phase')}
          onComplete={() => console.log('Orchestration complete!')}
        >
          <Commit message="Feature complete - all tests passing" />
        </Phase>
      </Ralph>

      {/* ============================================================ */}
      {/* HOOKS: AUTOMATED RESPONSES                                   */}
      {/* ============================================================ */}

      <PostCommit runOn="smithers-only">
        <Review
          target={{ type: 'commit', ref: 'HEAD' }}
          postToGitNotes
        />
      </PostCommit>

      <OnCIFailure provider="github-actions" pollInterval={60000}>
        <Claude
          model="sonnet"
          allowedTools={['Read', 'Edit', 'Bash']}
        >
          CI has failed. Analyze the failure logs and fix the issue.
        </Claude>
        <Commit autoDescribe notes="ci-fix" />
      </OnCIFailure>
    </SmithersProvider>
  )
}

// ============================================================================
// EXECUTION
// ============================================================================

async function main() {
  const root = createSmithersRoot()

  try {
    console.log('╔══════════════════════════════════════════════════════════╗')
    console.log('║            SMITHERS ORCHESTRATION PLAN                   ║')
    console.log('╚══════════════════════════════════════════════════════════╝')
    console.log('')
    console.log('Database: .smithers/data (SQLite)')
    console.log('Execution ID:', executionId)
    console.log('')
    console.log('To inspect:')
    console.log('  bunx smithers-orchestrator db state')
    console.log('  bunx smithers-orchestrator db commits')
    console.log('  bunx smithers-orchestrator db reviews')
    console.log('  bunx smithers-orchestrator db reports')
    console.log('')
    console.log('═══════════════════════════════════════════════════════════')
    console.log('')

    await root.mount(App)
    root.dispose()

    const finalState = await db.state.getAll()
    await db.execution.complete(executionId, finalState)

    console.log('')
    console.log('✅ Execution complete!')

    const execution = await db.execution.get(executionId)
    if (execution) {
      console.log('Summary:')
      console.log(`  Duration: ${execution.completed_at
        ? new Date(execution.completed_at).getTime() - new Date(execution.started_at!).getTime()
        : 0}ms`)
      console.log(`  Agents: ${execution.total_agents}`)
      console.log(`  Tool calls: ${execution.total_tool_calls}`)
      console.log(`  Tokens: ${execution.total_tokens_used}`)
    }

  } catch (error) {
    console.error('')
    console.error('❌ Execution failed:', error)

    root.dispose()
    await db.execution.fail(
      executionId,
      error instanceof Error ? error.message : String(error)
    )

    process.exit(1)
  } finally {
    await db.close()
  }
}

main().catch(console.error)
