#!/usr/bin/env bun
import { createSmithersRoot } from 'smithers'
import { createSmithersDB } from 'smithers-orchestrator/db'
import { Ralph } from 'smithers/components/Ralph'

// Enhanced components with database integration
import { SmithersProvider, useSmithers } from 'smithers-orchestrator/components/SmithersProvider'
import { Orchestration } from 'smithers-orchestrator/components/Orchestration'
import { Claude } from 'smithers-orchestrator/components/Claude'
import { Phase } from 'smithers-orchestrator/components/Phase'
import { Step } from 'smithers-orchestrator/components/Step'

// VCS components
import { Commit, Snapshot, Describe, Status, Rebase } from 'smithers/components/JJ'
import { Commit as GitCommit, Notes as GitNotes } from 'smithers/components/Git'

// Review and hooks
import { Review } from 'smithers/components/Review'
import { PostCommit, OnCIFailure } from 'smithers/components/Hooks'

/**
 * Smithers Orchestration Template
 *
 * This is a declarative AI agent workflow using the Smithers framework.
 * Edit this file to define your multi-agent orchestration.
 *
 * ALL STATE LIVES IN PGLITE - fully auditable, recoverable, and predictable.
 *
 * Run with:
 *   bunx smithers-orchestrator monitor
 */

// ============================================================================
// DATABASE SETUP - ALL STATE LIVES HERE
// ============================================================================

// Create PGlite database (persisted to .smithers/data)
const db = await createSmithersDB({
  path: '.smithers/data',
})

// Start execution tracking
const executionId = await db.execution.start(
  'My Orchestration',
  '.smithers/main.tsx',
  {
    maxIterations: 10,
    model: 'sonnet',
  }
)

// ============================================================================
// STATE HELPERS (replaces Zustand)
// ============================================================================

/**
 * Get current phase from database
 */
async function getPhase(): Promise<string> {
  return (await db.state.get<string>('phase')) ?? 'initial'
}

/**
 * Set phase with audit logging
 */
async function setPhase(phase: string, trigger: string = 'agent_finished'): Promise<void> {
  await db.state.set('phase', phase, trigger)
}

// ============================================================================
// ORCHESTRATION DEFINITION
// ============================================================================

async function App() {
  const phase = await getPhase()

  return (
    <SmithersProvider db={db} executionId={executionId}>
      <Orchestration
        globalTimeout={1800000} // 30 minutes
        snapshotBeforeStart
        stopConditions={[
          { type: 'pattern', value: /STOP_ORCHESTRATION/i, message: 'Agent requested stop' }
        ]}
      >
        <Ralph maxIterations={10}>
          {/* ============================================================ */}
          {/* PHASE 1: IMPLEMENTATION                                      */}
          {/* ============================================================ */}
          {phase === 'initial' && (
            <Phase name="Implementation">
              {/* Take a JJ snapshot before starting */}
              <Snapshot description="Before implementation" />

              {/* Check working copy status */}
              <Status
                onDirty={(status) => {
                  console.log('Working copy has changes:', status)
                }}
                onClean={() => {
                  console.log('Working copy is clean')
                }}
              />

              {/* Main implementation step with Claude */}
              <Step
                name="implement-feature"
                snapshotBefore
                commitAfter
              >
                <Claude
                  model="sonnet"
                  reportingEnabled
                  tools={['Read', 'Edit', 'Write', 'Bash', 'Glob', 'Grep']}
                  stopConditions={[
                    { type: 'turn_limit', value: 50 },
                    { type: 'token_limit', value: 100000 },
                  ]}
                  onFinished={async (result) => {
                    console.log('Implementation complete')
                    await setPhase('review', 'implementation_complete')
                  }}
                  onError={async (error) => {
                    console.error('Implementation failed:', error)
                    await setPhase('error', 'implementation_failed')
                  }}
                >
                  {/* Your implementation prompt here */}
                  Implement the requested feature. Use the Report tool to log progress.
                </Claude>
              </Step>

              {/* Auto-generate commit message using AI */}
              <Describe useAgent="claude" />

              {/* Create JJ commit with metadata */}
              <Commit autoDescribe notes="implementation-phase" />
            </Phase>
          )}

          {/* ============================================================ */}
          {/* PHASE 2: CODE REVIEW                                         */}
          {/* ============================================================ */}
          {phase === 'review' && (
            <Phase name="Review">
              <Review
                target={{ type: 'diff', ref: 'main' }}
                agent="claude"
                model="sonnet"
                blocking
                criteria={[
                  'No security vulnerabilities',
                  'Code follows project conventions',
                  'Tests are included for new functionality',
                  'No performance regressions',
                ]}
                postToGitNotes
                onFinished={async (review) => {
                  if (review.approved) {
                    console.log('Review approved!')
                    await setPhase('testing', 'review_approved')
                  } else {
                    console.log('Review found issues:', review.issues.length)
                    // Go back to implementation to fix issues
                    await setPhase('initial', 'review_rejected')
                  }
                }}
              />
            </Phase>
          )}

          {/* ============================================================ */}
          {/* PHASE 3: TESTING                                             */}
          {/* ============================================================ */}
          {phase === 'testing' && (
            <Phase name="Testing">
              <Step name="run-tests">
                <Claude
                  model="haiku"
                  tools={['Bash']}
                  stopConditions={[
                    { type: 'turn_limit', value: 10 },
                  ]}
                  onFinished={async (result) => {
                    const passed = result.output.includes('PASS') ||
                                   result.output.includes('All tests passed')
                    if (passed) {
                      await setPhase('done', 'tests_passed')
                    } else {
                      await setPhase('initial', 'tests_failed')
                    }
                  }}
                >
                  Run the test suite with `bun test`. Report the results.
                </Claude>
              </Step>
            </Phase>
          )}

          {/* ============================================================ */}
          {/* TERMINAL: SUCCESS                                            */}
          {/* ============================================================ */}
          {phase === 'done' && (
            <Phase name="Complete">
              <Commit message="Feature complete - all tests passing" />
              <div>Orchestration complete!</div>
            </Phase>
          )}

          {/* ============================================================ */}
          {/* TERMINAL: ERROR                                              */}
          {/* ============================================================ */}
          {phase === 'error' && (
            <Phase name="Error Recovery">
              <Claude
                model="sonnet"
                tools={['Read', 'Bash']}
                onFinished={async () => {
                  await setPhase('initial', 'error_diagnosed')
                }}
              >
                An error occurred. Diagnose the issue and suggest fixes.
              </Claude>
            </Phase>
          )}
        </Ralph>

        {/* ============================================================ */}
        {/* HOOKS: AUTOMATED RESPONSES                                   */}
        {/* ============================================================ */}

        {/* Run review on every commit made by Smithers */}
        <PostCommit runOn="smithers-only">
          <Review
            target={{ type: 'commit', ref: 'HEAD' }}
            postToGitNotes
          />
        </PostCommit>

        {/* Auto-fix CI failures */}
        <OnCIFailure provider="github-actions" pollInterval={60000}>
          <Claude
            model="sonnet"
            tools={['Read', 'Edit', 'Bash']}
          >
            CI has failed. Analyze the failure logs and fix the issue.
          </Claude>
          <Commit autoDescribe notes="ci-fix" />
        </OnCIFailure>
      </Orchestration>
    </SmithersProvider>
  )
}

// ============================================================================
// EXECUTION
// ============================================================================

async function main() {
  try {
    const root = createSmithersRoot()

    console.log('╔══════════════════════════════════════════════════════════╗')
    console.log('║            SMITHERS ORCHESTRATION PLAN                   ║')
    console.log('╚══════════════════════════════════════════════════════════╝')
    console.log('')
    console.log('Database: .smithers/data')
    console.log('Execution ID:', executionId)
    console.log('')
    console.log('All state lives in PGlite - fully auditable!')
    console.log('')
    console.log('To inspect:')
    console.log('  bunx smithers-orchestrator db state')
    console.log('  bunx smithers-orchestrator db commits')
    console.log('  bunx smithers-orchestrator db reviews')
    console.log('  bunx smithers-orchestrator db reports')
    console.log('')
    console.log('═══════════════════════════════════════════════════════════')
    console.log('')

    // Execute the orchestration
    await root.mount(App)

    // Mark execution as complete
    const finalState = await db.state.getAll()
    await db.execution.complete(executionId, finalState)

    console.log('')
    console.log('✅ Execution complete!')
    console.log('')

    // Show summary
    const execution = await db.execution.get(executionId)
    if (execution) {
      console.log('Summary:')
      console.log(`  Duration: ${execution.completed_at
        ? new Date(execution.completed_at).getTime() - new Date(execution.started_at!).getTime()
        : 0}ms`)
      console.log(`  Agents: ${execution.total_agents}`)
      console.log(`  Tool calls: ${execution.total_tool_calls}`)
      console.log(`  Tokens: ${execution.total_tokens_used}`)
    }

  } catch (error) {
    console.error('')
    console.error('❌ Execution failed:', error)
    console.error('')

    await db.execution.fail(
      executionId,
      error instanceof Error ? error.message : String(error)
    )

    process.exit(1)
  } finally {
    await db.close()
  }
}

main().catch(console.error)
